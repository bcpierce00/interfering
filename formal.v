Require Import List.
Import ListNotations.
Require Import Bool.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Omega.
Require Import Trace.
Require Import Machine.
Require Import ObsTrace.
(* Require Import Paco.paco. *)

(****************************)
(***** Eager Integrity ******)
(****************************)

(* Latex-like definition. *)
Definition EagerStackIntegrityThru (C : Contour) (MP: MPTrace) : Prop :=
    forall (k: Component), integrityOf (C k) = HI ->
      forall (mp : MPState),
        InTrace mp MP -> ms (head MP) k = ms mp k.

Create HintDb StackSafety.

(* CoInductive variant *)
(* RB: TODO: Indexing over the contour as well to get cleaner coinduction with
   Paco while sorting things out. *)
CoInductive EagerStackIntegrityInd(*_gen R*) :
  Contour -> MPTrace -> Prop :=
| SI_finished : forall C mp,
    EagerStackIntegrityInd(*_gen R*) C (finished mp)
| SI_notfinished :
    forall (C : Contour) (mp: MPState) (MP : MPTrace),
    (forall (k: Component), integrityOf (C k) = HI -> ms mp k = ms (head MP) k) ->
    (*R*)EagerStackIntegrityInd C MP ->
    EagerStackIntegrityInd(*_gen R*) C (notfinished mp MP).
Hint Constructors EagerStackIntegrityInd(*_gen*) : core.

(* Definition EagerStackIntegrity' (C : Contour) (MP : MPTrace) := *)
(*   paco2 EagerStackIntegrity'_gen bot2 C MP. *)
(* Hint Unfold EagerStackIntegrity' : core. *)
(* Lemma EagerStackIntegrity'_mon : monotone2 EagerStackIntegrity'_gen. Proof. pmonauto. Qed. *)
(* Hint Resolve EagerStackIntegrity'_mon : paco. *)

(* RB: TODO: See if these work as well as the old version. *)
Hint Constructors EagerStackIntegrityInd(*_gen*) : StackSafety.

Lemma StackIntegrityThruEquiv : forall (C:Contour) (MP: MPTrace),
     EagerStackIntegrityThru C MP -> EagerStackIntegrityInd C MP.
Proof.
  intros C. cofix COFIX.
  intros MP H(*; pfold*).
  destruct MP.
  - constructor.
  - constructor.
    + intros. unfold EagerStackIntegrityThru in H.  simpl in H.
      apply H; auto. constructor. apply head_InTrace.
    + (*right.*) apply COFIX.
      unfold EagerStackIntegrityThru in *.  intros. simpl in H.
      erewrite <- H; auto.
      * apply H; auto.  constructor. auto.
      * constructor. apply head_InTrace.
Qed.

Lemma StackIntegrityIndEquiv : forall (C:Contour) (MP: MPTrace),
     EagerStackIntegrityInd C MP -> EagerStackIntegrityThru C MP.
Proof.
  unfold EagerStackIntegrityThru.
  intros C MP H1 k H2 mp H3.
  induction H3 as [| | ? ? ? IHInTrace].
  - auto.
  - auto.
  - simpl. inversion H1. subst. rewrite <- IHInTrace.
    +  apply H5; auto.
       (* punfold H6. *)
    +  apply H6.
Qed.

Definition EagerStackIntegrityEnd (C:Contour) (mp:MPState) (justReturned:MachineState -> Prop) : Prop :=
  forall MP mp',
    PrefixUpTo (fun mp => justReturned (ms mp)) (MPTraceOf mp) MP ->
    Last MP mp' ->
    (forall k, integrityOf (C k) = HI -> (ms mp) k = (ms mp') k).

(* NB: It doesn't matter whether we calculate this at a
call instruction (as in a subtrace) or at the first
instruction of the callee (as in the top-level trace)
assuming that registers remain LI,LC at all times. *)
(* SNA: With code in the contour, this actually does matter:
   it needs to be the first instruction of the caller. *)
Definition variantOf (m n : MachineState) (C : Contour) :=
  forall (k : Component), confidentialityOf (C k) = LC ->
                          m k = n k.

Hint Unfold variantOf : StackSafety.

Hint Constructors ObsTraceEq(*_gen*) : StackSafety.

Hint Constructors ObsTracePrefix(*_gen*) : StackSafety.

(* The entire trace MP represents a callee, that terminates when (and if)
   control has returned to the caller, according to the "justReturned" predicate.
   Note: If we are at a toplevel trace, "justReturn" will never hold. *)
Definition EagerStackConfidentialityOld (C : Contour) (MP : MPTrace)
           (justReturned : MachineState -> Prop) :=
  forall m' M',
    (* If m' is a variant of the initial state of MP... *)
    variantOf (ms (head MP)) m' C ->
    (* And if M' is the longest prefix of the traced generated by m'
       up to and including the point where control has returned to the
       caller (or the whole trace if the callee doesn't return control)... *)
    PrefixUpTo justReturned (MTraceOf m') M' ->
    (* There are three cases to consider now: *)

    (* 1. The callee ends succesfully with a return. *)
    (forall mpret, Last MP mpret -> justReturned (ms mpret) ->
     (* Then: 
        - M' also terminates in some state mret'.
        - And for every component k whose value changed either between the 
          initial and final states of MP or of M', then the final states agree 
          on the value of k.
        - And the observations of MP and M' are the same. 
      *)
      (exists mret', Last M' mret' /\
                     forall k, 
                       (ms (head MP) k <> ms mpret k \/ (head M') k <> mret' k) ->
                       ms mpret k = mret' k) /\
      (ObsTraceOf MP) ~=_O (ObsTraceOfM M')) /\

    (* 2. The callee trace is cut short by a monitor fault. *)
    (forall mpret, Last MP mpret -> (* mpstep mpret = None -> *)
                   ~ justReturned (ms mpret) ->
     (* Then: 
        - The observations of the MP trace are a prefix of the 
          observations of M'.
      *)
     (ObsTraceOf MP) <=_O (ObsTraceOfM M')) /\
    
    (* 3. The callee trace never returns. *) 
    ((forall mpret, ~ Last MP mpret) ->
     (* Then: 
        - The variant trace never returns.
        - The observations of MP and M' are the same. 
      *)
     forall mret', ~ Last M' mret' /\
                   (ObsTraceOf MP) ~=_O (ObsTraceOfM M')).

Hint Unfold EagerStackConfidentialityOld : StackSafety.

Definition ObsEqUpToHalt (MPO : MPTrace') (MO : MTrace') : Prop :=
  ObsOfMP MPO <=_O ObsOfM MO /\
  (infinite MPO -> ObsOfMP MPO ~=_O ObsOfM MO).
(* APT: There is something fishy about this definition.
   First of all, it doesn't quite match the latex, because the predicate
   can hold even if we cannot show that MPO  is finite or infinite.
   (And that is not a given constructively.)

   But also, using some facts proved at the bottom of ObsTrace.v
   (which rely on a new alternative coinductive characterization of Infinite traces):
*)

Remark redundant: forall (MPO: MPTrace') (MO: MTrace'), 
   ObsOfMP MPO <=_O ObsOfM MO -> 
   infinite MPO -> 
   ObsOfMP MPO ~=_O ObsOfM MO.
Proof.
  intros.
  apply inf_infObsOfMP in H0. 
  apply infiniteObsTracePrefixEq; auto. 
Qed.
   
(* 
   So the second clause of the /\ follows from the first, and so this definition of ObsEqUpToHalt reduces to just <=_O. 
*)

Inductive RunUpTo {A} (f : A -> Prop) : TraceOf (A * Observation) -> TraceOf (A * Observation) -> Prop :=
| FNowFinished : forall a o, RunUpTo f (finished (a,o)) (finished (a,Tau))
| FNowNotFinished : forall a o T, f a -> RunUpTo f (notfinished (a,o) T) (finished (a,Tau))
| FLater : forall a o T Tpre,
    ~ f a ->
    RunUpTo f T Tpre ->
    RunUpTo f (notfinished (a,o) T) (notfinished (a,o) Tpre).

Definition EagerStackConfidentiality (C : Contour) (mp : MPState) (justReturned : MachineState -> Prop) :=
  forall m' callMPO call'MO,
    variantOf (ms mp) m' C ->
    RunUpTo (fun mp => justReturned (ms mp)) (MPRunOf mp) callMPO ->
    RunUpTo (fun m => justReturned m) (RunOf m') call'MO ->
    (forall mpret o, Last callMPO (mpret,o) ->
                     exists m'ret o', Last call'MO (m'ret,o') /\
                                      (ObsOfMP callMPO) ~=_O (ObsOfM call'MO) /\
                                      forall k, 
                                        (ms mp k <> ms mpret k \/ m' k <> m'ret k) ->
                                        ms mpret k = m'ret k) /\
    (* Case 2: The call runs forever without returning *)
    (Infinite callMPO ->
     Infinite call'MO /\
     ObsOfMP callMPO ~=_O ObsOfM call'MO) /\
    (* Case 3: The policy fail-stops before the call returns *)
    (forall mpohalt, Last callMPO mpohalt ->
                     ~ justReturned (ms (fst mpohalt)) ->
                     ObsOfMP callMPO <=_O ObsOfM call'MO)
.

CoInductive StrongEagerStackConfidentiality(*_gen*) (R : MachineState -> Prop) (*Rcoind*) :
  MPTrace -> MachineState -> Prop :=
| StrongConfStep :
    (* Maybe the top one should have a not ret *)
    forall mp MP m m' O,
      mpstep mp = Some (ms (head MP), ps (head MP), O) ->
      step m = (m', O) ->
      ~ R (ms mp) -> ~ R m ->
      (forall k, ms (head MP) k <> ms mp k \/
                 m' k <> m k -> ms (head MP) k = m' k) ->
      (*Rcoind*)StrongEagerStackConfidentiality R MP m' ->
      StrongEagerStackConfidentiality(*_gen*) R (*Rcoind*) (notfinished mp MP) m
| StrongConfEnd :
    forall mp m,
      R (ms mp) -> R m ->
      StrongEagerStackConfidentiality(*_gen*) R (*Rcoind*) (finished mp) m
| StrongConfNotMStep :
    forall mp m,
      ~ (R (ms mp)) -> ~ R m ->
      (* mpstep mp = None ->  *)
      StrongEagerStackConfidentiality(*_gen*) R (*Rcoind*) (finished mp) m.
Hint Constructors StrongEagerStackConfidentiality(*_gen*) : core.

(* Definition StrongEagerStackConfidentiality (R : MachineState -> Prop) MP M := *)
(*   paco2 (StrongEagerStackConfidentiality_gen R) bot2 MP M. *)
(* Hint Unfold StrongEagerStackConfidentiality : core. *)
(* Lemma StrongEagerStackConfidentiality_mon (R : MachineState -> Prop) : monotone2 (StrongEagerStackConfidentiality_gen R). Proof. pmonauto. Qed. *)
(* Hint Resolve StrongEagerStackConfidentiality_mon : paco. *)

Hint Constructors StrongEagerStackConfidentiality(*_gen*) : StackSafety.

Lemma confStepPreservesVariant :
  forall C mp m' p' OM mv mv' ON,
    mpstep mp = Some (m', p', OM) ->
    step mv = (mv', ON) ->
    (forall k, m' k <> ms mp k \/ mv' k <> mv k -> m' k = mv' k) ->
    variantOf (ms mp) mv C ->
    variantOf m' mv' C.
Proof.
  unfold variantOf.
  intros C mp m' p' OM mv mv' ON StepM StepN Conf Var k Hk.
  destruct (WordEqDec (m' k) (ms mp k)) as [eqM | neqM];
  destruct (WordEqDec (mv' k) (mv k)) as [eqN | neqN];
  try solve [ apply Conf; auto ];
  rewrite eqM; rewrite eqN; auto.
Qed.

Hint Resolve confStepPreservesVariant : StackSafety.

Ltac frob x :=
  rewrite (idTrace_eq x); simpl.

Ltac frobin x H :=
  rewrite (idTrace_eq x) in H; simpl.

Ltac extract_mpstep :=
  match goal with
  | [H : mpstep ?MP = Some (?M, ?P, ?O) |- _ ] =>
    match goal with
    | [ H'  : step (ms MP) = _ , H'' : pstep MP = _
        |- _ ] => fail 1
    | _ => 
      unfold mpstep in H;
      let m' := fresh "m" in
      let o' := fresh "o" in
      let MStep := fresh "MStep" in
      let PStep := fresh "PStep" in
      destruct (step (ms MP)) as [m' o'] eqn:MStep;
      destruct (pstep MP) eqn:PStep;
      inversion H; subst; clear H;
      assert (H: mpstep MP = Some (M, P, O))
        by (unfold mpstep; rewrite MStep; rewrite PStep; auto)
    end
  end.

Ltac rewriteHyp :=
  match goal with
    | [ H : _ |- _ ] => rewrite H by solve [ auto ]
  end.

Hint Constructors Last : StackSafety.

Ltac last_reasoning :=
  match goal with
  | [ H : Last (finished _) _ |- _ ] => inversion H; subst; clear H
  | [ H : Last (notfinished _ _ ) _ |- _ ] => inversion H; subst; clear H
  end.

Lemma NotLastProgress {A} : forall (M : TraceOf A) m m',
    ~ Last (notfinished m M) m' -> ~ Last M m'.
Proof.
  intros. intro.
  eapply H.
  constructor; auto.
Qed.

Hint Resolve NotLastProgress : StackSafety.

(* Ltac inv H := (pinversion H || inversion H); subst; clear H.*)
Ltac inv H := inversion H; subst; clear H.

Ltac frobber F :=
  match goal with
  | [ |- context[(F ?T)] ] =>
    match goal with
    | [ |- context[notfinished _ (F T)] ] => fail 1
    | _ => frob (F T); simpl
    end
  end.

(** Run [f] on every element of [ls], not just the first that doesn't fail. *)
Ltac all f ls :=
  match ls with
    | (?LS, ?X) => f X; all f LS
    | (_, _) => fail 1
    | _ => f ls
  end.

(* Invert a particular symbol. *)
Ltac invert F :=
  match goal with 
  | [ H : F _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ _ _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ _ _ _ |- _ ] => inv H; simpl in *
  end.

Ltac induct F :=
  match goal with 
  | [ H : F _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ _ _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ _ _ _ |- _ ] => induction H; subst; clear H; simpl in *
  end.

Ltac destruct_observations :=
  match goal with
  | |- context[notfinished Tau _] => idtac
  | |- context[notfinished (Out _) _] => idtac
  | |- context[notfinished ?O _] => destruct O
  end.

Ltac simplifications :=
  match goal with
  | [ |- _ /\ _ ] => split
  | [H : _ \/ _ |- _ ] => destruct H
  | [H : _ /\ _ |- _ ] => destruct H
  | [H : exists x, _ |- _] => destruct H
  end.

Ltac conf_progress :=
  repeat progress (try all frobber (ObsTraceOf, ObsTraceOfM);
                   try extract_mpstep;
                   try rewriteHyp;
                   try last_reasoning;
                   try destruct_observations;
                   try simplifications
                  ).

Ltac seauto :=
  try intros; (* try pfold; *)
  eauto 10 with core (* paco *) StackSafety;
  try solve [exfalso; eauto 10 with core (* paco *)  StackSafety].


Lemma MTraceNeverFinished : forall m m', finished m = MTraceOf m' -> False.
Proof.
  intros m m' H; frobin (MTraceOf m') H; simpl in *; inv H.
Qed.

Lemma MTraceNeverFinished' : forall m m', finished m ~= MTraceOf m' -> False.
Proof.
  intros m m' H; frobin (MTraceOf m') H; simpl in *; inv H.
Qed.

Hint Resolve MTraceNeverFinished  : StackSafety.
Hint Resolve MTraceNeverFinished' : StackSafety.


Lemma StrongConfImpliesObsEq_Ret :
  forall C R m MP,
    variantOf (ms (head MP)) m C ->
    StrongEagerStackConfidentiality R MP m ->
    forall mpret MV,
      Last MP mpret -> R (ms mpret) ->
      PrefixUpTo R (MTraceOf m) MV ->
      (ObsTraceOf MP) ~=_O (ObsTraceOfM MV).
Proof.
  cofix COFIX.
  intros; invert StrongEagerStackConfidentiality; conf_progress; seauto.
  - destruct H3 as [[TSuff Split] | [NotR Eq]] eqn:Pre.
    + invert (@SplitInclusive MachineState).
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.                
        rewrite H5.
        apply ObsEqNow.
        eapply COFIX with (m := m'); seauto.
        left.
        exists TSuff; seauto.
        rewrite H5 in H10; simpl in *; seauto.
    + clear Pre. frobin (MTraceOf m) Eq; simpl in *. 
      inv Eq.
      rewriteHyp.
      apply ObsEqNow.
      eapply COFIX with (m := m'); seauto.
      rewrite H5 in *.
      right; split; seauto.
      inv NotR; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
      rewrite H5 in *; simpl in *; auto.
  - destruct H3 as [[TSuff Split] | [NotR Eq]] eqn:Pre.
    + invert (@SplitInclusive MachineState).
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.        
        rewrite H5.
        apply ObsEqTau1; apply ObsEqTau2.
        eapply COFIX with (m := m'); seauto.
        left.
        exists TSuff; seauto.
        rewrite H5 in *; simpl in *; auto.
    + clear Pre. frobin (MTraceOf m) Eq; simpl in *. 
      inv Eq.
      rewriteHyp.
      apply ObsEqTau1; apply ObsEqTau2.
      eapply COFIX with (m := m'); seauto.
      rewrite H5 in *.
      right; split; seauto.
      inv NotR; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
      rewrite H5 in *; simpl in *; auto.
  - destruct H3 as [[TSuff Split] | [NotR Eq]] eqn:Pre.
    + invert (@SplitInclusive MachineState).
      * constructor. 
      * frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
    + clear Pre. frobin (MTraceOf m) Eq; simpl in *. 
      inv Eq.
      inv NotR; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.      
Qed.

Lemma StrongConfImpliesObsEq_Fault :
  forall C R MP m,
    variantOf (ms (head MP)) m C ->
    StrongEagerStackConfidentiality R MP m ->
    forall mpret MV,
      Last MP mpret -> ~ R (ms mpret) ->
      PrefixUpTo R (MTraceOf m) MV ->
      (ObsTraceOf MP) <=_O (ObsTraceOfM MV).
Proof.  
  cofix COFIX.
  intros; invert StrongEagerStackConfidentiality; conf_progress; seauto.
  - destruct H3 as [[TSuff Split] | [NotR Eq]] eqn:Pre.
    + invert (@SplitInclusive MachineState).
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.                
        rewrite H5.
        apply ObsPreNow.
        eapply COFIX with (m := m'); seauto.
        left.
        exists TSuff; seauto.
        rewrite H5 in H10; simpl in *; seauto.
    + clear Pre. frobin (MTraceOf m) Eq; simpl in *. 
      inv Eq.
      rewriteHyp.
      apply ObsPreNow.
      eapply COFIX with (m := m'); seauto.
      rewrite H5 in *.
      right; split; seauto.
      inv NotR; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
      rewrite H5 in *; simpl in *; auto.
  - destruct H3 as [[TSuff Split] | [NotR Eq]] eqn:Pre.
    + invert (@SplitInclusive MachineState).
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.        
        rewrite H5.
        apply ObsPreTau1; apply ObsPreTau2.
        eapply COFIX with (m := m'); seauto.
        left.
        exists TSuff; seauto.
        rewrite H5 in *; simpl in *; auto.
    + clear Pre. frobin (MTraceOf m) Eq; simpl in *. 
      inv Eq.
      rewriteHyp.
      apply ObsPreTau1; apply ObsPreTau2.
      eapply COFIX with (m := m'); seauto.
      rewrite H5 in *.
      right; split; seauto.
      inv NotR; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
      rewrite H5 in *; simpl in *; auto.
Qed.

Hint Transparent not : StackSafety.

Lemma StrongConfImpliesObsEq_Inf :
  forall C R MP m,
    variantOf (ms (head MP)) m C ->
    StrongEagerStackConfidentiality R MP m ->
    (forall mpret, ~ Last MP mpret) ->
    forall MV, PrefixUpTo R (MTraceOf m) MV ->
    ObsTraceEq (ObsTraceOf MP) (ObsTraceOfM MV).
Proof.
  unfold not; cofix COFIX.
  intros; invert StrongEagerStackConfidentiality; conf_progress; seauto.
  - destruct H2 as [[TSuff Split] | [NotR Eq]] eqn:Pre.
    + invert (@SplitInclusive MachineState).
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.                
        rewrite H4.
        apply ObsEqNow.
        eapply COFIX with (m := m'); seauto.
        left.
        exists TSuff; seauto.
        rewrite H4 in H10; simpl in *; seauto.
    + clear Pre. frobin (MTraceOf m) Eq; simpl in *. 
      inv Eq.
      rewriteHyp.
      apply ObsEqNow.
      eapply COFIX with (m := m'); seauto.
      rewrite H4 in *.
      right; split; seauto.
      inv NotR; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
      rewrite H4 in *; simpl in *; auto.
  - destruct H2 as [[TSuff Split] | [NotR Eq]] eqn:Pre.
    + invert (@SplitInclusive MachineState).
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.
      * frobin (MTraceOf m) H0; simpl in H0; inv H0; seauto.        
        rewrite H4.
        apply ObsEqTau1; apply ObsEqTau2.
        eapply COFIX with (m := m'); seauto.
        left.
        exists TSuff; seauto.
        rewrite H4 in *; simpl in *; auto.
    + clear Pre. frobin (MTraceOf m) Eq; simpl in *. 
      inv Eq.
      rewriteHyp.
      apply ObsEqTau1; apply ObsEqTau2.
      eapply COFIX with (m := m'); seauto.
      rewrite H4 in *.
      right; split; seauto.
      inv NotR; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
      rewrite H4 in *; simpl in *; auto.
  (* RB: TODO: Fix tactics to apply Paco lemmas and solve last case. Naive hints
     on constructors of Paco generators do not work as well: after [pfold]ing, a
     constructor can be applied, but before another can be applied the resulting
     [upaco] must pick its left disjunct, that is, the corecursive [paco] (not
     not the parametric relation on the right) and [pfold] it again. *)
  (* constructor. left. pfold. constructor. seauto. *)
Qed.

Lemma ComponentConfTrans :
  forall (M0 M1 M2 N0 N1 N2 : MachineState),
    (forall k : Component, M1 k <> M0 k \/ N1 k <> N0 k -> M1 k = N1 k) ->
    (forall k : Component, M1 k <> M2 k \/ N1 k <> N2 k -> M2 k = N2 k) ->
    (forall k : Component, M0 k <> M2 k \/ N0 k <> N2 k -> M2 k = N2 k).
Proof.
  intros M0 M1 M2 N0 N1 N2 H01 H12.
  intros k [HM02 | HN02].
  - destruct (WordEqDec (M2 k) (M1 k)) as [eqM | neqM].
    + assert (M1 k <> M0 k) as HM01.
      { intros Contra.
        apply HM02.
        rewrite Contra in eqM.
        auto.
      }
      specialize (H01 k (or_introl HM01)).
      destruct (WordEqDec (N2 k) (N1 k)) as [eqN | neqN].
      * rewrite eqM; rewrite eqN; auto.
      * apply H12; eauto.
    + eapply H12; eauto.
  - destruct (WordEqDec (N2 k) (N1 k)) as [eqN | neqN].
    + assert (N1 k <> N0 k) as HN01.
      { intros Contra.
        apply HN02.
        rewrite Contra in eqN.
        auto.
      }
      specialize (H01 k (or_intror HN01)).
      destruct (WordEqDec (M2 k) (M1 k)) as [eqM | neqM].
      * rewrite eqM; rewrite eqN; auto.
      * apply H12; eauto.
    + eapply H12; eauto.
Qed.

(*
Lemma StrongConfImpliesCotermination :
  forall C R MP MV,
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV ->
    (exists mpret, IsEnd MP mpret) <-> (exists mvret, IsEnd MV mvret).
Proof.
  intros C R MP MV Var Conf; split.
  - intros [mpret HEnd].
    generalize dependent MV.
    induction HEnd; subst; eauto; intros MV Var Conf;
    inversion Conf; subst; eauto; clear Conf; simpl in *.
    + exists m.
      constructor.
    + exists m. constructor.
    + destruct (IHHEnd M'); eauto using confStepPreservesVariant.
      exists x; constructor; eauto.
  - intros [mvret HEnd].
    generalize dependent MP.
    induction HEnd; subst; eauto; intros MP Var Conf;
    inversion Conf; subst; eauto; clear Conf; simpl in *.
    + exists mp.
      constructor.
    + exists mp; constructor.
    + destruct (IHHEnd MP0); eauto using confStepPreservesVariant.
      exists x; constructor; eauto.
Qed.
 *)
Lemma StrongConfImpliesIndist_Ret :
  forall C R MP m,
    variantOf (ms (head MP)) m C ->
    StrongEagerStackConfidentiality R MP m ->
    (forall mpret MV,
        Last MP mpret -> R (ms mpret) ->
        PrefixUpTo R (MTraceOf m) MV ->
        (exists mret, Last MV mret /\
                      forall k, 
                        (ms (head MP) k <> ms mpret k \/ (head MV) k <> mret k) ->
                        ms mpret k = mret k)).
Proof.
  intros C R MP m Var Conf mpret MV HLast HR Pre.
  generalize dependent m.
  generalize dependent MV.
  induction HLast; subst; eauto; intros MV m Var Conf Pre;
  inversion Conf; subst; eauto; clear Conf; simpl in *; seauto.
  - exists m; split; seauto.
    + destruct Pre as [[TSuff HPre] | [NotR Eq]].
      * inv HPre; seauto.
        -- frobin (MTraceOf m) H; simpl in *; inv H; seauto.
        -- frobin (MTraceOf m) H; simpl in *; inv H; seauto.
      * inv NotR; seauto.
        frobin (MTraceOf m) H; simpl in *; inv H; seauto.
    + destruct Pre as [[TSuff HPre] | [NotR Eq]].
      * inv HPre; seauto.
        -- frobin (MTraceOf m) H2; simpl in *; inv H2; seauto.
           inv H; seauto.
        -- frobin (MTraceOf m) H2; simpl in *; inv H2; seauto.
      * frobin (MTraceOf m) Eq; simpl in *; inv Eq; simpl in *; destruct H; seauto.
  - simpl in *.
    destruct MV as [| mv MV].
    { destruct Pre as [[TSuff HPre] | [NotR Eq]].
      + inv HPre; seauto.
        frobin (MTraceOf m) H; simpl in *; inv H; seauto.        
      + inv Eq; seauto.
    } 
    destruct (IHHLast HR MV m') as [mret [HLastMret HConf]]; seauto.
    + destruct Pre as [[TSuff HPre] | [NotR Eq]].
      * inv HPre; seauto.
        left; simpl; exists TSuff.        
        frobin (MTraceOf m) H; simpl in *; inv H; seauto. 
        rewrite H2 in H10; auto.
      * right; split; seauto.
        -- inv NotR; seauto.
           inv H.
           frobin (MTraceOf m) H9; simpl in *; inv H9; seauto.
           rewrite H2 in H6; simpl in *; auto.
        -- frobin (MTraceOf m) Eq; simpl in *; rewrite H2 in Eq; inv Eq; seauto.
    + exists mret; split; simpl in *; [seauto |].
      destruct Pre as [[TSuff HPre] | [NotR Eq]].
      * inv HPre; seauto.
        eapply SplitInclusiveHead in H10; simpl in *; subst.
        frobin (MTraceOf m) H; simpl in *; inv H; subst.
        rewrite H2 in H10; simpl in *.
        rewrite H10 in *.
        eapply ComponentConfTrans; eauto.
      * frobin (MTraceOf m) Eq; simpl in *.
        inv Eq.
        rewrite H2 in H0; simpl in *.
        frobin (MTraceOf m') H0; simpl in *; inv H0.
        eapply ComponentConfTrans; eauto.        
Qed.

Lemma StrongConfImpliesInf_Inf : 
  forall C R MP m,
    variantOf (ms (head MP)) m C ->
    StrongEagerStackConfidentiality R MP m ->
    (forall mpret, ~ Last MP mpret) ->
    (forall mv MV, PrefixUpTo R (MTraceOf m) MV -> ~ Last MV mv).
Proof.
  unfold not.
  intros; generalize dependent MP.
  generalize dependent m.
  induct (@Last MachineState); intros;
  invert StrongEagerStackConfidentiality;
  conf_progress; seauto.
  - destruct H2 as [[TSuff HPre] | [NotR Eq]].
    + inv HPre.
      * frobin (MTraceOf m) H0; simpl in *; inv H0.
      * frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.        
    + inv Eq; seauto.
  - destruct H2 as [[TSuff HPre] | [NotR Eq]].
    + inv HPre.
      * frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
        eapply (IHLast m'); seauto.
        left. exists TSuff. 
        rewrite H4 in H12; simpl in *; auto.
    + inv Eq; seauto.
      frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.        
      eapply (IHLast m'); seauto.
      right; split; seauto.
      -- inv NotR; seauto.
         frobin (MTraceOf m) H0; simpl in *; inv H0; seauto.
         rewrite H4 in H10; simpl in *; auto.
      -- rewrite H4 in H9; auto.
Qed.         

Theorem StrongConfImpliesConf (C: Contour) (R: MachineState -> Prop) (MP : MPTrace) :
  (forall m,
    variantOf (ms (head MP)) m C ->
    StrongEagerStackConfidentiality R MP m) ->
  EagerStackConfidentialityOld C MP R.
Proof.
  intros Conf.
  unfold EagerStackConfidentiality.
  intros mv MV HVar HPre.
  specialize (Conf mv HVar).
  assert (head MV = mv) as HN
      by (erewrite <- PrefixUpToHead; eauto; auto).
  split; [|split].
  - intros mpret HLast HR; split.
    + eapply StrongConfImpliesIndist_Ret; eauto.
    + eapply StrongConfImpliesObsEq_Ret; eauto.
  - intros mpret HLast HNotR.
    eapply StrongConfImpliesObsEq_Fault; eauto.
  - intros HNotLast mvret'. split.
    * eapply StrongConfImpliesInf_Inf; eauto.
    * eapply StrongConfImpliesObsEq_Inf; eauto.
Qed.        


(*Definition updateContour (C: Contour) (args: nat) (m: MachineState) : Contour :=
  fun k =>
    match k with
    | Mem a =>
      let a' := wminus (m (Reg SP)) args in
      if wle a a' then
        (HC, HI)
      else if andb (wlt a' a) (wle a (m (Reg SP))) then
        (LC, LI)
      else if wlt (m (Reg SP)) a then
        (HC, LI)
      else C k (* impossible *)
    | _ => C k
    end.*)

(* LEO: TODO: Instruction memory should be tagged LC HI *)
(* SNA: Since we never actually use the old contour in updateContour,
   I made this for FindCall, below. (Importantly, if we did use the old contour,
   newer versions of subtrace would be wrong.) *)
Definition makeContour (cdm : CodeMap) (*(f : FunID)*) (args : nat) (m : MachineState) : Contour :=
  fun k =>
    match k with
    | Mem a =>
      if isCode cdm a then
        (*if inFun cdm a f then*)
          (LC,HI)
        (*else
          (HC,HI)*)
      else
      let a' := wminus (m (Reg SP)) args in
      if wle a a' then
        (HC, HI)
      else if andb (wlt a' a) (wle a (m (Reg SP))) then
        (LC, LI)
      else (*if wlt (M (Reg SP)) a then*)
        (HC, LI)
    | _ => (LC, LI)
    end.

(*
CoInductive Subtrace (cm: CallMap) : Contour -> MTrace -> Contour -> MTrace -> Prop :=
  | SubNow : forall C C' MM MM' args,
      (* Current instruction is a call *)
      isCall cm (head MM) args ->
      (* Take the prefix until a return *)
      LongestPrefix (fun M => ~ (isRet (head MM) M)) MM MM' ->
      (* Construct the new contour *)
      updateContour C args (head MM) = C' ->
      Subtrace cm C MM C' MM'
  | SubNotNow: forall C MM C' MM' M,
      (forall args, ~ isCall cm (head MM) args) ->
      Subtrace cm C MM C' MM' ->
      Subtrace cm C (notfinished M MM) C' MM'
  | SubSkipCall : forall C MM C' MMskip args MM' MM'',
      isCall cm (head MM) args ->
      TraceSpan (fun M => ~ (isRet (head MM) M)) MM MMskip (Some MM')  ->
      Subtrace cm C MM' C' MM'' ->
      Subtrace cm C MM C' MM''.
 *)
(* Make this "Make Contour" *)
(*
CoInductive Subtrace (cm: CallMap) : Contour -> MTrace -> Contour -> MTrace -> Prop :=
  | SubNow : forall C C' MM MM' args,
      (* Current instruction is a call *)
      isCall cm (head MM) args ->
      (* Take the prefix until a return *)
      LongestPrefix (fun M => ~ (isRet (head MM) M)) MM MM' ->
      (* Construct the new contour *)
      updateContour C args (head MM) = C' ->
      Subtrace cm C MM C' MM'
  | SubNotNow: forall C MM C' MM' M,
      Subtrace cm C MM C' MM' ->
      Subtrace cm C (notfinished M MM) C' MM'.
*)

(* Definition FindCall (cm : CallMap) (M : MTrace) (C : Contour) (M' : MTrace) := *)
(*   paco3 (FindCall_gen cm) bot3 M C M'. *)
(* Hint Unfold FindCall : core. *)
(* Lemma FindCall_mon cm : monotone3 (FindCall_gen cm). Proof. pmonauto. Qed. *)
(* Hint Resolve FindCall_mon : paco. *)

Inductive FindCallMP (cm : CallMap) (cdm : CodeMap) : MPTrace -> Contour -> MPTrace -> Prop :=
| NextCall : forall C MP MPpre MPsuff args,
    SplitInclusive (fun mp => exists args, isCall cm (ms mp) args) MP MPpre MPsuff ->
    isCall cm (ms (head MPsuff)) args ->
    makeContour cdm args (ms (head MPsuff)) = C ->
    FindCallMP cm cdm MP C MPsuff
| LaterCall : forall C C' mp MP MP' MPsuff MPcall,
    FindCallMP cm cdm MP C MPsuff ->
    MPsuff = notfinished mp MP' ->
    FindCallMP cm cdm MP' C' MPcall ->
    FindCallMP cm cdm MP C' MPcall.

(* TODO: Prove these two equivalent? *)
(* TODO: Write find call MP coinductively, prove equiv? *)

(*
CoInductive StackSafety (cm : CallMap) : MTrace -> Contour -> Prop :=
  ss : forall (MM : MTrace) (C : Contour),
       (StackIntegrity C MM) ->
       (StackConfidentiality C MM) ->
       (forall MM' C', Subtrace cm C MM C' MM' -> StackSafety cm MM' C') ->
       StackSafety cm MM C.
 *)

Definition EagerStackSafetyOld (cm : CallMap) (cdm : CodeMap) : MPTrace -> Contour -> Prop :=
  fun (MP : MPTrace) (C : Contour) =>
    (EagerStackIntegrityThru C MP) /\
    (EagerStackConfidentialityOld C MP (fun _ => False)) /\
    (forall (MPpre' MP' : MPTrace) C',
        FindCallMP cm cdm MP C' MP' -> (* Find call*)
        PrefixUpTo (fun mp => justRet (ms (head MP')) (ms mp)) MP' MPpre' ->
        EagerStackIntegrityThru C' MPpre' /\
        EagerStackConfidentialityOld C' MPpre' (justRet (ms (head MPpre')))).

Definition EagerStackSafety cm rm em cdm : Prop :=
  forall m p,
    let pm := (cm,rm,em,cdm) in
    let initC := makeContour cdm 0 m in
    initPolicyState m pm = Some p ->
    (EagerStackConfidentiality initC (m,p) (fun _ => False)) /\
    (forall (mp : MPState) C,
        FindCallMP cm cdm (MPTraceOf (m,p)) C (MPTraceOf mp) -> (* Find call*)
        EagerStackIntegrityEnd C mp (justRet (ms mp)) /\
        EagerStackConfidentiality C mp (justRet (ms mp))).

Definition EagerStackSafetyOldWrap (pm : ProgramMap) (m : MachineState) :=
  forall p,
    let '(cm,rm,em,cdm) := pm in
    let initC := makeContour cdm 0 m in
    let MP := MPTraceOf (m,p) in
    initPolicyState m pm = Some p ->
    EagerStackSafetyOld cm cdm MP initC.

(* TODO: step by step property that implies the rest *)

(* TODO: Rename this to SafeTrace or something, then write StackSafe
   as a top-level property that either quantifies over all traces (for
   a dynamic analysis) or only over a subset (e.g., those produced by
   a stack-protecting compiler). *)

(***** TESTING Property **********)
(* Note: This enforces lockstep due to PC equality.
   TODO: How not to enforce lockstep? *)

Definition EagerIntegrityTest (C : Contour) (M M' : MachineState) : Prop :=
  forall (k : Component), integrityOf (C k) = HI -> M k = M' k.

Hint Unfold EagerIntegrityTest : StackSafety.

Definition EagerConfidentialityTest (isRet : MachineState -> Prop)
           (M M' N N' : MachineState) (OM ON : Observation) : Prop :=
  OM = ON /\
  forall (k : Component),  M k <> M' k \/ N k <> N' k -> M' k = N' k.

Hint Unfold EagerConfidentialityTest : StackSafety.

(* Elements of the Variant Stack. *)
Record VSE := {
  init_machine : MachineState;
  init_variant : MachineState;
  curr_variant : MachineState;
  contour : Contour;
  retP : MachineState -> Prop
}.

Definition upd_curr (mv : MachineState) (vse : VSE) : VSE :=
  {| init_machine := init_machine vse;
     init_variant := init_variant vse;
     curr_variant := mv;
     contour := contour vse;
     retP := retP vse
  |}.

Definition VSE_step (vse : VSE) :=
  match step (curr_variant vse) with
  | (mv',_) => upd_curr mv' vse
  end.

Definition VarStack := list VSE.

Definition VSEs_step (vs : VarStack) := map VSE_step vs.

Inductive FinLast {A : Type} : A -> list A -> Prop :=
| FLastSing : forall x, FinLast x [x]
| FLastTail : forall x h t, FinLast x t -> FinLast x (h::t).

Hint Constructors FinLast : StackSafety.

Lemma FinLast_unique {A : Type} (x x' : A) (l : list A) :
  FinLast x l -> FinLast x' l -> x = x'.
Proof.
  intro H; induction H; intro HLast; inversion HLast; subst; clear HLast; eauto;
    match goal with
    | [ H : FinLast _ [] |- _ ] => inversion H
    end.
Qed.

Hint Resolve FinLast_unique : StackSafety.

Lemma FinLast_singleton {A : Type} (x x' : A) :
  FinLast x [x'] -> x = x'.
Proof.
  intros H. inversion H; easy.
Qed.

Hint Resolve FinLast_singleton : StackSafety.

Inductive FinLastN {A} : nat -> list A -> list A -> Prop :=
| FinLastNow : forall n l, length l = n -> FinLastN n l l
| FinLastLater : forall n x xs l, FinLastN n xs l -> FinLastN n (x::xs) l.

Lemma FinLastN_length {A} : forall n (L l : list A), FinLastN n L l -> length l = n.
Proof.
  intros n L l H; induction H; eauto.
Qed.

Lemma FinLastN_length2 {A} : forall n (L l : list A), FinLastN n L l -> length L >= n.
Proof.
  intros n L l H; induction H; eauto.
  - rewrite H; apply le_n.
  - simpl.
    apply le_S.
    eauto.
Qed.


Lemma FinLastN_unique {A : Type} n (l l' L : list A) :
  FinLastN n L l -> FinLastN n L l' -> l = l'.
Proof.
  intros H.
  generalize dependent l'.
  induction H; intros l' H';
  inversion H'; subst; clear H'; simpl in *; eauto.
  - apply FinLastN_length2 in H0; omega.
  - apply FinLastN_length2 in H; omega.
Qed.

Lemma VSEs_step_preserves_length: forall vs vs', VSEs_step vs = vs' ->
                                  forall n, length vs = n -> length vs' = n.
Proof.
  intros.
  unfold VSEs_step in *.
  rewrite <- H.
  rewrite <- H0.
  apply map_length; eauto.
Qed.
  
Lemma VSE_step_preserves_LastN :
  forall n VS vs, FinLastN n VS vs ->
  forall VS' vs', 
    VSEs_step vs = vs' ->
    VSEs_step VS = VS' ->
    FinLastN n VS' vs'.
Proof.
  intros n Vs vs H; induction H; intros VS' vs' SV Sv.
  - rewrite SV in Sv; subst; eapply FinLastNow; eapply VSEs_step_preserves_length; eauto.
  - inversion Sv; subst; simpl in *.
    eapply FinLastLater.
    eapply IHFinLastN; eauto.
Qed.    
    
Lemma VSE_step_preserves_in :
  forall vse vs vs' mv' O,
    In vse vs ->
    VSEs_step vs = vs' ->
    step (curr_variant vse) = (mv',O) ->
    In (upd_curr mv' vse) vs'.
Proof.
  intros vse vs vs' mv' O HIn HForall HStep.
  rewrite <- HForall.
  apply in_map_iff.
  exists vse.
  split; auto.
  unfold VSE_step. rewrite HStep.
  auto.
Qed.

Hint Resolve VSE_step_preserves_in : StackSafety.

Lemma map_preserves_last :
  forall {A B} (f : A -> B)  x l, FinLast x l -> FinLast (f x) (map f l).
Proof.
  intros A B f x l H; induction H; simpl in *; seauto.
Qed.

Lemma VSE_step_preserves_last :
  forall vse vse' vs vs',
    FinLast vse vs ->
    VSEs_step vs = vs' ->
    VSE_step vse = vse' ->
  FinLast vse' vs'.
Proof.
  intros vse vse' vs vs' HLast HVS HVSE.
  rewrite <- HVS.
  unfold VSEs_step.
  rewrite <- HVSE.
  apply map_preserves_last; auto.
Qed.

Hint Resolve VSE_step_preserves_last : StackSafety.

Corollary VSE_step_preserves_last' :
  forall vse vses vses' N' O,
    FinLast vse vses ->
    VSEs_step vses = vses' ->
  step (curr_variant vse) = (N',O) ->
  FinLast (upd_curr N' vse) vses'.
Proof.
  intros; eapply VSE_step_preserves_last; eauto.
  unfold VSE_step. rewriteHyp. auto.
Qed.  

Hint Resolve VSE_step_preserves_last' : StackSafety.

Lemma FinLast_implies_In {A : Type} (x : A) (l : list A) :
  FinLast x l -> In x l.
Proof.
  intros Last; induction Last.
  - left; auto.
  - right; auto.
Qed.

Hint Resolve FinLast_implies_In : StackSafety.

Lemma FinLastNHead_implies_In {A} (x : A) n L l :
  FinLastN n L l -> hd_error l = Some x -> In x L.
Proof.
  intros H; induction H; intros; eauto.
  - destruct l; eauto.
    + inversion H0; eauto.
    + inversion H0; subst; left; eauto.
  - right; eauto.
Qed.

Definition publicRegisters C :=
  forall r, C (Reg r) = (LC, LI).

(* Well-formedness conditions on the stack with respect to a current MS. *)
Definition WellFormedVS (M : MachineState) (vs : VarStack) : Prop :=
  (* The curr_variant field is a variant of the current state. *)
  Forall (fun vse => variantOf M (curr_variant vse) (contour vse)) vs /\
  (* The stack is nonempty and the last retP is const False *)
  (exists vse, FinLast vse vs /\ retP vse = fun _ => False) /\
  (* The current state is in the trace of *every* init machine. *)
  (Forall (fun vse => InTrace M (MTraceOf (init_machine vse))) vs) /\
  (* The variant state is in the trace of its own init variant. *)
  (Forall (fun vse => InTrace (curr_variant vse) (MTraceOf (init_variant vse))) vs) /\
  (* The ret function is an isRet if not the last element. *)
  (Forall (fun vse =>
             (exists m', forall m, retP vse m = justRet m' m) \/
             (forall m, retP vse m = False)
          ) vs) /\
  (* All contours have public registers. *)
  (Forall (fun vse => publicRegisters (contour vse)) vs).

Hint Unfold WellFormedVS : StackSafety.

(* Indexed Stack Safety Test to signify when a return should finish a trace. *)
CoInductive EagerStackSafetyTest(*_gen*) (cm : CallMap) (cdm : CodeMap) (*R*)
  : nat -> MPTrace -> VarStack -> Prop :=
| EagerTestFinFault :
    forall depth mp vs,
      WellFormedVS (ms mp) vs ->
      mpstep mp = None ->
      length vs >= depth -> 
      EagerStackSafetyTest(*_gen*) cm cdm (*R*) depth (finished mp) vs
| EagerTestFinRet :
    forall depth mp vse vs,
      WellFormedVS (ms mp) (vse :: vs) ->
      length (vse :: vs) = depth ->
      (* The top one returns. *)
      retP vse (ms mp) ->
      (* No other returns. *)
      (forall vse', In vse' vs -> ~ retP vse' (ms mp)) ->
      EagerStackSafetyTest(*_gen*) cm cdm (*R*) depth (finished mp) (vse :: vs)
| EagerTestStep :
    forall depth mp MP vs vs' m' p' OM,
      (* Not a call or a return *)
      (forall args, ~ isCall cm (ms mp) args) ->
      (forall vse, In vse vs -> ~ (retP vse (ms mp))) ->
      (* Take a step. *)
      mpstep mp = Some (m', p', OM) ->
      WellFormedVS (ms mp) vs ->
      (* Enforce confidentiality for each variant. *)
      (forall vse,
          In vse vs ->
          exists mv' OV, step (curr_variant vse) = (mv', OV) /\
          EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' OM OV) ->
      (* Enforce integrity for main trace, but for each possible level in NCRs? *)
      (forall vse,
          In vse vs ->
          EagerIntegrityTest (contour vse) (ms mp) m') ->
      (* Step all variants and just recurse *)
      VSEs_step vs = vs' ->
      head MP = (m',p') ->
      (*R*)EagerStackSafetyTest cm cdm depth MP vs' ->
      length vs >= depth ->
      (* Conclude for current. *)
      EagerStackSafetyTest(*_gen*) cm cdm (*R*) depth (notfinished mp MP) vs
| EagerTestCall :
    forall depth args mp MP vs vs' m' p' OM C vsecall,      
      (* Is a call *)
      isCall cm (ms mp) args ->
      (* ...but not a return *)
      (forall vse, In vse vs -> ~ (retP vse (ms mp))) ->      
      (* Take a step. *)
      mpstep mp = Some (m', p', OM) ->
      WellFormedVS (ms mp) vs ->
      (* Enforce confidentiality for each variant. *)
      (forall vse,
          In vse vs ->
          exists mv' OV, step (curr_variant vse) = (mv', OV) /\
          EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' OM OV) ->
      (* Enforce integrity for main trace, but for each possible level in NCRs? *)
      (forall vse,
          In vse vs ->
          EagerIntegrityTest (contour vse) (ms mp) m') ->
      (* Step all variants. *)
      VSEs_step vs = vs' ->
      head MP = (m', p') ->
      (* Calculate the new contour based on the top of the current machine. *)
      (* LEO: TODO: Current machine, or HEAD MP? *)
      makeContour cdm args (ms mp) = C ->
      (* Confidentiality Test for all variants _at the call_: *)
      (forall mvar mvar' OV,
          variantOf (ms mp) mvar C ->
          step mvar = (mvar', OV) ->          
          EagerConfidentialityTest (justRet (ms mp)) (ms mp) m' mvar mvar' OM OV) ->
      (* Integrity Test for new contour _at the call_ : *)
      EagerIntegrityTest C (ms mp) m' ->
      (* Build a variant stack element *)
      vsecall = (fun mvar => {| init_machine := ms mp
                             ; init_variant := mvar
                             ; curr_variant := mvar
                             ; contour := C
                             ; retP := justRet (ms mp)
                             |}) ->
      (* Recurse with every variant at the new contour at the top. *)
      (forall mvar, variantOf (ms (head MP)) mvar C ->
                    (*R*)EagerStackSafetyTest cm cdm depth MP (vsecall mvar :: vs')) ->
      length vs >= depth ->
      (* Conclude for current. *)
      EagerStackSafetyTest(*_gen*) cm cdm (*R*) depth (notfinished mp MP) vs
| EagerTestRet :
    forall depth mp MP vs vs' m' p' OM,          
      (* Top return, no other return. *)
      (exists vse vsrest, vs = vse :: vsrest  /\ retP vse (ms mp) /\ depth <= length vsrest /\ forall vse', In vse' vsrest -> ~ retP vse' (ms mp)) ->
      (* ...but not a call! *)
      (forall args, ~ isCall cm (ms mp) args) ->      
      (* Take a step. *)
      mpstep mp = Some (m', p', OM) ->
      WellFormedVS (ms mp) vs ->
      length vs >= depth ->
      (* Enforce confidentiality for each variant. *)
      (forall vse,
          In vse vs ->
          exists mv' OV, step (curr_variant vse) = (mv', OV) /\
          EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' OM OV) ->
      (* Enforce integrity for main trace, but for each possible level in NCRs? *)
      (forall vse,
          In vse vs ->
          EagerIntegrityTest (contour vse) (ms mp) m') ->
      (* Step all variants. *)
      VSEs_step vs = vs' ->
      head MP = (m',p') ->
      (* Recurse but take of the top of the stack. *)
      (*R*)EagerStackSafetyTest cm cdm depth MP (tl vs') ->
      (* Conclude for current. *)
      EagerStackSafetyTest(*_gen*) cm cdm (*R*) depth (notfinished mp MP) vs
| EagerTestRetCall :
    forall depth args mp MP vs vs' m' p' OM C vsecall,      
      (* Is a call *)
      isCall cm (ms mp) args ->
      (* ...and a return *)
      (exists vse vsrest, vs = vse :: vsrest  /\ retP vse (ms mp) /\ depth <= length vsrest /\ forall vse', In vse' vsrest -> ~ retP vse' (ms mp)) ->
      (* Take a step. *)
      mpstep mp = Some (m', p', OM) ->
      WellFormedVS (ms mp) vs ->
      (* Enforce confidentiality for each variant. *)
      (forall vse,
          In vse vs ->
          exists mv' OV, step (curr_variant vse) = (mv', OV) /\
          EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' OM OV) ->
      (* Enforce integrity for main trace, but for each possible level in NCRs? *)
      (forall vse,
          In vse vs ->
          EagerIntegrityTest (contour vse) (ms mp) m') ->
      (* Step all variants. *)
      VSEs_step vs = vs' ->
      head MP = (m', p') ->
      (* Calculate the new contour based on the top of the current machine. *)
      (* LEO: TODO: Current machine, or HEAD MP? *)
      makeContour cdm args (ms mp) = C ->
      (* Confidentiality Test for all variants _at the call_: *)
      (forall mvar mvar' OV,
          variantOf (ms mp) mvar C ->
          step mvar = (mvar', OV) ->          
          EagerConfidentialityTest (justRet (ms mp)) (ms mp) m' mvar mvar' OM OV) ->
      (* Integrity Test for new contour _at the call_ : *)
      EagerIntegrityTest C (ms mp) m' ->
      (* Build a variant stack element *)
      vsecall = (fun mvar => {| init_machine := ms mp
                             ; init_variant := mvar
                             ; curr_variant := mvar
                             ; contour := C
                             ; retP := justRet (ms mp)
                             |}) ->
      (* Recurse with every variant at the new contour at the top of the tail of the stack. *)
      (forall mvar, variantOf (ms (head MP)) mvar C ->
                    (*R*)EagerStackSafetyTest cm cdm depth MP (vsecall mvar :: (tl vs'))) ->
      (* Conclude for current. *)
      EagerStackSafetyTest(*_gen*) cm cdm (*R*) depth (notfinished mp MP) vs.

Hint Constructors EagerStackSafetyTest(*_gen*) : core.

(* Definition EagerStackSafetyTest *)
(*            (cm : CallMap) (depth : nat) (MP : MPTrace) (vs : VarStack) := *)
(*   paco3 (EagerStackSafetyTest_gen cm) bot3 depth MP vs. *)
(* Hint Unfold EagerStackSafetyTest : core. *)
(* Lemma EagerStackSafetyTest_mon cm : monotone3 (EagerStackSafetyTest_gen cm). Proof. pmonauto. Qed. *)
(* Hint Resolve EagerStackSafetyTest_mon : paco. *)

Definition EagerStackSafetyTest' cm cdm MP :=
  forall mv,
    variantOf (ms (head MP)) mv (makeContour cdm 0 (ms (head MP))) ->
    EagerStackSafetyTest cm cdm 1 MP [Build_VSE (ms (head MP)) mv mv (makeContour cdm 0 (ms (head MP))) (fun _ => False)].

Hint Unfold EagerStackSafetyTest' : StackSafety.

Ltac in_reasoning :=
  repeat match goal with
         | [ H : In _ [] |- _ ] => inversion H
         | [ H : In _ [_] |- _ ] => inversion H; subst; clear H
         | [ H : (_,_,_,_) = (_,_,_,_) |- _ ] => inversion H; subst; clear H
         end.

Ltac progress_integrity :=
  repeat match goal with
         | [ H : WellFormedVS ?M ?VS |- _ ] =>
           destruct H as [HVar [[vse_last' [HLast' HRet]] [HMTrace HNTrace]]]
         | [ H1 : Last ?X ?L, H2 : Last ?Y ?L |- _ ] =>
           assert (Y = X) by (eapply FinLast_unique; eauto); subst; clear H2
         end.

Ltac int_progress' :=
  (try all frobber (ObsTraceOf, ObsTraceOfM);
   try extract_mpstep;   
   try rewriteHyp;
   try last_reasoning;
   try simplifications
  ).

Ltac int_progress := repeat progress int_progress'.

CoInductive MStepCompatible(*_gen R*) : MTrace -> Prop :=
| MCompStep :
    forall m M o,
      step m = (head M, o) ->
      (*R*) MStepCompatible M ->
      MStepCompatible(*_gen R*) (notfinished m M).
Hint Constructors MStepCompatible(*_gen*) : core.

(* Definition MStepCompatible (M : MTrace) := *)
(*   paco1 MStepCompatible_gen bot1 M. *)
(* Hint Unfold EagerStackSafetyTest : core. *)
(* Lemma MStepCompatible_mon : monotone1 MStepCompatible_gen. Proof. pmonauto. Qed. *)
(* Hint Resolve MStepCompatible_mon : paco. *)

Lemma MTraceOf_Compatible : forall m, MStepCompatible (MTraceOf m).
Proof.
  cofix COFIX.
  intros m; (*pfold;*) frobber MTraceOf.
  destruct (step m) as [m' o] eqn:Step.
  eapply MCompStep; eauto.
Qed.    

Lemma InMTrace_Compatible : forall m M, InTrace m M ->
                      MStepCompatible M ->
                      forall m' o', step m = (m',o') ->
                      InTrace m' M.
Proof.
  intros m M H; induction H; intros Comp m'' o'' MStep.
  - inversion Comp.
  - apply In_later.
    inversion Comp; subst; eauto.
    rewrite H1 in MStep. inv MStep. inversion H2; subst; auto.
    destruct H2; simpl; constructor.
  - apply In_later. eapply IHInTrace; eauto.
    inversion Comp; eauto.
Qed.

Corollary InMTrace_step : forall m m0, InTrace m (MTraceOf m0) ->
                      forall m' o', step m = (m',o') ->
                      InTrace m' (MTraceOf m0).
Proof.
  intros; eapply InMTrace_Compatible; eauto using MTraceOf_Compatible.
Qed.

(*
CoInductive MPStepCompatible(*_gen*) (R : MachineState -> Prop) (*Rcoind*) : MPTrace -> Prop :=
| CompError :
    forall mp, mpstep mp = None -> MPStepCompatible(*_gen*) R (*Rcoind*) (finished mp)
| CompRet :
    forall mp, R (ms mp) -> MPStepCompatible(*_gen*) R (*Rcoind*) (finished mp)
| CompStep :
    forall mp MP,
      (exists o, mpstep mp = Some (ms (head MP), ps (head MP), o)) ->
      ~ (R (ms mp)) ->
      (*Rcoind*)MPStepCompatible R MP ->
      MPStepCompatible(*_gen*) R (*Rcoind*) (notfinished mp MP).
Hint Constructors MPStepCompatible(*_gen*) : core.
*)

(* Definition MPStepCompatible (R : MachineState -> Prop) (MP : MPTrace) := *)
(*   paco1 (MPStepCompatible_gen R) bot1 MP. *)
(* Hint Unfold MPStepCompatible : core. *)
(* Lemma MPStepCompatible_mon R : monotone1 (MPStepCompatible_gen R). Proof. pmonauto. Qed. *)
(* Hint Resolve MPStepCompatible_mon : paco. *)

Lemma variantOf_id C m : variantOf m m C.
Proof.
  unfold variantOf. reflexivity.
Qed.

(* TODO: Move to Trace *)
CoInductive ForallButLast {A : Type} (P : A -> Prop) : TraceOf A -> Prop :=
| ForallBL_finished : forall a : A, ForallButLast P (finished a)
| ForallBL_notfinished : forall (a : A) (T' : TraceOf A),
                         P a -> ForallButLast P T' -> ForallButLast P (notfinished a T').

Lemma ForallTraceImpl :
  forall A (P Q : A -> Prop) T,
  ForallTrace P T ->
  (forall a, P a -> Q a) ->
  ForallTrace Q T.
Proof.
  cofix COFIX.
  intros.
  inv H; constructor; eauto.
Qed.
    
Theorem TestImpliesIntegrityNested :
  forall cm cdm C MP vs n vscall vse,
         FinLastN n vs vscall ->
         hd_error vscall = Some vse ->
         contour vse = C ->
         ForallButLast (fun mp => ~ retP vse (ms mp)) MP ->
  EagerStackSafetyTest cm cdm n MP vs -> EagerStackIntegrityInd C MP.
Proof.
  cofix COFIX.
  intros cm cdm C MP vs n vscall vse Last Hvse HC HNotR Safety(*; pfold*).
  inv Safety.
  - apply SI_finished.
  - apply SI_finished.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H6; simpl.
      eapply H4; eauto using FinLastNHead_implies_In.
    + (*right.*)
      eapply (COFIX cm cdm (contour vse) MP0 (VSEs_step vs) n (VSEs_step vscall) (VSE_step vse)); eauto.
      * eapply VSE_step_preserves_LastN; eauto.
      * destruct vscall; inversion Hvse; subst; simpl; auto.
      * unfold VSE_step; simpl; auto.
        destruct (step (curr_variant vse)); simpl; auto.
      * unfold not; intros; (*pfold;*) eauto.
        inversion HNotR; subst; auto.
        unfold VSE_step; simpl; destruct (step (curr_variant vse)); auto.
  (* simpl. *)
        (* eapply paco1_unfold with (x0 := MP0); eauto with paco. *)
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H6; simpl.
      eauto using FinLastNHead_implies_In.
    + remember (Build_VSE (ms mp) (ms (head MP0)) (ms (head MP0)) (makeContour cdm args (ms mp)) (justRet (ms mp))) as vse_call.
      (*right.*)
      apply (COFIX cm cdm (contour vse) MP0 (vse_call::(VSEs_step vs)) n (VSEs_step vscall) (VSE_step vse)); eauto.
      * eapply FinLastLater.
        eapply VSE_step_preserves_LastN; eauto.
      * destruct vscall; inversion Hvse; subst; simpl; auto.
      * unfold VSE_step; simpl; auto.
        destruct (step (curr_variant vse)); simpl; auto.
      * unfold not; intros; eauto.
        unfold VSE_step.
        destruct (step (curr_variant vse)); auto.
        inversion HNotR; subst; auto.
      * (*pfold.*) rewriteHyp.
        seauto.
(*        specialize (H11 (ms (head MP0)) (variantOf_id _ _)).
        (* destruct H8 as [H8 | H8]; [| easy]. *)
        (* (* RB: TODO: Revisit similar cases to try to simplify like so: *) *)
        (* punfold H8. *)
        assumption. *)
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewriteHyp.
      eauto using FinLastNHead_implies_In.
    + (*right.*)
      apply (COFIX cm cdm (contour vse) MP0 (tl (VSEs_step vs)) n (VSEs_step vscall) (VSE_step vse)); auto.
      * destruct vs; simpl in *.
        -- inversion Last; subst; simpl in *; try solve [constructor]; eauto.
        -- inversion Last; subst; simpl in *; eauto.
           ++ inversion Hvse; subst; simpl in *.
              destruct H as [vseC [vsrest [Eq [Hret Hd]]]].
              exfalso.
              inversion Eq; subst.
              inversion HNotR; subst; auto.
           ++ eapply VSE_step_preserves_LastN; eauto.
      * destruct vscall; inversion Hvse; subst; eauto.
      * unfold VSE_step; simpl; auto.
        destruct (step (curr_variant vse)); simpl; auto.
      * unfold not; intros; eauto.
        inversion HNotR; subst; auto.
        unfold VSE_step; destruct (step (curr_variant vse)); simpl; auto.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewriteHyp.
      eauto using FinLastNHead_implies_In.
    + (*right.*)
      remember (Build_VSE (ms mp) (ms (head MP0)) (ms (head MP0)) (makeContour cdm args (ms mp)) (justRet (ms mp))) as vse_call.
      apply (COFIX cm cdm (contour vse) MP0 (vse_call::(tl (VSEs_step vs))) n (VSEs_step vscall) (VSE_step vse)); eauto.
      * destruct vs; simpl in *.
        -- inversion Last; subst; simpl in *; try solve [constructor]; eauto.
           constructor.
           constructor.
           auto.
        -- constructor.
           inversion Last; subst; simpl in *; eauto.
           ++ inversion Hvse; subst; simpl in *.
              destruct H0 as [vseC [vsrest [Eq [Hret Hd]]]].
              exfalso.
              inversion Eq; subst.
              inversion HNotR; subst; auto.
           ++ eapply VSE_step_preserves_LastN; eauto.
      * destruct vscall; inversion Hvse; subst; eauto.
      * unfold VSE_step; simpl; auto.
        destruct (step (curr_variant vse)); simpl; auto.
      * unfold not; intros; eauto.
        inversion HNotR; subst; auto.
        unfold VSE_step; destruct (step (curr_variant vse)); simpl; auto.
      * rewrite Heqvse_call; seauto. 
Qed.

Lemma FinLastN1_FinLast : forall {A} (l : list A) x,
    FinLastN 1 l [x] -> FinLast x l.
Proof.
  intros.
  remember 1.
  remember [x].
  generalize dependent x.
  induction H; intros; subst; seauto.
Qed.

Lemma FinLast_FinLastN1 : forall {A} (l : list A) x,
    FinLast x l -> FinLastN 1 l [x].
Proof.
  intros.
  induction H.
  - constructor; simpl; auto.
  - constructor; eauto.
Qed.

(*
Lemma EagerTestTermination :
  forall cm MP vs, EagerStackSafetyTest cm MP vs ->
  forall vse, FinLast vse vs ->
  forall mp, InTrace mp MP -> 
             ~ retP vse (ms mp) \/ mpstep mp = None.
Proof.
  intros.
  induction H1; inversion H; subst; simpl in *; eauto.
  - left; eauto using FinLast_implies_In.
  - left; eauto using FinLast_implies_In.
  - 
 *)

Lemma RetP_Rewrite :
  forall vs a,
 Forall (fun vse : VSE =>
          a = vse \/ In vse vs ->
          ~ FinLast vse (a :: vs) ->
          exists m' : MachineState, forall m : MachineState, retP vse m = justRet m' m)
         vs ->
  Forall
    (fun vse0 : VSE =>
     In vse0 vs ->
     ~ FinLast vse0 vs ->
     exists m'0 : MachineState, forall m : MachineState, retP vse0 m = justRet m'0 m) vs.
Proof.
  intros.
  eapply Forall_impl; eauto.
  intros.
  simpl in *.
  destruct H0.
  - right; auto.
  - intros Contra.
    inv Contra; auto.
  - exists x; auto.
Qed.

Lemma RetP_Rewrite_Step :
  forall vs a, 
    Forall
         (fun vse : VSE =>
          a = vse \/ In vse vs ->
          ~ FinLast vse (a :: vs) ->
          exists m' : MachineState, forall m : MachineState, retP vse m = justRet m' m)
         vs ->
  Forall
    (fun vse0 : VSE =>
     In vse0 (VSE_step a :: VSEs_step vs) ->
     ~ FinLast vse0 (VSE_step a :: VSEs_step vs) ->
     exists m'0 : MachineState, forall m : MachineState, retP vse0 m = justRet m'0 m)
    (VSEs_step vs).
Proof.
  intros.
  eapply Forall_forall.  
  intros.
  apply in_map_iff in H0.
  destruct H0 as [m [Step HIn]].
  eapply Forall_forall in H.
  - destruct H.
    + right; eauto.
    + intros Contra.
      inv Contra.
      * inv HIn.
      * eapply H2.
        constructor.
        eapply VSE_step_preserves_last; eauto.
    + exists x0; eauto.
      intros.
      unfold VSE_step, upd_curr in *.
      destruct (step (curr_variant m)); simpl in *.
      subst.
      simpl.
      eauto.
  - eauto.
Qed.      

Ltac dest_wf :=
  match goal with
  | [H : WellFormedVS _ _ |- _ ] =>
    destruct H as [Varwf [[vsewf [Lastwf Retwf]] [InM [InV [HRetwf HPubwf]]]]] eqn:wf
  end.

(*
Corollary TestImpliesIntegrityToplevel :
  forall cm C MP vs,
    MPStepCompatible (fun _ => False) MP ->
    (exists vse, FinLast vse vs /\ contour vse = C) ->
    EagerStackSafetyTest cm 1 MP vs -> EagerStackIntegrity' C MP.
Proof.
  intros cm C MP vs Comp Last Safety.
  destruct Last as [vse [Last HC]].
  eapply TestImpliesIntegrityNested with (n:=1) (vscall := [vse]); eauto.
  - eapply FinLast_FinLastN1; eauto.
  - simpl; auto.
  - (*pfold.*)
    invert EagerStackSafetyTest.
    + constructor; auto.
    + apply CompRet; auto.
      destruct vs0; simpl in *.
      * inversion Last; subst; auto. inversion H5.
      * congruence.
    + dest_wf. 
      assert (vse = vsewf) by (eapply FinLast_unique; eauto).
      inversion Comp; subst; eauto.
      constructor; eauto; rewrite Retwf; auto.
    + dest_wf.
      assert (vse = vsewf) by (eapply FinLast_unique; eauto).
      subst.
      inversion Comp; subst; eauto.
      constructor; eauto; rewrite Retwf; auto.
    + dest_wf. 
      assert (vse = vsewf) by (eapply FinLast_unique; eauto).
      subst.
      inversion Comp; subst; eauto.
      constructor; eauto; rewrite Retwf; auto.
    + dest_wf. 
      assert (vse = vsewf) by (eapply FinLast_unique; eauto).
      subst.
      inversion Comp; subst; eauto.
      constructor; eauto; rewrite Retwf; auto.
Qed.
*)

Lemma retP_VSE :
  forall vse, retP vse = retP (VSE_step vse).
Proof.
  intros.
  unfold VSE_step, upd_curr.
  destruct (step (curr_variant vse)).
  simpl.
  auto.
Qed.

Lemma contour_VSE :
  forall vse, contour vse = contour (VSE_step vse).
Proof.
  intros.
  unfold VSE_step, upd_curr.
  destruct (step (curr_variant vse)).
  simpl.
  auto.
Qed.


Lemma VSE_step_preserves_WellFormed :
  forall vs mp, WellFormedVS (ms mp) vs ->
  forall m' p' o', mpstep mp = Some (m', p', o') ->
  forall vs', VSEs_step vs = vs' ->
  (forall vse : VSE,
       In vse vs ->
       exists (mv' : MachineState) (OV : Observation),
         step (curr_variant vse) = (mv', OV) /\
         EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' o' OV) ->
  WellFormedVS m' vs'.              
Proof.
  intro vs; induction vs; intros mp WF m' p' o' MPStep vs' Step Conf.
  - inversion Step; subst.
    destruct WF as [Var [[vse [Last Ret]] [InM InV]]] eqn:wf.
    inversion Last.
  - inversion Step; subst.
    destruct WF as [Var [[vse [Last Ret]] [InM [InV [HR HC]]]]] eqn:wf.
    extract_mpstep.    
    inversion Var; inversion Last; inversion InM; inversion InV; subst; simpl in *.
    + inversion H3; subst; clear H3.
(*       inversion H1; subst; clear H1.*)
      repeat split.
      * constructor; simpl in *; eauto.
(*        remember (Build_VSE m0 mv0 mv C R) as vse. *)
        specialize (Conf a (or_introl eq_refl)).
        destruct Conf as [mv'' [ov'' [MVStep [OEq Conf]]]].
        simpl in *.
        rewrite OEq in *.
(*        clear H0; clear H1; clear OEq; clear MVStep. *)
        eapply confStepPreservesVariant; eauto.
        -- unfold VSE_step.
           rewrite MVStep.
           eauto.
        -- intros k Hk.
           unfold VSE_step in *.
           rewrite MVStep in *.
           simpl.
           eapply Conf; eauto.
           destruct Hk; [ left | right ]; eauto.
        -- unfold VSE_step in *; rewrite MVStep; eauto.
      * exists (VSE_step a); split; auto using FLastSing.
        unfold VSE_step in *.
        destruct (step (curr_variant a)); simpl; auto.
      * constructor; simpl in *; eauto.
        eapply InMTrace_step; eauto.
        unfold VSE_step; destruct (step (curr_variant a)); simpl; auto.
      * constructor; simpl in *; eauto.
        unfold VSE_step; destruct (step (curr_variant a)) eqn:S; simpl; eauto.
        destruct H; eapply InMTrace_step; eauto.
      * constructor; simpl in *; intros; eauto.
        right. intros.
        rewrite <- retP_VSE; eauto.
        rewrite Ret; auto.
      * constructor; simpl in *.
        inv HC.
        -- rewrite <- contour_VSE; auto.
        -- constructor.
    + repeat split.
      * constructor; simpl in *; eauto.
        -- eapply confStepPreservesVariant; eauto.
           ++ specialize (Conf a (or_introl eq_refl)).
              unfold VSE_step in *; simpl in *.           
              destruct Conf as [mv'' [ov'' [MVStep [OEq Conf]]]].
              simpl in *.
              rewrite MVStep; eauto.
              rewrite OEq in *; eauto.
           ++ intros k Hk.
              unfold VSE_step in *; simpl in *.
              destruct (Conf a (or_introl eq_refl)) as [mv'' [ov'' [MVStep [OEq Conf']]]].
              rewrite MVStep in *; simpl in *.
              eapply Conf'.
              destruct Hk; [left | right]; eauto.
           ++ intros k Hk.
              unfold VSE_step in *; simpl in *.
              destruct (Conf a (or_introl eq_refl)) as [mv'' [ov'' [MVStep [OEq Conf']]]].
              rewrite MVStep in *; simpl in *.
              unfold variantOf in H2.
              eapply H2; eauto.
        -- eapply IHvs; eauto.
           repeat split; eauto.
           ++ inv HR.
              eauto.
           ++ inv HC; eauto.
      * destruct (step (curr_variant vse)) as (mv'', ov'') eqn:Step_vse.

        exists (upd_curr mv'' vse).
        split; subst; simpl; auto.
        apply FLastTail.
        eapply VSE_step_preserves_last; eauto.
        unfold VSE_step in *; simpl in *.
        rewrite Step_vse; auto.
      * constructor; simpl in *; eauto.
        -- eapply InMTrace_step; eauto.
           unfold VSE_step in *; simpl.
           destruct (step (curr_variant a)); simpl; auto.
        -- eapply IHvs; eauto.
           repeat split; eauto.
           ++ inv HR.
              eauto.
           ++ inv HC; eauto.
      * destruct (step (curr_variant a)) eqn:S; simpl; eauto.           
        constructor; simpl in *; eauto.
        -- unfold VSE_step in *.
           rewrite S; simpl in *.
           eapply InMTrace_step; eauto.
        -- eapply IHvs; eauto.
           repeat split; eauto.
           ++ inv HR. eauto.
           ++ inv HC; eauto.
      * inv HR.
        constructor; eauto.
        -- intros.
           destruct H4.
           ++ destruct H0.
              left; eexists; intros; eauto.
              rewrite <- retP_VSE; simpl; auto.
           ++ right; intros; eauto.
              rewrite <- retP_VSE; simpl; auto.
        -- eapply Forall_forall.
           intros.
           eapply in_map_iff in H0.
           destruct H0 as [X [S I]].
           eapply Forall_forall in H5; [ | eapply I].
           destruct H5.
           ++ destruct H0.
              left.
              subst.
              rewrite <- retP_VSE.
              eexists; eauto.
           ++ right; subst; rewrite <- retP_VSE; eauto.
      * inv HC.
        constructor; eauto.
        -- rewrite <- contour_VSE; auto.
        -- eapply Forall_forall.
           intros.
           eapply in_map_iff in H0.
           destruct H0 as [X [S I]].
           eapply Forall_forall in H5; [|eapply I].
           subst.
           rewrite <- contour_VSE; auto.
Qed.

Lemma well_formed_extend :
  forall M vse vs,
    WellFormedVS M vs ->
    variantOf M (curr_variant vse) (contour vse) ->
    InTrace M (MTraceOf (init_machine vse)) ->
    InTrace (curr_variant vse) (MTraceOf (init_variant vse)) ->
    (exists m, forall m', retP vse m' = justRet m m') ->
    publicRegisters (contour vse) ->
    WellFormedVS M (vse :: vs).
Proof.
  intros M vse vs [H1 [[vse' [HLast HR]] [H3 [H4 [H5 H6]]]]] Var InM InV Ret HC.
  repeat split; try solve [constructor; eauto].
  - exists vse'; split; eauto using FLastTail.
Qed.

Lemma FinLastN_depth : forall {A} n (x : A) (xs l : list A), 
  FinLastN n (x :: xs) l -> n <= length xs -> FinLastN n xs l.
Proof.
  intros A n x xs l H.
  remember (x :: xs) as L.
  generalize dependent xs.
  generalize dependent x.
  induction H; intros y ys Eq Len.
  - rewrite Eq in H. simpl in *.
    destruct n; inversion H; subst; auto.
    omega.
  - simpl in *.
    inversion Eq; subst; eauto.
Qed.    

Lemma hd_error_map : forall {A B} (f : A -> B) l x,
    hd_error l = Some x -> hd_error (map f l) = Some (f x).
Proof.
  intros A B f l x H; induction l; simpl in *. 
  - congruence.
  - inversion H; subst; auto.
Qed.

(*
Lemma FinLastDec :
  forall {A} (x : A) l, {FinLast x l} + {~ FinLast x l}.
Proof.
  intros A x l.
  induction l.
  - right; intro C; inv C.
  - destruct IHl.
 *)

(* This appears to be a hack to get an arbitrary policy state,
   but doesn't work with partial pinit; I propose the one below: *)
(*Ltac policify pm m :=
  let p := fresh "p" in
  let HP := fresh "HP" in 
  pose proof (initPolicyState m pm) as p;
  assert (HP: m = ms (m, p)) by auto;
  rewrite HP.*)

Ltac policify mp m' :=
  destruct mp as (m,p);
  assert (HP: m' = ms (m', p)) by auto;
  rewrite HP.

(*
Lemma variant_equalRet :
  forall m vse vs, In vse vs -> WellFormedVS m vs ->
                   publicRegisters (contour vse) ->
                   variantOf
                   forall m m' (isRet 
 *)

Theorem TestImpliesConfidentialityNested :
  forall cm (rm:RetMap) (em:EntryMap) cdm C MP vs n vscall vse R,
    FinLastN n vs vscall ->
    hd_error vscall = Some vse ->
    contour vse = C ->
    ForallButLast (fun mp => ~ retP vse (ms mp)) MP ->
    WellFormedVS (ms (head MP)) vs ->
    EagerStackSafetyTest cm cdm n MP vs ->
    variantOf (ms (head MP)) (curr_variant vse) C ->
    (forall m, retP vse (ms m) = R (ms m)) ->
    StrongEagerStackConfidentiality R MP (curr_variant vse).
Proof.
  cofix COFIX.
  intros cm rm em cdm C MP vs n vscall vse R LastN HCall HC Comp [HVar [[vselast [HLast RFalse]] [InMP [InVar [HRet HPub]]]]] Safety Var HR.
  pose (pm := (cm, rm, em, cdm)).
  destruct MP.
  - destruct vs.
    + inv HLast.
    + eapply Forall_forall with (x := vse) in HRet.
      * destruct HRet as [[m0 HRet] | HRet].
        -- destruct (justRet_dec m0 (ms m)) as [r | r].
           ++ eapply StrongConfEnd.
              ** rewrite <- HR.
                 rewrite HRet.
                 auto.
              ** policify m (curr_variant vse).
                 rewrite <- HR.
                 rewrite HRet.
                 unfold justRet in *.
                 simpl in *.
                 unfold variantOf in Var.
                 eapply Forall_forall with (x := vse) in HPub; eauto.
                 --- do 2 rewrite Var in r; auto;
                     try solve [
                           rewrite <- HC;
                           rewrite HPub;
                           unfold confidentialityOf; auto].
                 --- eapply FinLastNHead_implies_In; eauto.
           ++ eapply StrongConfNotMStep.
              ** rewrite <- HR.
                 rewrite HRet.
                 auto.
              ** policify m (curr_variant vse).
                 rewrite <- HR.
                 rewrite HRet.
                 unfold justRet in *.
                 simpl in *.
                 unfold variantOf in Var.
                 eapply Forall_forall with (x := vse) in HPub; eauto.
                 --- do 2 rewrite Var in r; auto;
                       try solve [
                           rewrite <- HC;
                           rewrite HPub;
                           unfold confidentialityOf; auto].
                 --- eapply FinLastNHead_implies_In; eauto.
        -- eapply StrongConfNotMStep.
           ++ rewrite <- HR.
              rewrite HRet.
              auto.
           ++ policify m (curr_variant vse).
              rewrite <- HR.
              rewrite HRet.
              auto.
      * eapply FinLastNHead_implies_In; eauto.
  - destruct (step (curr_variant vse)) as [mv' o'] eqn:StepV.
    inversion Safety; subst; clear Safety.
    + rename H3 into MPStep.
      extract_mpstep.
      destruct (H5 vse) as [mv'' [ov [VStep VConf]]].
      { eauto using FinLastNHead_implies_In. }
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      rewrite HO in *; auto; clear HO.
      eapply StrongConfStep; simpl in *; eauto.
      * unfold MPState.
        rewrite H8.
        simpl; auto.
      * rewrite <- HR.
        inv Comp.
        eauto.
      * policify m (curr_variant vse).
        rewrite <- HR.
        simpl.
        eapply Forall_forall with (x := vse) in HPub;
          eauto using FinLastNHead_implies_In.
        eapply Forall_forall with (x := vse) in HRet;
          eauto using FinLastNHead_implies_In.
        destruct HRet as [[m0 HRet] | HRet].
        -- inv Comp.
           rewrite HRet.
           rewrite HRet in H3.
           unfold justRet in *.
           intros r.
           unfold variantOf in *.
           do 2 rewrite <- Var in r; eauto;
             try solve [ unfold confidentialityOf;
                         rewrite HPub; auto ].
        -- rewrite HRet.
           auto.
      * unfold MPState.
        rewrite H8 in *.
        intros k [Diff | Diff]; simpl in *; repeat rewriteHyp; simpl in *; auto.
      * remember (VSE_step vse) as vse'.
        assert (HMV' : curr_variant vse' = mv')
          by (subst; unfold VSE_step; simpl; rewriteHyp; simpl; auto).
        rewrite <- HMV'.
        (* right. *)
        apply (COFIX cm rm em cdm (contour vse) MP (VSEs_step vs) n (VSEs_step vscall) vse');
          eauto.
        -- eapply VSE_step_preserves_LastN; eauto.
        -- unfold VSEs_step; simpl.
           rewriteHyp; apply hd_error_map; auto.
        -- unfold VSE_step in *; repeat rewriteHyp; auto.
        -- inv Comp; auto.
           unfold VSE_step.
           rewriteHyp; simpl; auto.
        -- (* Safe step preserves wellformed *)
           unfold MPState. rewrite H8.
           eapply VSE_step_preserves_WellFormed; eauto.
        (* -- (* RB: This (easy) goal is no longer discharged by eauto. *) *)
        (*    destruct H13 as [H13 | H13]; [| easy]. *)
        (*    punfold H13. *)
        -- unfold MPState; repeat rewriteHyp; eapply confStepPreservesVariant; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
        -- subst.
           rewrite <- retP_VSE.
           auto.
    + extract_mpstep.
      rename H3 into MPStep.
      destruct (H5 vse) as [mv'' [ov [VStep VConf]]].
        { eauto using FinLastNHead_implies_In. }
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      rewrite HO in *; simpl in *; clear HO.
      unfold MPState in *.
      eapply StrongConfStep; simpl in *; eauto; unfold MPState in *.
      * rewrite H8; simpl; auto.
      * rewrite <- HR.
        inv Comp.
        eauto.
      * policify m (curr_variant vse).
        rewrite <- HR.
        simpl.
        eapply Forall_forall with (x := vse) in HPub;
          eauto using FinLastNHead_implies_In.
        eapply Forall_forall with (x := vse) in HRet;
          eauto using FinLastNHead_implies_In.
        destruct HRet as [[m0 HRet] | HRet].
        -- inv Comp.
           rewrite HRet.
           rewrite HRet in H3.
           unfold justRet in *.
           intros r.
           unfold variantOf in *.
           do 2 rewrite <- Var in r; eauto;
             try solve [ unfold confidentialityOf;
                         rewrite HPub; auto ].
        -- rewrite HRet.
           auto.
      * intros k [Diff | Diff]; simpl in *; repeat rewriteHyp; simpl in *; auto.
        rewrite H8 in Diff; simpl; eauto.
      * (* Recursive call with self variant. *)
        remember (VSE_step vse) as vse'.
        assert (HMV' : curr_variant vse' = mv')
          by (subst; unfold VSE_step; simpl; rewriteHyp; simpl; auto).
        rewrite <- HMV'.
        remember (Build_VSE (ms m) (ms (head MP)) (ms (head MP)) (makeContour cdm args (ms m)) (justRet (ms m))) as vse_call.
        (* right. *)
        apply (COFIX cm rm em cdm (contour vse) MP (vse_call :: (VSEs_step vs)) n (VSEs_step vscall) vse'); eauto.
        -- constructor; eapply VSE_step_preserves_LastN; eauto.
        -- unfold VSEs_step; simpl.
           rewriteHyp; apply hd_error_map; auto.
        -- unfold VSE_step in *; repeat rewriteHyp; auto.
        -- inv Comp.
           unfold VSE_step; rewriteHyp; simpl; auto.
        -- (* Safe step preserves wellformed *)
          eapply well_formed_extend; eauto.
          ++ rewrite H8. eapply VSE_step_preserves_WellFormed; eauto.
          ++ rewrite Heqvse_call; simpl in *; eauto.
             unfold variantOf.
             intros k HK. auto.
          ++ rewrite Heqvse_call; simpl in *; eauto.
             frobber MTraceOf.
             apply In_later.
             frobber MTraceOf.
             rewrite MStep; simpl.
             rewrite H8; simpl.
             apply In_now.
          ++ frobber MTraceOf. rewrite Heqvse_call; simpl; apply In_now.
          ++ subst.
             exists (ms m).
             intros; simpl; auto.
          ++ subst.
             simpl.
             unfold makeContour, publicRegisters.
             intros r; auto.
        -- (* RB: This (easy) goal is no longer discharged by eauto. *)
           rewrite Heqvse_call.
           seauto.
           (*
           specialize (H16 _ (variantOf_id _ _)).
           (* destruct H14 as [H14 | H14]; [| easy]. *)
           (* punfold H14. *)
           assumption.
            *)
        -- repeat rewriteHyp; eapply confStepPreservesVariant; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
        -- subst.
           rewrite <- retP_VSE; auto.
    + extract_mpstep.
      destruct (H6 vse) as [mv'' [ov [VStep VConf]]].
      { eauto using FinLastNHead_implies_In. }
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      rewrite HO in *.
      eapply StrongConfStep; simpl in *; eauto.
      * unfold MPState; rewrite H10; simpl; auto.
      * rewrite <- HR.
        inv Comp.
        eauto.
      * policify m (curr_variant vse).
        rewrite <- HR.
        simpl.
        eapply Forall_forall with (x := vse) in HPub;
          eauto using FinLastNHead_implies_In.
        eapply Forall_forall with (x := vse) in HRet;
          eauto using FinLastNHead_implies_In.
        destruct HRet as [[m0 HRet] | HRet].
        -- inv Comp.
           rewrite HRet.
           rewrite HRet in H8.
           unfold justRet in *.
           intros r.
           unfold variantOf in *.
           do 2 rewrite <- Var in r; eauto;
             try solve [ unfold confidentialityOf;
                         rewrite HPub; auto ].
        -- rewrite HRet.
           auto.
      * unfold MPState.
        intros k [Diff | Diff]; simpl in *; repeat rewriteHyp; simpl in *; auto.
        rewrite H10 in Diff; auto.
      * (* Recursive call with the tail. *)
        destruct vs as [| vseret vs].
        (* vs is not empty *)
        { inversion HLast. } 

        destruct H1 as [vser [vsrest [Eq [RetR [Len NoR]]]]].
        inversion Eq; subst; eauto.
        rename vsrest into vs.
        rename vser into vseret.

        remember (VSE_step vse) as vse'.
        assert (HMV' : curr_variant vse' = mv')
          by (subst; unfold VSE_step; simpl; rewriteHyp; simpl; auto).
        rewrite <- HMV'.

        (* right. *)
        apply (COFIX cm rm em cdm (contour vse) MP (VSEs_step vs) n (VSEs_step vscall) vse'); eauto.
        -- eapply FinLastN_depth.
           eapply VSE_step_preserves_LastN; unfold VSEs_step; simpl; eauto.
           ++ simpl; eauto.
           ++ unfold VSEs_step; simpl.
              rewrite map_length; auto.
        -- unfold VSEs_step; simpl.
           rewriteHyp; apply hd_error_map; auto.
        -- unfold VSE_step in *; repeat rewriteHyp; auto.
        -- inv Comp. unfold VSE_step; rewriteHyp; simpl; auto.
        -- assert (WF : WellFormedVS (ms (head MP)) (VSE_step vseret :: VSEs_step vs)).
           { unfold MPState. rewrite H10. simpl.
             eapply VSE_step_preserves_WellFormed; eauto. 
           }
           destruct WF as [HVar' [HLast' [HInM' [HInV' [HRet' HPub']]]]].
           repeat split.
           ** inversion HVar'; eauto.
           ** destruct HLast' as [vseL [HPvseL HRetL]]; exists vseL; split; eauto.
              inversion HPvseL; subst; eauto.
              (* Case where we returned from the last stack element,
                 but that can't happen. But this proof is hideous *)
              symmetry in H8.
              unfold VSEs_step in *.
              apply map_eq_nil in H8.
              subst; auto.
              inversion HLast; subst; eauto.
              --- exfalso.
                  rewrite RFalse in RetR.
                  inversion RetR.
              --- inversion H1. 
             ** inversion HInM'; eauto.
             ** inversion HInV'; eauto.
             ** inv HRet'; eauto.
             ** inv HPub'; eauto.
        -- unfold MPState. repeat rewriteHyp. eapply confStepPreservesVariant; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
        -- subst; rewrite <- retP_VSE; auto.
    + extract_mpstep.
      destruct (H5 vse) as [mv'' [ov [VStep VConf]]].
      { eauto using FinLastNHead_implies_In. }
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      rewrite HO in *.
      subst.
      unfold MPState in *.
      eapply StrongConfStep; simpl in *; eauto; unfold MPState in *.
      * rewrite H8; simpl; auto.
      * rewrite <- HR.
        inv Comp.
        eauto.
      * policify m (curr_variant vse).
        rewrite <- HR.
        simpl.
        eapply Forall_forall with (x := vse) in HPub;
          eauto using FinLastNHead_implies_In.
        eapply Forall_forall with (x := vse) in HRet;
          eauto using FinLastNHead_implies_In.
        destruct HRet as [[m0 HRet] | HRet]. 
        -- inv Comp.
           rewrite HRet.
           rewrite HRet in H7.
           unfold justRet in *.
           intros r.
           unfold variantOf in *.
           do 2 rewrite <- Var in r; eauto;
             try solve [ unfold confidentialityOf;
                         rewrite HPub; auto ].
        -- rewrite HRet.
           auto.
      * intros k [Diff | Diff]; simpl in *; repeat rewriteHyp; simpl in *; auto.
        rewrite H8 in Diff; eauto.
      * (* Recursive call with the tail/added. *)
        destruct vs as [| vseret vs].
        (* vs is not empty *)
        { inversion HLast. } 

        destruct H2 as [vser [vsrest [Eq [RetR [Len NoR]]]]].
        inversion Eq; subst; eauto.
        rename vsrest into vs.
        rename vser into vseret.

        remember (VSE_step vse) as vse'.
        assert (HMV' : curr_variant vse' = mv')
          by (subst; unfold VSE_step; simpl; rewriteHyp; simpl; auto).
        rewrite <- HMV'.

        remember (Build_VSE (ms m) (ms (head MP)) (ms (head MP)) (makeContour cdm args (ms m)) (justRet (ms m))) as vse_call.
        
        apply (COFIX cm rm em cdm (contour vse) MP (vse_call :: (VSEs_step vs)) n (VSEs_step vscall) vse').

        -- constructor.
           eapply FinLastN_depth.
           eapply VSE_step_preserves_LastN; unfold VSEs_step; simpl; eauto.
           ++ simpl; eauto.
           ++ unfold VSEs_step; simpl.
              rewrite map_length; auto.
        -- unfold VSEs_step; simpl.
           rewriteHyp; apply hd_error_map; auto.
        -- unfold VSE_step in *; repeat rewriteHyp; auto.
        -- inv Comp; unfold VSE_step; rewriteHyp; simpl; auto.
        -- assert (WF : WellFormedVS (ms (head MP)) (VSE_step vseret :: VSEs_step vs)).
           { unfold MPState in *; rewrite H8; simpl.
             eapply VSE_step_preserves_WellFormed; eauto. }
           destruct WF as [HVar' [HLast' [HInM' [HInV' [HRet' HPub']]]]].
           eapply well_formed_extend; eauto.
           ++ repeat split.
              ** inversion HVar'; subst; eauto.
              ** destruct HLast' as [vseL [HPvseL HRetL]]; exists vseL; split; eauto.
                 inversion HPvseL; subst; eauto.
                 (* Case where we returned from the last stack element,
                 but that can't happen. But this proof is hideous *)
                 symmetry in H7.
                 unfold VSEs_step in *.
                 apply map_eq_nil in H7.
                 subst; auto.
                 inversion HLast; subst; eauto.
                 --- exfalso.
                     rewrite RFalse in RetR.
                     inversion RetR.
                 --- inversion H2.
             ** inversion HInM'; eauto.
             ** inversion HInV'; eauto.
             ** inversion HRet'; eauto.
             ** inversion HPub'; eauto.
           ++ rewrite Heqvse_call; simpl in *; seauto.
           ++ rewrite Heqvse_call; simpl in *.
              frobber MTraceOf.
              apply In_later.
              frobber MTraceOf.
              rewrite MStep; simpl.
              rewrite H8; simpl.
              apply In_now.
           ++ frobber MTraceOf. rewrite Heqvse_call; simpl; apply In_now.
           ++ subst; simpl.
              exists (ms m); auto.
           ++ subst; simpl.
              unfold makeContour, publicRegisters; auto.
        -- rewrite Heqvse_call. seauto.
        -- repeat rewriteHyp. eapply confStepPreservesVariant; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
        -- subst.
           rewrite <- retP_VSE.
           auto.
Qed.

(*
Corollary TestImpliesConfidentialityToplevel :
  forall cm C MP,
    MPStepCompatible (fun _ => False) MP ->
    (forall vs vse, 
        FinLast vse vs ->
        contour vse = C ->
        WellFormedVS (ms (head MP)) vs ->
        variantOf (ms (head MP)) (curr_variant vse) C ->
        EagerStackSafetyTest cm 1 MP vs) ->
    EagerStackConfidentiality C MP (fun _ => False).
Proof.
  intros.
  eapply StrongConfImpliesConf.
  intros.
  remember (Build_VSE (ms (head MP)) m m C (fun _ => False)) as vse.
  assert (m = curr_variant vse) by (subst; auto).
  rewrite H2.
  eapply (TestImpliesConfidentialityNested cm C MP [vse] 1 [vse] vse); simpl; auto.
  - constructor; simpl; auto.
  - subst; auto.
  - subst; auto.    
  - repeat split.
    + constructor; eauto.
      subst; auto.
    + exists vse; split; auto.
      * constructor; auto.
      * subst; auto.
    + constructor; subst; simpl; auto.
      frob (MTraceOf (ms (head MP))).
      apply In_now.
    + constructor; subst; simpl; auto.
      frob (MTraceOf m); auto.
      apply In_now.
  - eapply H0; eauto.
    + econstructor.
    + subst; eauto.
    + repeat split.
      * constructor; eauto.
        subst; auto.
      * exists vse; split; auto.
        -- constructor; auto.
        -- subst; auto.
      * constructor; subst; simpl; auto.
        frob (MTraceOf (ms (head MP))).
        apply In_now.
      * constructor; subst; simpl; auto.
        frob (MTraceOf m); auto.
        apply In_now.
    + subst; auto.
  - subst; seauto.
Qed.
*)

Fixpoint fixN {A} (f : A -> A) n (x : A) :=
  match n with
  | O => x
  | S n' => fixN f n' (f x)
  end.

Definition VSEs_fix := fixN VSEs_step.
Definition VSE_fix := fixN VSE_step.
Definition tl_fix {A} := fixN (@tl A).

Lemma fixN_nilr : forall A n (f : list A -> list A),
    f [] = [] ->
    fixN f n [] = [].
Proof.
  intros A n f H ; induction n; simpl; try rewriteHyp; eauto.
Qed.    

Lemma VSEs_fix_consr : forall n v vs, VSEs_fix n (v::vs) = VSE_fix n v :: VSEs_fix n vs.
  intros n; induction n; simpl; eauto.
Qed.    

(*
Lemma VSE_fix_commute :
  forall n vs, 
  VSEs_fix n vs = map (VSE_fix n) vs.
Proof.
  intros.
  induction vs.
  - simpl; apply fixN_nilr.
    unfold VSE_step; simpl; auto.
  - destruct n; simpl in *.
    + unfold VSEs_fix, VSE_fix; simpl; f_equal; auto.
    + unfold VSEs_fix, VSE_fix; simpl; auto.
      
Qed.
 *)

Inductive TLen {A}: TraceOf A -> nat -> Prop :=
| TLen_end  : forall a, TLen (finished a) 0
| TLen_step : forall n a T, TLen T n -> TLen (notfinished a T) (S n).

Inductive RetsContained : MPTrace -> list (MachineState -> Prop) -> nat -> Prop :=
| FinRetC : forall rs x,
    RetsContained (finished x) rs 0 (* In the last one its not added *)
| NFinRet :
    forall (r : MachineState -> Prop) (rs rs' : list (MachineState -> Prop)) x n T, 
    rs = r :: rs' ->
    r (ms x) ->
    (forall (r' : MachineState -> Prop), In r' rs' -> ~ r' (ms x)) ->
    RetsContained T rs' n ->
    RetsContained (notfinished x T) rs (S n)
| NFinNRet : forall (rs : list (MachineState -> Prop)) x n T, 
    (forall r, In r rs -> ~ r (ms x)) ->
    RetsContained T rs n ->
    RetsContained (notfinished x T) rs n.

Ltac vse_reasoning :=
  match goal with
  | |- context [retP (VSE_step ?V)] =>
    unfold VSE_step; destruct (step (curr_variant V)); simpl; auto
  | [H : In ?X (VSEs_step ?VS) |- _ ] =>
        unfold VSEs_step in *;
          apply in_map_iff in H;
          let x := fresh "x" in
          let Feq := fresh "Feq" in
          let HIn := fresh "HIn" in
          destruct H as [x [Feq HIn]];
            let Eq := fresh "EQ" in
            assert (Eq: retP X = retP x)
              by (rewrite <- Feq; unfold VSE_step; destruct (step (curr_variant x)); simpl; auto)                   ;
            rewrite Eq
      end.

(*
Lemma RetsContained_VSEs_step :
  forall T vs n,
    RetsContained T vs n -> RetsContained T n.
Proof.  
  intros; induction H; unfold VSEs_step in *; simpl in *.
  - eapply FinRetC. 
  - eapply (NFinRet (VSEs_step vs) (VSE_step v) (VSEs_step vs')); eauto.
    + rewrite H; simpl; auto.
    + vse_reasoning. 
    + intros.
      vse_reasoning.
      eapply H1; eauto.
  - eapply (NFinNRet (VSEs_step vs)); eauto.
    intros; vse_reasoning.
    eapply H; eauto.
Qed.
 *)

(*

Lemma RetsContained_VSEs_step_inv :
  forall T vs n,
    RetsContained T (VSEs_step vs) n -> RetsContained T vs n.
Proof.  
  intros.
  remember (VSEs_step vs) as VS.
  unfold VSEs_step in *.
  assert (Hyp: forall v, In v VS -> exists v', VSE_step v' = v /\ In v' vs).
  { intros.
    rewrite HeqVS in H0.
    eapply in_map_iff in H0.
    auto.
  }
  clear HeqVS.
  induction H; unfold VSEs_step in *; intros; simpl in *.
  - eapply FinRetC. 
  - eapply NFinRet; eauto.
    eapply NFinRet; eauto.
    
    eapply RetsContained_VSEs_step in Eq.
    eapply (NFinRet vs v vs'); eauto.
    eapply (NFinRet (VSEs_step vs) (VSE_step v) (VSEs_step vs')); eauto.
    + rewrite H; simpl; auto.
    + vse_reasoning. 
    + intros.
      vse_reasoning.
      eapply H1; eauto.
  - eapply (NFinNRet (VSEs_step vs)); eauto.
    intros; vse_reasoning.
    eapply H; eauto.
Qed.
*)

Lemma tl_fixNStep :
  forall n vs, tl (fixN VSEs_step n vs) = fixN VSEs_step n (tl vs).
Proof.
  intros n vs; induction vs.
  - simpl.
    assert (fixN VSEs_step n [] = [])
      by (apply fixN_nilr; unfold VSEs_step; auto).
    rewrite H; simpl; auto.
  - rewrite (VSEs_fix_consr); simpl.
    auto.
Qed.

Lemma map_ret_VSE :
  forall vs, map retP vs = map retP (VSEs_step vs).
Proof.
  intros vs; induction vs; simpl; eauto.
  f_equal.
  - unfold VSE_step. destruct (step (curr_variant a)); auto.
  - auto.
Qed.

Lemma map_ret_VSE' :
  forall vs r rs,
    map retP vs = r :: rs ->
    map retP (tl (VSEs_step vs)) = rs.
Proof.  
  intros vs; induction vs; intros; inv H; simpl in *; auto.
  rewrite <- map_ret_VSE.
  auto.
Qed.

Lemma SplitPreservesSafety :
  forall cm cdm MP MPpre MPsuff,
    SplitInclusive (fun mp => exists args, isCall cm (ms mp) args) MP MPpre MPsuff ->
    forall steps rets n vs,
      TLen MPpre steps ->
      RetsContained MPpre (map retP vs) rets ->
      EagerStackSafetyTest cm cdm n MP vs ->
      EagerStackSafetyTest cm cdm n MPsuff (fixN (@tl _) rets (fixN VSEs_step steps vs)).
Proof.
  intros cm cdm MP MPpre MPsuff Split;
    induction Split; intros steps rets n vs Len Rets Safety.
  - inv Len; inversion Safety; subst; simpl in *.
    + inv Rets; simpl.
      eapply EagerTestFinFault; eauto.
    + inv Rets.
      eapply EagerTestFinRet; eauto.
  - inv Len; inv Rets; eauto.
  - inv Len; inv Safety.
    + inv Rets; simpl.
      * exfalso.
        assert (HIn: In r (map retP vs)) by (rewriteHyp; left; auto).
        eapply in_map_iff in HIn.
        destruct HIn as [x [HR HIn]].
        rewrite <- HR in H11; eapply H4; eauto.
      * eapply IHSplit; eauto.
        rewrite <- map_ret_VSE.
        auto.
    + exfalso.
      eapply H.
      exists args; auto.
    + inv Rets.
      * simpl.
        rewrite tl_fixNStep; simpl.
        eapply IHSplit; eauto.
        rewrite (map_ret_VSE' vs r rs'); eauto.
      * exfalso.
        destruct H2 as [vse [vsrest [Eq [Ret [Len NotR]]]]].
        subst.
        eapply H10.
        -- left; auto.
        -- auto.
    + exfalso; eapply H; eauto.
Qed.

Lemma SplitInclusive_TLen :
  forall {A} (P : A -> Prop)  T Tpre Tsuff, 
  SplitInclusive P T Tpre Tsuff ->
  exists n, TLen Tpre n.
Proof.
  intros A P T Tpre Tsuff Split; induction Split.
  - exists 0; constructor.
  - exists 0; constructor.
  - destruct IHSplit as [n Hn].
    exists (S n); constructor; auto.
Qed.

Lemma SplitInclusive_Rets :
  forall cm cdm MP MPpre MPsuff, 
    SplitInclusive (fun mp => exists args, isCall cm (ms mp) args) MP MPpre MPsuff ->
    forall n vs, EagerStackSafetyTest cm cdm n MP vs ->
    exists rets, RetsContained MPpre (map retP vs) rets.
Proof.
  intros cm cdm MP MPpre MPsuff Split; induction Split; intros n vs Safety.
  - exists 0; eapply FinRetC.
  - exists 0; eapply FinRetC.
  - inv Safety.
    + eapply IHSplit in H11.
      destruct H11 as [rets HRets].
      exists rets.
      rewrite <- map_ret_VSE in HRets.
      eapply NFinNRet; eauto.
      intros.
      eapply in_map_iff in H0.
      destruct H0 as [x [R I]].
      rewrite <- R.
      eapply H3; auto.
    + exfalso; eapply H; eauto.
    + eapply IHSplit in H13.
      destruct H13 as [rets HRets].
      exists (S rets).
      destruct vs.
      * destruct H2 as [? [? [Contra ?]]]; inv Contra.
      * apply (NFinRet (retP (VSE_step v)) (map retP (v :: vs)) (map retP vs)); eauto.
        -- simpl.
           f_equal.
           ++ unfold VSE_step; destruct (step (curr_variant v)); simpl; auto.
        -- destruct H2 as [vse [vsrest [Eq [Ret ?]]]].
           inv Eq.
           auto.
           unfold VSE_step.
           destruct (step (curr_variant vse)); simpl; auto.
        -- destruct H2 as [vse [vsrest [Eq [Ret [Len NotR]]]]].
           intros.
           apply in_map_iff in H0.
           destruct H0 as [x [R I]].
           rewrite <- R.
           eapply NotR.
           inv Eq.
           simpl in I.
           auto.
        -- erewrite map_ret_VSE' in HRets; eauto.
           simpl.
           f_equal.
    + exfalso; eapply H; eauto.
Qed.

Lemma FindCallMP_Contour :
  forall cm cdm MP C MPsuff,
  FindCallMP cm cdm MP C MPsuff ->
  exists args,
    isCall cm (ms (head MPsuff)) args /\
    C = makeContour cdm args (ms (head MPsuff)) /\
    publicRegisters C.
Proof.
  intros cm cdm MP C MPsuff H; induction H.
  - exists args; repeat split; auto.
    unfold makeContour, publicRegisters in *; simpl; intros; auto.
    rewrite <- H1. auto.
  - auto.
Qed.
    
Lemma FindCallPreservesSafety :
  forall cm cdm MP C MPsuff,
    FindCallMP cm cdm MP C MPsuff ->
    forall n vs,
      EagerStackSafetyTest cm cdm n MP vs ->
      exists vs', WellFormedVS (ms (head MPsuff)) vs' /\
      EagerStackSafetyTest cm cdm n MPsuff vs'.
Proof.
  intros cm cdm MP C MPsuff Find; induction Find; intros n vs Safety.  
  - assert (Hyp: exists steps, TLen MPpre steps).
    { eapply SplitInclusive_TLen; eauto. }
    destruct Hyp as [steps Hsteps].
    assert (Hyp: exists rets, RetsContained MPpre (map retP vs) rets). 
    { eapply SplitInclusive_Rets; eauto. }
    destruct Hyp as [rets HRets].
    eapply SplitPreservesSafety in H; eauto.
    exists (fixN (tl (A:=VSE)) rets (fixN VSEs_step steps vs)).
    split; eauto.
    inv H; eauto.
  - eapply IHFind1 in Safety; clear IHFind1.
    destruct Safety as [vs' [WF Safety]].
    subst.
    destruct (FindCallMP_Contour _ _ _ _ _ Find1) as [f [args [HCall _]]].
    inv Safety.
    + exfalso; eapply H1; eauto.
    + eapply IHFind2 in H14; eauto using variantOf_id.
    + exfalso; eapply H2; eauto.
    + eapply IHFind2 in H15; eauto using variantOf_id.
Qed.

Lemma TestImpliesDepth :
  forall cm cdm n MP vs,
  EagerStackSafetyTest cm cdm n MP vs ->
  length vs >= n.
Proof.
  intros cm cdm n MP vs Safety.
  inv Safety; eauto.
  destruct H0 as [? [? [Eq [? [Len ?]]]]].
  rewrite Eq.
  simpl.
  omega.
Qed.

Lemma FinLastN_lt :
  forall {A} n (L l : list A), FinLastN n L l -> n <= length L.
Proof.
  intros; induction H.
  - subst; apply le_n.
  - simpl. apply le_S. auto.
Qed.

Lemma SplitInclusive_Safety :
  forall MP MPpre MPsuff cm cdm (R : MPState -> Prop),
    SplitInclusive R MP MPpre MPsuff ->
    forall n n' vs vse vs',
      EagerStackSafetyTest cm cdm n MP vs ->
      FinLastN n' vs (vse :: vs') ->
      (forall mp, retP vse (ms mp) = R mp) ->
      EagerStackSafetyTest cm cdm n' MPpre vs.
Proof.
  intros MP MPpre MPsuff cm cdm R HSuff.
    induction HSuff; intros n n' vs vse vs' Safety LastN HR.
    + inversion Safety. 
      * subst; eapply EagerTestFinFault; auto.
        eapply FinLastN_lt; eauto.
      * subst.
        inv LastN.
        -- eapply EagerTestFinRet; eauto.
        -- exfalso. (* Impossible because the only return can be the top. *)
           eapply H5.
           ++ eapply FinLastNHead_implies_In; simpl; eauto.
              simpl; eauto.
           ++ rewrite HR.
              auto.
    + inv Safety.
      * exfalso.
        eapply H3; eauto.
        -- eapply FinLastNHead_implies_In; simpl; eauto.
           simpl; eauto.
        -- rewrite HR; auto.
      * exfalso.
        eapply H3; eauto.
        -- eapply FinLastNHead_implies_In; simpl; eauto.
           simpl; eauto.
        -- rewrite HR; auto.
      * destruct H2 as [vse' [vsrest' [Eq [HR' [Len NoR]]]]].
        inv LastN.
        -- inv H9.
           eapply EagerTestFinRet; eauto.
        -- inv H2; simpl in *.
           exfalso.
           eapply NoR.
           ++ eapply FinLastNHead_implies_In; simpl; eauto.
              simpl; eauto.
           ++ rewrite HR; eauto.
      * destruct H3 as [vse' [vsrest' [Eq [HR' [Len NoR]]]]].
        inv LastN.
        -- inv H8.
           eapply EagerTestFinRet; eauto.
        -- inv H3; simpl in *.
           exfalso.
           eapply NoR.
           ++ eapply FinLastNHead_implies_In; simpl; eauto.
              simpl; eauto.
           ++ rewrite HR; eauto.
    + inv Safety.
      * eapply EagerTestStep; eauto.
        -- rewrite <- H9.
           symmetry. eapply PrefixUpToHead; left; eexists; eauto.
        -- eapply IHHSuff with (vse := VSE_step vse); eauto.
           ++ eapply VSE_step_preserves_LastN; simpl; eauto.
              simpl. eauto.
           ++ intros; auto.
              unfold VSE_step, upd_curr.
              destruct (step (curr_variant vse)); auto.
              simpl; eauto.
        -- eapply FinLastN_lt; eauto.
      * assert (EqT: @head (@prod MachineState PolicyState) T =
                     @head (@prod MachineState PolicyState) Tpre).
        { eapply PrefixUpToHead; left; eexists; eauto. }
        eapply EagerTestCall; eauto.
        -- rewrite <- H9; symmetry; auto.
        -- reflexivity.
        -- intros.
           eapply IHHSuff with (vse := VSE_step vse); eauto.
           eapply H15.
           ++ rewrite EqT; auto.
           ++ constructor.
              eapply VSE_step_preserves_LastN; simpl; eauto.
              simpl; eauto.
           ++ intros; auto.
              unfold VSE_step, upd_curr.
              destruct (step (curr_variant vse)); auto.
              simpl; auto.
        -- eapply FinLastN_lt; eauto.
      * assert (EqT: @head (@prod MachineState PolicyState) T =
                     @head (@prod MachineState PolicyState) Tpre).
        { eapply PrefixUpToHead; left; eexists; eauto. }
        eapply EagerTestRet; eauto.
        -- destruct H2 as [vse' [vsrest' [Eq [HRet [Len NoR]]]]].
           exists vse'. exists vsrest'.
           repeat split; auto.
           inv LastN.
           ++ inv H9; auto.
              exfalso. eapply H.
              rewrite <- HR.
              auto.
           ++ inv H2.
              eapply FinLastN_lt; eauto.
        -- destruct H2 as [vse' [vsrest' [Eq [HRet [Len NoR]]]]].
           eapply FinLastN_lt; eauto.
        -- rewrite <- EqT; auto.
        -- destruct H2 as [vse' [vsrest' [Eq [HRet [Len NoR]]]]].
           eapply IHHSuff with (vse := VSE_step vse)
                               (vs := tl (VSEs_step vs))
                               (vs' := (VSEs_step vs')); eauto.
           ++ inv LastN.
              ** inv H9.
                 exfalso.
                 eapply H.
                 rewrite <- HR.
                 auto.
              ** inv H2.
                 simpl.
                 eapply VSE_step_preserves_LastN; simpl; eauto.
           ++ intros; auto.
              unfold VSE_step, upd_curr.
              destruct (step (curr_variant vse)).
              simpl.
              eauto.

      * assert (EqT: @head (@prod MachineState PolicyState) T =
                     @head (@prod MachineState PolicyState) Tpre).
        { eapply PrefixUpToHead; left; eexists; eauto. }
        eapply EagerTestRetCall; eauto.
        -- destruct H3 as [vse' [vsrest' [Eq [HRet [Len NoR]]]]].
           exists vse'. exists vsrest'.
           repeat split; auto.
           inv LastN.
           ++ inv H8; auto.
              exfalso. eapply H.
              rewrite <- HR.
              auto.
           ++ inv H3.
              eapply FinLastN_lt; eauto.
        -- rewrite <- EqT; auto.
        -- reflexivity.
        -- intros.
           destruct H3 as [vse' [vsrest' [Eq [HRet [Len NoR]]]]].           
           eapply IHHSuff with (vse := VSE_step vse)
                               (vs' := (VSEs_step vs')); eauto.
           ++ eapply H16.
              rewrite EqT; auto.
           ++ constructor.
              inv LastN.
              ** inv H10.
                 exfalso.
                 eapply H.
                 rewrite <- HR.
                 auto.
              ** inv H8.
                 simpl.
                 eapply VSE_step_preserves_LastN; simpl; eauto.
           ++ intros; auto.
              unfold VSE_step, upd_curr.
              destruct (step (curr_variant vse)).
              simpl.
              eauto.
Qed.

Lemma Eq_Safety :
  forall MP MP' cm cdm,
    MP ~= MP' ->
    forall R n n' vs vse vs',
      EagerStackSafetyTest cm cdm n MP vs ->      
      ForallTrace (fun m => ~ R m) MP ->
      n <= n' ->
      FinLastN n' vs (vse :: vs') ->
      (forall mp, retP vse (ms mp) = R mp) ->
      EagerStackSafetyTest cm cdm n' MP' vs.
Proof.
  cofix COFIX.
  intros MP MP' cm cdm Eq R n n' vs vse vs' Safety NoR LT LastN EqR.
  inversion Safety; subst; inv Eq.
  - eapply EagerTestFinFault; eauto.
    eapply FinLastN_lt; eauto.
  - inv NoR.
    inversion LastN; subst.
    + exfalso.
      eapply H3.
      rewrite <- EqR.
      auto.
    + eapply EagerTestFinRet; eauto.
      eapply FinLastN_lt in H7.
      exfalso.
      simpl in LT.
      omega.
  - eapply EagerTestStep; eauto.
    + inv H11; eauto.
    + unfold VSEs_step. simpl.
      eapply COFIX with (R := R) (vse := VSE_step vse); eauto.      
      * inv NoR; auto.
      * eapply VSE_step_preserves_LastN; eauto.
        simpl; eauto.
      * unfold VSE_step.
        destruct (step (curr_variant vse)).
        simpl.
        auto.
    + eapply FinLastN_lt; eauto.
  - eapply EagerTestCall; eauto.
    + inv H13; eauto.
    + reflexivity.
    + intros.
      eapply COFIX with (R := R) (vse := VSE_step vse); eauto.
      * eapply H11.
        inv H13; auto.
      * inv NoR; auto.
      * constructor.
        eapply VSE_step_preserves_LastN; eauto.
        simpl; eauto.
      * vse_reasoning.
    + eapply FinLastN_lt; eauto.
  - eapply EagerTestRet; eauto.
    + destruct H as [vse' [vsrest' [Eq' [HR' [Len' NoR']]]]].
      exists vse'. exists vsrest'.
      repeat split; auto.
      * inv LastN.
        -- inv H10.
           exfalso.
           inv NoR.
           eapply H9.
           rewrite <- EqR.
           auto.
        -- inv H9.
           eapply FinLastN_lt; eauto.
    + eapply FinLastN_lt; eauto.
    + inv H11; subst; auto.
    + destruct H as [vse' [vsrest' [Eq' [HR' [Len' NoR']]]]].
      inv LastN.
      * inv H10.
        exfalso.
        inv NoR.
        eapply H9.
        rewrite <- EqR.
        auto.
      * inv H9.
        simpl in *.
        eapply COFIX with (R := R) (vse := VSE_step vse); eauto.      
        -- inv NoR; auto.
        -- eapply VSE_step_preserves_LastN; eauto.
           simpl; eauto.
        -- unfold VSE_step.
           destruct (step (curr_variant vse)).
           simpl.
           auto.
  - eapply EagerTestRetCall; eauto; try solve [reflexivity].
    + destruct H0 as [vse' [vsrest' [Eq' [HR' [Len' NoR']]]]].
      exists vse'. exists vsrest'.
      repeat split; auto.
      * inv LastN.
        -- inv H10.
           exfalso.
           inv NoR.
           eapply H7.
           rewrite <- EqR.
           auto.
        -- inv H7.
           eapply FinLastN_lt; eauto.
    + inv H12; subst; auto.
    + destruct H0 as [vse' [vsrest' [Eq' [HR' [Len' NoR']]]]].
      inv LastN.
      * inv H10.
        exfalso.
        inv NoR.
        eapply H7.
        rewrite <- EqR.
        auto.
      * intros.
        inv H7.
        simpl in *.
        eapply COFIX with (R := R) (vse := VSE_step vse); eauto.
        -- eapply H11.
           inv H12; eauto.
        -- inv NoR; auto.
        -- constructor.
           eapply VSE_step_preserves_LastN; eauto.
           simpl; eauto.
        -- unfold VSE_step.
           destruct (step (curr_variant vse)).
           simpl.
           auto.
Qed.

Lemma PrefixUpTo_Safety : 
  forall (MP MPpre MPsuff : TraceOf MPState) (cm : CallMap) (cdm : CodeMap) (R : MPState -> Prop),
    PrefixUpTo R MP MPpre ->
    forall (n : nat) (vs : VarStack) (vse : VSE) (vs' : list VSE),
      EagerStackSafetyTest cm cdm n MP (vse :: vs) ->
      (forall mp : MPState, retP vse (ms mp) = R mp) ->
      EagerStackSafetyTest cm cdm (S (length vs)) MPpre (vse :: vs).
Proof.
  intros.
  destruct H as [[Tsuff Hsuff] | [NoR Eq]].
  - eapply SplitInclusive_Safety; eauto.
    eapply TestImpliesDepth in H0; eauto.
    constructor; simpl; auto.
  - eapply Eq_Safety; eauto.
    + eapply TestImpliesDepth in H0; eauto.
    + constructor; simpl; auto.
Qed.

Lemma PrefixUpTo_FirstStep :
  forall m MP MPpre, 
  PrefixUpTo (fun mp => justRet (ms m) (ms mp)) 
             (notfinished m MP) MPpre ->
  exists MPpre',
    MPpre = notfinished m MPpre' /\
    PrefixUpTo (fun mp => justRet (ms m) (ms mp)) MP MPpre'.
Proof.  
  intros m MP MPpre Pre.
  destruct Pre as [[TSuff Hsuff] | [NoR Eq]].
  - inv Hsuff.
    + exfalso.
      unfold justRet in *.
      destruct H3.
      inv H.
      eapply wplus_neq in H2.
      auto.
      omega.
    + exists Tpre. split; auto. left. exists TSuff; auto.
  - inv Eq.
    exists T2.
    split; auto.
    right; split; auto.
    inv NoR; auto.
Qed.

Lemma isCall_inj :
  forall cm m args args',
    isCall cm m args -> isCall cm m args' -> args = args'.
Proof.
  intros. unfold isCall in *.
  rewrite H in H0.
  inv H0.
  auto.
Qed.

Lemma SplitInclusive_Forall :
  forall A (R : A -> Prop) T Tpre Tsuff,
    SplitInclusive R T Tpre Tsuff ->
    ForallButLast (fun a => ~ R a) Tpre.
Proof.
  intros A R T Tpre Tsuff Split.
  induction Split; constructor; eauto.
Qed.

Lemma ForallTrace_ForallButLast :
  forall A (R : A -> Prop) T T',
    T ~= T' ->
    ForallTrace R T ->
    ForallButLast R T'.
Proof.
  cofix COFIX.
  intros A R T T' Eq H.
  inv Eq; inv H.
  - constructor.
  - constructor; eauto.
Qed.
    
Lemma PrefixUpTo_Forall :
  forall A (R : A -> Prop) T TPre,
  PrefixUpTo R T TPre ->
  ForallButLast (fun a => ~ R a) TPre.
Proof.
  intros A R T Tpre Pre.
  destruct Pre as [[TSuff HSuff] | [NoR Eq]].
  - eapply SplitInclusive_Forall; eauto.
  - eapply ForallTrace_ForallButLast; eauto.
Qed.
    
Theorem TestImpliesSafetyCall :
  forall cm (rm : RetMap) cdm n MP vs,
    EagerStackSafetyTest cm cdm n MP vs ->
    forall C' MP' MPpre',
    FindCallMP cm cdm MP C' MP' ->
    PrefixUpTo (fun mp => justRet (ms (head MP')) (ms mp)) MP' MPpre' ->
    EagerStackIntegrityThru C' MPpre' /\
    EagerStackConfidentialityOld C' MPpre' (justRet (ms (head MPpre'))).
Proof.
  intros cm rm cdm n MP vs Safety C' MP' MPpre' Find Pre.
  remember Find as Call; clear HeqCall.
  eapply FindCallPreservesSafety in Call; eauto.
  clear Safety.
  destruct Call as [vs' [WF Safety]].
  eapply FindCallMP_Contour in Find.
  destruct Find as [args [Call [HC HPub]]].
  destruct MP'.
  { (* finished case. Easy. *)
    assert (Eq: MPpre' = finished m).
    { destruct Pre as [[TSuff Hsuff] | [NoR Eq]].
      - inv Hsuff; auto.
      - inv Eq; auto.
    }
    subst.
    split.
    - unfold EagerStackIntegrityThru; intros; simpl; auto.
      inv H0. auto.
    - eapply StrongConfImpliesConf; intros; simpl.
      inv Safety.
      + destruct Pre as [[TSuff Hsuff] | [NoR Eq]].
        * inv Hsuff; simpl in *.
          eapply StrongConfEnd; auto.
          unfold variantOf in H.
          unfold justRet in *.
          rewrite <- H; [rewrite <- H | ]; auto;
          unfold publicRegisters in *;
          rewrite HPub; simpl; auto.
        * inv NoR; simpl in *;
          eapply StrongConfNotMStep; eauto.
          intros Contra.
          eapply H3.
          unfold variantOf, justRet in *.
          rewrite <- H in Contra; [rewrite <- H in Contra |]; auto;
            unfold publicRegisters in *; rewrite HPub; simpl; auto.
      + destruct Pre as [[TSuff Hsuff] | [NoR Eq]].
        * inv Hsuff; simpl in *.
          eapply StrongConfEnd; auto.
          unfold variantOf in H.
          unfold justRet in *.
          rewrite <- H; [rewrite <- H | ]; auto;
          unfold publicRegisters in *;
          rewrite HPub; simpl; auto.
        * inv NoR; simpl in *;
          eapply StrongConfNotMStep; eauto.
          intros Contra.
          eapply H2.
          unfold variantOf, justRet in *.
          rewrite <- H in Contra; [rewrite <- H in Contra |]; auto;
            unfold publicRegisters in *; rewrite HPub; simpl; auto.
  }
  simpl in *; inv Safety.
  - exfalso; eapply H1; eauto.
  - apply PrefixUpTo_FirstStep in Pre.
    assert (Hyp: args0 = args) by (eapply isCall_inj; eauto); subst.
    destruct Pre as [MPpre [Eq Pre]].
    subst; simpl in *.
    auto.
    split.
    + eapply StackIntegrityIndEquiv.
      apply SI_notfinished; auto.
      * unfold EagerIntegrityTest in H6.
        intros k Hk.
        unfold EagerIntegrityTest in *.
        apply PrefixUpToHead in Pre.
        rewrite <- Pre.
        unfold MPState. (* lol *)
        rewrite H8; simpl.
        eapply H11; eauto.
      * remember (Build_VSE (ms m) (ms (head MP')) (ms (head MP')) (makeContour cdm args (ms m)) (justRet (ms m))) as vse.

        assert (Safety: EagerStackSafetyTest cm cdm (S (length (VSEs_step vs'))) MPpre (vse :: VSEs_step vs')).
        { eapply PrefixUpTo_Safety; subst; simpl in*; eauto using variantOf_id. }

        eapply TestImpliesIntegrityNested; eauto.
        -- constructor; simpl; auto.
        -- simpl; eauto.
        -- subst; simpl; auto.
        -- eapply PrefixUpTo_Forall; subst; simpl; eauto.
    + extract_mpstep.
      eapply StrongConfImpliesConf.
      rewrite H8 in H14.
      intros mv Var; simpl in *.
      destruct (step mv) as [mv' OV] eqn:StepV.
      destruct (H10 mv mv' OV); eauto; subst.
      eapply StrongConfStep; eauto.
      * erewrite <- PrefixUpToHead; eauto.
        unfold MPState. rewrite H8. eauto.
      * unfold justRet.
        intros [Contra ?].
        eapply wplus_neq in Contra; eauto.
        omega.
      * unfold justRet.
        intros [Contra ?].
        unfold variantOf in Var.
        rewrite <- Var in Contra; eauto.
        eapply wplus_neq in Contra; eauto.
        omega.
      * erewrite <- PrefixUpToHead; eauto.
        unfold MPState. rewrite H8. simpl; eauto.
        intros k Hk.
        eapply H0.
        destruct Hk.
        -- left. intros Eq; symmetry in Eq; eauto.
        -- right. intros Eq; symmetry in Eq; eauto.
      * remember (Build_VSE (ms m) mv' mv' (makeContour cdm args (ms m)) (justRet (ms m))) as vse.
        replace mv' with (curr_variant vse); [ | subst; auto].

        assert (V: variantOf m' mv' (makeContour cdm args (ms m))).
        {
          eapply confStepPreservesVariant; eauto.
          intros k Hk.
          eapply H0.
          destruct Hk.
          -- left. intros Eq; symmetry in Eq; eauto.
          -- right. intros Eq; symmetry in Eq; eauto.
        } 
        
        assert (Safety: EagerStackSafetyTest cm cdm (S (length (VSEs_step vs'))) MPpre (vse :: VSEs_step vs')).
        { eapply PrefixUpTo_Safety; subst; simpl in*; eauto. }

        eapply TestImpliesConfidentialityNested; eauto.
        -- constructor; simpl; auto.
        -- simpl; eauto.
        -- eapply PrefixUpTo_Forall; subst; simpl; eauto.
        -- (* Well-formedness *)
           assert (wf: WellFormedVS m' (VSEs_step vs')).
           { eapply VSE_step_preserves_WellFormed in H4; eauto. }
           destruct wf as [Varwf [[vsewf [Lastwf Retwf]] [InM [InV [HRetwf HPubwf]]]]].

           repeat split.
           ++ constructor; eauto.
              ** subst; simpl. unfold MPState.
                 erewrite <-PrefixUpToHead; eauto.
                 rewrite H8. simpl. eauto.
              ** eapply Forall_forall.
                 intros.
                 eapply Forall_forall in Varwf.
                 unfold MPState.
                 erewrite <- PrefixUpToHead; eauto.
                 rewrite H8.
                 simpl.
                 eapply Varwf; eauto.
                 eauto.
           ++ exists vsewf.
              split; auto.
              constructor; auto.
           ++ erewrite <- PrefixUpToHead; eauto.
              unfold MPState. rewrite H8. simpl.
              constructor; subst; simpl; eauto.
              frob (MTraceOf (ms m)).
              rewrite MStep. simpl.
              apply In_later.
              frob (MTraceOf m').
              apply In_now.
           ++ subst; simpl; auto. 
              constructor; subst; simpl; eauto.
              frob (MTraceOf mv').
              apply In_now.
           ++ constructor; subst; simpl; eauto.
           ++ constructor; subst; simpl; eauto.              
        -- subst; simpl; eauto.
           erewrite <- PrefixUpToHead; eauto.
           unfold MPState. rewrite H8. simpl.
           auto.
        -- subst; simpl; auto.
  - exfalso; eapply H2; eauto.
  - apply PrefixUpTo_FirstStep in Pre.
    assert (Hyp: args0 = args) by (eapply isCall_inj; eauto); subst.
    destruct Pre as [MPpre [Eq Pre]].
    subst; simpl in *.
    auto.
    split.
    + eapply StackIntegrityIndEquiv.
      apply SI_notfinished; auto.
      * unfold EagerIntegrityTest in H6.
        intros k Hk.
        unfold EagerIntegrityTest in *.
        apply PrefixUpToHead in Pre.
        rewrite <- Pre.
        unfold MPState. (* lol *)
        rewrite H8; simpl.
        eapply H11; eauto.
      * remember (Build_VSE (ms m) (ms (head MP')) (ms (head MP')) (makeContour cdm args (ms m)) (justRet (ms m))) as vse.

        assert (Safety: EagerStackSafetyTest cm cdm (S (length (tl (VSEs_step vs')))) MPpre (vse :: tl (VSEs_step vs'))).
        { eapply PrefixUpTo_Safety; subst; simpl in*; eauto using variantOf_id. }

        eapply TestImpliesIntegrityNested; eauto.
        -- constructor; simpl; auto.
        -- simpl; eauto.
        -- subst; simpl; auto.
        -- eapply PrefixUpTo_Forall; subst; simpl; eauto.
    + extract_mpstep.
      eapply StrongConfImpliesConf.
      rewrite H8 in H15.
      intros mv Var; simpl in *.
      destruct (step mv) as [mv' OV] eqn:StepV.
      destruct (H10 mv mv' OV); eauto; subst.
      eapply StrongConfStep; eauto.
      * erewrite <- PrefixUpToHead; eauto.
        unfold MPState. rewrite H8. eauto.
      * unfold justRet.
        intros [Contra ?].
        eapply wplus_neq in Contra; eauto.
        omega.
      * unfold justRet.
        intros [Contra ?].
        unfold variantOf in Var.
        rewrite <- Var in Contra; eauto.
        eapply wplus_neq in Contra; eauto.
        omega.
      * erewrite <- PrefixUpToHead; eauto.
        unfold MPState. rewrite H8. simpl; eauto.
        intros k Hk.
        eapply H0.
        destruct Hk.
        -- left. intros Eq; symmetry in Eq; eauto.
        -- right. intros Eq; symmetry in Eq; eauto.
      * remember (Build_VSE (ms m) mv' mv' (makeContour cdm args (ms m)) (justRet (ms m))) as vse.
        replace mv' with (curr_variant vse); [ | subst; auto].

        assert (V: variantOf m' mv' (makeContour cdm args (ms m))).
        {
          eapply confStepPreservesVariant; eauto.
          intros k Hk.
          eapply H0.
          destruct Hk.
          -- left. intros Eq; symmetry in Eq; eauto.
          -- right. intros Eq; symmetry in Eq; eauto.
        } 
        
        assert (Safety: EagerStackSafetyTest cm cdm (S (length (tl (VSEs_step vs')))) MPpre (vse :: (tl (VSEs_step vs')))).
        { eapply PrefixUpTo_Safety; subst; simpl in*; eauto. }

        eapply TestImpliesConfidentialityNested; eauto.
        -- constructor; simpl; auto.
        -- simpl; eauto.
        -- eapply PrefixUpTo_Forall; subst; simpl; eauto.
        -- (* Well-formedness *)
           assert (wf: WellFormedVS m' (VSEs_step vs')).
           { eapply VSE_step_preserves_WellFormed in H4; eauto. }
           destruct wf as [Varwf [[vsewf [Lastwf Retwf]] [InM [InV [HRetwf HPubwf]]]]].

           repeat split.
           ++ constructor; eauto.
              ** subst; simpl. unfold MPState.
                 erewrite <-PrefixUpToHead; eauto.
                 rewrite H8. simpl. eauto.
              ** eapply Forall_forall.
                 intros.
                 inv Varwf.
                 { rewrite <- H9 in H. simpl in *. inv H. }
                 eapply Forall_forall in H12.
                 unfold MPState.
                 erewrite <- PrefixUpToHead; eauto.
                 rewrite H8.
                 simpl.
                 eapply H12; eauto.
                 rewrite <- H7 in H.
                 simpl in *. eauto.
           ++ exists vsewf.
              split; auto.
              constructor; auto.
              inv Lastwf.
              ** exfalso.
                 unfold VSEs_step in H9.
                 destruct vs'; simpl in *; inv H9.
                 destruct vs'; simpl in *; inv H12.
                 destruct H2 as [vse' [vsrest' [Eq' [Ret' [Len' NotR']]]]].
                 inv Eq'.
                 unfold VSE_step, upd_curr in Retwf.
                 destruct (step (curr_variant vse')); simpl in *.
                 rewrite Retwf in Ret'.
                 inv Ret'.
              ** simpl; auto.
           ++ erewrite <- PrefixUpToHead; eauto.
              unfold MPState. rewrite H8. simpl.
              constructor; subst; simpl; eauto.
              ** frob (MTraceOf (ms m)).
                 rewrite MStep. simpl.
                 apply In_later.
                 frob (MTraceOf m').
                 apply In_now.
              ** inv InM; simpl; auto.
           ++ subst; simpl; auto. 
              constructor; subst; simpl; eauto.
              ** frob (MTraceOf mv').
                 apply In_now.
              ** inv InV; simpl; auto.
           ++ constructor; subst; simpl; eauto.
              inv HRetwf; simpl; eauto.
           ++ constructor; subst; simpl; eauto.              
              inv HPubwf; simpl; eauto.
        -- subst; simpl; eauto.
           erewrite <- PrefixUpToHead; eauto.
           unfold MPState. rewrite H8. simpl.
           auto.
        -- subst; simpl; auto.
Qed.

Definition EagerStackSafetyTest'' pm :=
  forall m p,
    let '(cm,rm,em,cdm) := pm in
    let initC := makeContour cdm 0 m in
    let MP := MPTraceOf (m,p) in
    initPolicyState m pm = Some p ->
    forall mv, variantOf m mv initC ->
               let initvse := {| init_machine := m
                                 ; init_variant := mv 
                                 ; curr_variant := mv
                                 ; contour := initC
                                 ; retP := fun _ => False
                              |} in
               EagerStackSafetyTest cm cdm 1 MP [initvse].

Lemma False_Forall :
  forall {A} (T : TraceOf A), ForallButLast (fun _ => ~ False) T.
Proof.  
  cofix COFIX.
  intros.
  destruct T; constructor; eauto.
Qed.
    

Theorem StackSafetyTestImpliesStackSafety :
  forall pm m,
  EagerStackSafetyTest'' pm ->
  EagerStackSafetyOldWrap pm m.
Proof.
  intros pm m Safety. destruct pm as [[[cm rm] em] cdm].
  unfold EagerStackSafetyTest'' in *.
  unfold EagerStackSafetyOldWrap in *.
  unfold EagerStackSafetyOld.
  split; [|split].
  - eapply StackIntegrityIndEquiv.
    eapply TestImpliesIntegrityNested; simpl; eauto using variantOf_id.
    + constructor; auto.
    + simpl; eauto.
    + simpl; eauto.
    + simpl; eauto.
      eapply False_Forall.
  - eapply StrongConfImpliesConf.
    intros mv Var.
    remember (Build_VSE m mv mv (makeContour cdm 0 m) (fun _ => False)) as vse.
    replace mv with (curr_variant vse); [|subst; auto].
    eapply TestImpliesConfidentialityNested with (vs := [vse]); subst; simpl in *; eauto.
    + constructor; eauto.
    + simpl; eauto.
    + eapply False_Forall.
    + repeat split.
      * constructor; subst; simpl in *.
        -- destruct (pstep (m, p)); simpl in *; auto.
        -- constructor.
      * eexists; split; eauto.
        -- constructor.
        -- simpl; auto.
      * constructor; subst; simpl in *.
        -- destruct (pstep (m, p)); simpl in *; auto;
           frob (MTraceOf m); apply In_now.
        -- constructor.
      * constructor; subst; simpl in *.
        -- frob (MTraceOf mv); apply In_now.
        -- constructor.
      * constructor.
        -- right. intros; auto.
        -- constructor.
      * constructor.
        -- simpl.
           unfold makeContour, publicRegisters.
           intros; auto.
        -- constructor.
    + simpl; eapply Safety;
      destruct (pstep (m, p)); simpl in *; auto.
  - intros. eapply TestImpliesSafetyCall; eauto using variantOf_id.
Qed.
        
(* ********* SNA Beware : Lazy Properties ********* *)

(* Since eager property protects everything that is HI,
   an integrity rollback restores all HI components. *)
Definition RollbackInt (C: Contour) (Mstart Mend : MachineState) : MachineState :=
  fun k => match integrityOf (C k) with
           | HI => Mstart k
           | _ => Mend k
           end.

Definition LazyReturnMP (justReturned : MachineState -> Prop) (MP MPpre : MPTrace) (MPsuffO : option MPTrace) :=
  (exists MPsuff, MPsuffO = Some MPsuff /\ SplitInclusive (fun mp => justReturned (ms mp)) MP MPpre MPsuff)
  \/ (ForallTrace (fun mp => ~ (justReturned (ms mp))) MP /\ TraceEq MP MPpre /\ MPsuffO = None).

Definition LazyReturnM (justReturned : MachineState -> Prop) (M Mpre : MTrace) (MsuffO : option MTrace) :=
  (exists Msuff, MsuffO = Some Msuff /\ SplitInclusive justReturned M Mpre Msuff)
  \/ (ForallTrace (fun m => ~ (justReturned m)) M /\ TraceEq M Mpre /\ MsuffO = None).

(* Observable properties take a contour and a trace, with an optional additional trace.
   The contour C represents the security levels for trace MM, and MMOouter is the
   execution following after MM when C no longer applies. *)
Definition ObservableIntegrityOld (C:Contour) (MP:MPTrace) (MPsuffO:option MPTrace) : Prop :=
 match MPsuffO with
 | Some actual =>
   let ideal := MTraceOf (RollbackInt C (ms (head MP)) (ms (head actual))) in
   ((exists mpfin, Last actual mpfin) -> (ObsTraceOf actual) <=_O (ObsTraceOfM ideal)) /\
   ((forall mp, ~ Last actual mp) -> ObsTraceEq (ObsTraceOf actual) (ObsTraceOfM ideal))
 | None => True
 end.

Definition ObservableIntegrity (C:Contour) (mp:MPState) (justReturned:MachineState -> Prop) : Prop :=
  forall MPpre MPsuff,
    SplitInclusive (fun mp => justReturned (ms mp)) (MPTraceOf mp) MPpre MPsuff ->
    let m' := RollbackInt C (ms mp) (ms (head MPsuff)) in
    ObsEqUpToHalt (MPRunOf (head MPsuff)) (RunOf m').

(* A confidentiality rollback aims to undo a variation, so it restores the values of the
   original, unvaried state. But if the varied values were overwritten after they were varied,
   the changes should be kept. Otherwise we are building in some integrity. *)
Definition RollbackConf (Mstart Mend M'start M'end : MachineState) : MachineState :=
  fun k => if weq (Mstart k) (Mend k) && weq (M'start k) (M'end k) && negb (weq (Mstart k) (M'start k))
           then Mstart k
           else M'end k.

(* MP is a callee's trace that terminates when/if control has just returned to the caller
   according to justReturned. MPsuffO is the trace of the caller starting when control has
   just returned to it, or None if MP does not return, either due to nontermination or
   because it is cut short by a monitor fault.
   In a top level trace justReturned will never hold. *)
Definition ObservableConfidentialityOld (C : Contour) (MP:MPTrace) (MPsuffO:option MPTrace)
           (justReturned : MachineState -> Prop) :=
  forall m' M' M'suffO,
    (* If m' is a variant of the initial state of MP... *)
    variantOf (ms (head MP)) m' C ->
    (* If the trace from m' return control to the caller at some state,
       M'pre is its prefix up to and including that state,
       and M'suffO is the (non-empty) trace of the caller starting at that state
       (with the caller's memory still varied.)
       If the trace from m' does not return control, M'pre is the whole
       trace and M'suffO is None. *)
    LazyReturnM justReturned (MTraceOf m') M' M'suffO ->

    let O := (ObsTraceOf MP)^(option_map ObsTraceOf MPsuffO) in
    (* Here are the three cases from EagerConf: *)

    (* 1. The callee ends successfully with a return. *)
    (forall MPsuff,
        MPsuffO = Some MPsuff ->
       (* Previously: forall mpret, Last MP mpret ->
                      justReturned (ms mpret) -> 
          But these should fall out of LazyReturnMP *)

        (* Then M'pre also terminates in some state, which is at the head of M'suff.
           And we rollback the head of M'suff to undo the variation and get its trace. *)
        (exists M'suff M'roll,
              M'suffO = Some M'suff /\
              M'roll = MTraceOf (RollbackConf (ms (head MP)) (ms (head MPsuff)) m' (head M'suff)) /\
              let O' := (ObsTraceOfM M') ^ Some (ObsTraceOfM M'roll) in
              (* Two sub-cases: either MPsuffO is an infinite trace,
                 or it stops short due to the monitor. In the first
                 case it should produce the same observation trace as M'suff,
                 in the latter a prefix. *)
              ((exists mpfin, Last MPsuff mpfin) -> O <=_O O') /\
              (* Above exists is superfluous, but demonstrates that these are disjoint cases *)
              ((forall mpfin, ~(Last MPsuff mpfin)) -> ObsTraceEq O O'))) /\

    (* 2. The callee is cut short by a monitor fault. *)
    (forall mpret, Last MP mpret -> (* mpstep mpret = None -> *)
                   ~ justReturned (ms mpret) ->
     (* Then: 
        - The observations of the MP trace are a prefix of the 
          observations of M'.
      *)
     (ObsTraceOf MP) <=_O (ObsTraceOfM M')) /\
    
    (* 3. The callee trace never returns. *) 
    ((forall mpret, ~ Last MP mpret) ->
     (* Then: 
        - The variant trace never returns.
        - The observations of MP and M' are the same. 
      *)
     forall mret', ~ Last M' mret' /\
                   ObsTraceEq (ObsTraceOf MP) (ObsTraceOfM M')).

Definition ObservableConfidentiality (C : Contour) (mp:MPState) (justReturned : MachineState -> Prop) : Prop :=
  forall m' callMPO call'MO,
    variantOf (ms mp) m' C ->
    RunUpTo (fun mp => justReturned (ms mp)) (MPRunOf mp) callMPO ->
    RunUpTo (fun m => justReturned m) (RunOf m') call'MO ->
    (forall mpret (o:Observation),
        Last callMPO (mpret, o) ->
        (exists m'ret (o':Observation), Last call'MO (m'ret,o') /\
                          let m'roll := RollbackConf (ms mp) (ms mpret) m' m'ret in
                          ObsOfMP callMPO ~=_O ObsOfM call'MO /\
                          ObsOfMP (MPRunOf mpret) <=_O ObsOfM (RunOf m'roll))) /\
    (Infinite callMPO -> Infinite call'MO /\ ObsOfMP callMPO ~=_O ObsOfM call'MO) /\
    (forall mpohalt,
        Last callMPO mpohalt ->
        ~ justReturned (ms (fst mpohalt)) ->
        ObsOfMP callMPO <=_O ObsOfM call'MO).

Definition LazyStackSafetyOld (cm : CallMap) (cdm : CodeMap) (MP:MPTrace) : Prop :=
    ObservableConfidentialityOld (makeContour cdm 0 (ms (head MP))) MP None (fun _ => False) /\
    (forall MPcall MPpre C' MPsuffO,
        FindCallMP cm cdm MP C' MPcall ->
        LazyReturnMP (fun m => justRet (ms (head MPcall)) m) MPcall MPpre MPsuffO ->
        ObservableIntegrityOld C' MPpre MPsuffO /\
        ObservableConfidentialityOld C' MPpre MPsuffO (justRet (ms (head MPcall)))).

Definition LazyStackSafety cm rm em cdm : Prop :=
  forall m p,
    let pm := (cm,rm,em,cdm) in
    let initC := makeContour cdm 0 m in
    initPolicyState m (cm,rm,em,cdm) = Some p ->
    ObservableConfidentiality initC (m,p) (fun _ => False) /\
    (forall mp C,
      FindCallMP cm cdm (MPTraceOf (m,p)) C (MPTraceOf mp) ->
      ObservableIntegrity C mp (justRet (ms mp)) /\
      ObservableConfidentiality C mp (justRet (ms mp))).

(* More conjectural stuff follows. *)

(* This is meant to rollback in all of the cases that either an integrity or a confidentiality
   rollback would. If a component is HI, it should always be rolled back; if HC but LI, it
   should be rolled back only if it kept the value of its variant. *)
(*Definition RollbackCI (C: Contour) (Mstart Nstart Nend : MachineState) : MachineState :=
  RollbackInt C Mstart (RollbackConf Mstart Nstart Nend).

Definition ObservableConfidentegrity (C:Contour) (MP:MPTrace) (MPsuffO:option MPTrace) (isRet:MachineState -> Prop) :=
  forall n N NO,
    variantOf (ms (head MP)) n C ->
    TraceSpan (fun n' => ~ isRet n') (MTraceOf n) N NO ->
    let actual := MP ^ MPsuffO in
    let ideal := N ^ (option_map (fun N' => MTraceOf (RollbackCI C (ms (head MP)) n (head N'))) NO) in
    (ObsTraceOf actual) <=_O (ObsTraceOfM ideal).

Definition LazyStackSafety' (cm : CallMap) (MP:MPTrace) : Prop :=
  ObservableConfidentegrity (makeContour 0 (ms (head MP))) MP None (fun _ => False) /\
  (forall MP' MP'' C' MPsuffO, FindCall cm (mapTrace ms MP) C' (mapTrace ms MP') ->
                          TraceSpan (fun mp => ~isRet (ms (head MP')) (ms mp)) MP' MP'' MPsuffO ->
                          ObservableConfidentegrity C' MP'' MPsuffO (isRet (ms (head MP'')))).    *)

Lemma MTraceOfHead :
  forall m,
    head (MTraceOf m) = m.
Proof.
  intros. rewrite (idTrace_eq (MTraceOf m)). simpl. auto.
Qed.

Lemma MapTraceHead :
  forall MP,
    head (mapTrace ms MP) = ms (head MP).
Proof.
  intros. destruct MP; simpl; auto.
Qed.

(* APT: I thought some of these might be approachable if we change to this
definition but I couldn't actually make any of the proofs go through. *)
(* Definition RealMPTrace' (MP:MPTrace) : Prop := 
  TraceEq MP (MPTraceOf (head MP)).*)

CoInductive RealMPTrace'(*_gen R*) : MPState -> MPTrace -> Prop :=
| RMP0 : forall mp, pstep mp = None -> RealMPTrace'(*_gen R*) mp (finished mp)
| RMP1 : forall mp MP p', pstep mp = Some p' ->
                       (*R*)RealMPTrace' (fst (step (ms mp)), p') MP ->
                       RealMPTrace'(*_gen R*) mp (notfinished mp MP).
Hint Constructors RealMPTrace'(*_gen*) : core.

(* Definition RealMPTrace' (mp : MPState) (MP : MPTrace) := *)
(*   paco2 RealMPTrace'_gen bot2 mp MP. *)
(* Hint Unfold RealMPTrace' : core. *)
(* Lemma RealMPTrace'_mon : monotone2 RealMPTrace'_gen. Proof. pmonauto. Qed. *)
(* Hint Resolve RealMPTrace'_mon : paco. *)


Definition RealMPTrace'' MP := TraceEq MP (MPTraceOf (head MP)).

(* Ltac inv H := (pinversion H || inversion H); subst; clear H. *)

Lemma RealMPTrace'Same : forall m MP, RealMPTrace' m MP ->
                                    TraceEq MP (MPTraceOf m).
Proof.
 cofix COFIX.
 intros m mp H(*; pfold*).
 inv H.
 - rewrite idTrace_eq; simpl.
   rewrite H0.
   constructor.
 - rewrite idTrace_eq; simpl.
   rewrite H0.
   constructor.
   (*right.*) eapply COFIX; eauto.
Qed.

Lemma RealMPTrace'Eq : forall m MP,
    RealMPTrace' m MP ->
    forall MP1,
      TraceEq MP MP1 ->
      RealMPTrace' m MP1. 
Proof.
  cofix COFIX.
  intros m MP H MP1 H0(*; pfold*).
  inv H.
  - destruct MP1. 
    + inv H0. constructor; auto.
    + inv H0.
  - destruct MP1.       
    + inv H0. 
    + inv H0. 
      econstructor; eauto.
Qed.

Lemma RealMPTrace''Same : forall MP, RealMPTrace'' MP -> RealMPTrace' (head MP) MP. 
Proof.
  unfold RealMPTrace''.
  intro MP.
  remember (head MP) as m0.
  generalize dependent m0.
  generalize dependent MP.
  cofix COFIX.
  intros MP m0 Heqm0 H(*; pfold*).
  rewrite idTrace_eq in H. simpl in H.
  destruct MP as [m | m MP'] eqn:?.
  - destruct (pstep m0) eqn:?.
    + inversion H.
    + subst m0. constructor; auto.
  - destruct (pstep m0) eqn:?.
    + inv H.
      econstructor; eauto.
      simpl.
      set (mp' := (fst (step (ms m)), p)).
      simpl in *. 
      (*right.*) apply COFIX.
      * erewrite TraceEqHead.
        apply MPTraceOfHead. auto.
      * auto.
    + inversion H.
Qed.

Lemma RealMPEquiv : forall MP, RealMPTrace'' MP <-> RealMPTrace' (head MP) MP.
Proof.
  split; intros.
  - apply RealMPTrace''Same; auto.
  -  apply RealMPTrace'Same; auto.
Qed.

Lemma SplitSuffixReal' :
  forall P MP1 MP2 MP3,
    SplitInclusive P MP1 MP2 MP3 ->
    RealMPTrace' (head MP1) MP1 ->
    RealMPTrace' (head MP3) MP3.
Proof.
  induction 1; intros; auto. 
  apply IHSplitInclusive.
  (* pfold. *)
  simpl in H1.
  inv H1.
  inv H5; econstructor; eauto.
Qed.  

Lemma RealTail' :
  forall mp MP,
    RealMPTrace' mp (notfinished mp MP) ->
    RealMPTrace' (head MP) MP.  
Proof.
  intros mp MP H(*; pfold*).
  inv H.
  destruct MP. 
  - simpl. inv H3. constructor. auto.
  - simpl. inv H3.
    econstructor.  eauto.
    auto.
Qed.

Lemma MPTracePrefixMTrace :
  forall mp m,
     ms mp = m -> 
     ObsTraceOf (MPTraceOf mp) <=_O ObsTraceOfM (MTraceOf m).
Proof.
  cofix COFIX.
  intros mp m H(*; pfold*).
  destruct mp. simpl in *.  subst.
  rewrite idTrace_eq. pattern (ObsTraceOfM (MTraceOf m)) at 1.  rewrite idTrace_eq.  simpl.
  destruct (pstep (m,p)); simpl.
  - destruct (step m).  simpl.
    destruct o. 
    * constructor. (*right.*) apply COFIX. auto.
    * constructor. (*left. pfold.*) constructor. (*right.*) apply COFIX. auto.
  - destruct (step m). simpl.
    constructor.
Qed.

Lemma MTraceEqInfMPTrace :
  forall mp m,
    ms mp = m ->
    (forall mpfin, ~ (Last (MPTraceOf mp) mpfin)) ->
    ObsTraceEq (ObsTraceOf (MPTraceOf mp)) (ObsTraceOfM (MTraceOf m)).
Proof.
  cofix COFIX.
  intros mp m H H0(*; pfold*).
  destruct mp. simpl in *. subst.
  rewrite idTrace_eq. rewrite (idTrace_eq (ObsTraceOf (MPTraceOf (m,p)))).  simpl.
  destruct (pstep (m,p)) eqn:?; simpl.
  - destruct (step m) eqn:?.  simpl.
    assert (Q: forall mpfin : MPState, ~ Last (MPTraceOf (m0, p0)) mpfin).
    { intros. intro.
      apply (H0 mpfin).
      rewrite (idTrace_eq (MPTraceOf (m,p))). simpl.
      rewrite Heqo. rewrite Heqp1.  simpl.
      constructor.  auto. }
    destruct o.
    + constructor. (*right.*) apply COFIX; auto.
    + constructor. (*left. pfold.*) constructor. (*right.*) apply COFIX; auto.
  - exfalso. eapply (H0 (m,p)).
    rewrite (idTrace_eq (MPTraceOf (m,p))).  simpl.
    rewrite Heqo.
    constructor.
Qed.

Lemma MPObsLast :
  forall MP mp,
    Last MP mp ->
    Last (ObsTraceOf MP) Tau.
Proof.
  intros. induction H.
  - rewrite (idTrace_eq (ObsTraceOf (finished a))). unfold ObsTraceOf. simpl. constructor.
  - destruct T.
    + rewrite (idTrace_eq (ObsTraceOf (notfinished a' (finished m)))). unfold ObsTraceOf. simpl.
      destruct (step (ms a')). constructor. auto.
    + rewrite (idTrace_eq (ObsTraceOf (notfinished a' (notfinished m T)))). unfold ObsTraceOf. simpl.
      destruct (step (ms a')). constructor. auto.
Qed.

Lemma MObsLast :
  forall M m,
    Last M m ->
    Last (ObsTraceOfM M) Tau.
Proof.
  intros. induction H.
  - rewrite (idTrace_eq (ObsTraceOfM (finished a))). unfold ObsTraceOfM. simpl. constructor.
  - destruct T.
    + rewrite (idTrace_eq (ObsTraceOfM (notfinished a' (finished m)))). unfold ObsTraceOfM. simpl.
      destruct (step a'). constructor. auto.
    + rewrite (idTrace_eq (ObsTraceOfM (notfinished a' (notfinished m T)))). unfold ObsTraceOfM. simpl.
      destruct (step a'). constructor. auto.
Qed.


Lemma ObsTraceOfTraceEq :
  forall MP MP',
    MP ~= MP' ->
    (ObsTraceOf MP) ~= (ObsTraceOf MP').
Proof.
  cofix COFIX. intros MP MP' H(*; pfold*). inv H.
  - rewrite (idTrace_eq (ObsTraceOf (finished a))).
    unfold ObsTraceOf. simpl. constructor.
  - rewrite (idTrace_eq (ObsTraceOf (notfinished a T1))).
    rewrite (idTrace_eq (ObsTraceOf (notfinished a T2))).
    destruct a. unfold ObsTraceOf. simpl.
    destruct (step m) eqn:?.
    constructor. (*right.*) apply COFIX. auto.
Qed.

Lemma FindCallReal :
  forall cdm C MP C' MPcall,
    RealMPTrace'' MP ->
    FindCallMP cdm C MP C' MPcall  ->
    RealMPTrace'' MPcall.
Proof.
  intros. induction H0.
  - apply SplitSuffixReal' in H0; apply RealMPEquiv; auto.
  - apply IHFindCallMP1 in H. rewrite H0 in H. apply RealMPEquiv in H. apply RealTail' in H.
    apply IHFindCallMP2; auto. apply RealMPEquiv. auto.
Qed.

Lemma EagerImpliesLazyIntOld :
  forall C MPcall MPpre MPsuffO,
    RealMPTrace'' MPcall ->
    LazyReturnMP (fun m => justRet (ms (head MPcall)) m) MPcall MPpre MPsuffO ->
    EagerStackIntegrityThru C MPpre ->
    ObservableIntegrityOld C MPpre MPsuffO.
Proof.
  unfold EagerStackIntegrityThru. unfold ObservableIntegrityOld. intros.
  destruct MPsuffO as [MPsuff |] eqn:E; auto.
  assert (HSplit : SplitInclusive (fun mp => justRet (ms (head MPcall)) (ms mp)) MPcall MPpre MPsuff).
  { unfold LazyReturnMP in H0. destruct H0.
    - destruct H0 as [MPsuffAgain]. destruct H0. inversion H0. eauto.
    - destruct H0. destruct H2. discriminate. }
  assert (InTrace (head MPsuff) MPpre).
  {  apply SplitInclusiveIsInclusive in HSplit. apply LastInTrace in HSplit. auto. }
  assert (forall k, integrityOf (C k) = HI -> (ms (head MPpre)) k = (ms (head MPsuff)) k).
  { intros. apply H1; auto. }
  assert (RollbackInt C (ms (head MPpre)) (ms (head MPsuff)) = (ms (head MPsuff))).
  { unfold RollbackInt. extensionality k. destruct (integrityOf (C k)) eqn:E2.
    - apply H3; auto.
    - auto. }
  rewrite H4. assert (RealMPTrace'' MPsuff).
  { apply RealMPEquiv. apply RealMPEquiv in H.
    apply (SplitSuffixReal' (fun mp => justRet (ms (head MPcall)) (ms mp)) MPcall MPpre MPsuff); auto. }
  pose (mp := head MPsuff). unfold RealMPTrace'' in H5.
  replace (head MPsuff) with mp; auto. replace (head MPsuff) with mp in H5; auto.
  assert (ObsTraceEq (ObsTraceOf MPsuff) (ObsTraceOf (MPTraceOf mp))).
  { apply ObsTraceOfTraceEq in H5. apply TraceEqImpliesObsTraceEq. auto. }
  split.
  - intros. apply (ObsPrefOverEq (ObsTraceOf (MPTraceOf mp)) (ObsTraceOf MPsuff)).
    + apply ObsTraceOfTraceEq. apply TraceEqSym. auto.
    + apply (MPTracePrefixMTrace mp (ms mp) (* mpfin*)). auto.
  - intros. auto.
    apply (ObsEqOverEq (ObsTraceOf (MPTraceOf mp)) (ObsTraceOf MPsuff) (ObsTraceOfM (MTraceOf (ms mp)))).
    + apply ObsTraceOfTraceEq. symmetry. auto.
    + apply MTraceEqInfMPTrace; auto. unfold not. intros. 
      specialize H7 with mpfin. apply TraceEqSym in H5.
      apply (LastTraceEq (MPTraceOf mp) MPsuff) in H8; auto.
Qed.

Lemma EagerImpliesLazyInt :
  forall C mp justReturned,
    EagerStackIntegrityEnd C mp justReturned ->
    ObservableIntegrity C mp justReturned.
Proof.
  unfold EagerStackIntegrityEnd. unfold ObservableIntegrity. intros C mp justReturned H MPpre MPsuff HSplit.
  assert (forall k, integrityOf (C k) = HI -> (ms mp) k = (ms (head MPsuff)) k).
  { intros. specialize H with MPpre (head MPsuff) k. apply H; auto.
    - unfold PrefixUpTo. left. exists MPsuff. auto.
    - apply SplitInclusiveIsInclusive in HSplit. auto. }
  assert (RollbackInt C (ms mp) (ms (head MPsuff)) = (ms (head MPsuff))).
  { unfold RollbackInt. extensionality k. destruct (integrityOf (C k)) eqn:E2.
    - apply H0; auto.
    - auto. }
  rewrite H1.
  pose (mp' := head MPsuff). assert (RealMPTrace'' MPsuff).
  { apply RealMPEquiv.
    apply (SplitSuffixReal' (fun mp => justReturned (ms mp)) (MPTraceOf mp) MPpre MPsuff); auto.
    apply RealMPEquiv. unfold RealMPTrace''. rewrite <- (MPTraceOfHead mp). apply TraceEqRefl. }
  split.
  - apply MPRunPrefRun; auto.
  - apply RunEqInfMPRun; auto.
Qed.

(*
    apply (ObsPrefOverEq (ObsTraceOf (MPTraceOf mp')) (ObsTraceOf MPsuff)).
    + apply ObsTraceOfTraceEq. apply TraceEqSym. apply H2.
    + apply (MPTracePrefixMTrace mp' (ms (head MPsuff)) (* mpfin*)). auto.
  - intros. auto.
    apply (ObsEqOverEq (ObsTraceOf (MPTraceOf mp')) (ObsTraceOf MPsuff)).
    + apply ObsTraceOfTraceEq. symmetry. auto.
    + apply MTraceEqInfMPTrace; auto. unfold not. intros. 
      apply TraceEqSym in H2.
      apply (LastTraceEq (MPTraceOf mp') MPsuff) in H4.
      * unfold infinite in H3; apply H3 in H4; auto.
      * apply H2; auto.
Qed. *)

Lemma EagerImpliesLazyConfOld :
  forall C MPcall MPpre MPsuffO justReturned,
    RealMPTrace'' MPcall ->
    LazyReturnMP justReturned MPcall MPpre MPsuffO ->
    EagerStackConfidentialityOld C MPpre justReturned ->
    ObservableConfidentialityOld C MPpre MPsuffO justReturned.
Proof.
  unfold EagerStackConfidentialityOld. unfold ObservableConfidentialityOld. intros. split;try split.

  - (* this is case 1 *)
    intros. destruct H0.
    2: { destruct H0. destruct H5. rewrite H6 in H4. discriminate. }
    destruct H0 as [MPsuffAgain]. destruct H0 as [H0 HSplit].
    assert (MPsuffAgain = MPsuff). { rewrite H0 in H4; inversion H4; auto. }
    specialize H1 with m' M'.
    (* so assert right off the bat that M' returns *)
    
    assert (HM'sEx : exists M'suff, M'suffO = Some M'suff /\ SplitInclusive justReturned (MTraceOf m') M' M'suff).
    { destruct H3.
      - auto.
      - destruct H1; auto.
        + right. destruct H3. destruct H3. split; auto.
        + specialize H1 with (head MPsuff).
          destruct H1.
          * apply SplitInclusiveIsInclusive in HSplit. rewrite H5 in HSplit. auto.
          * apply SplitInclusiveProp in HSplit. rewrite H5 in HSplit. auto.
          * destruct H1 as [mret']. destruct H1. destruct H3. destruct H9.
            apply TraceEqSym in H9.
            eapply LastTraceEq in H1; eauto.
            destruct H6. apply MTraceOfInf in H1. contradiction. }

    destruct HM'sEx as [M'suff HM'sEx]. destruct HM'sEx as [HM'sEx Hsplit'].
    destruct H1;auto.
    + left. exists M'suff. auto.
    + specialize H1 with (head MPsuff).
      * rewrite H5 in HSplit.
        assert (HSplit2 := HSplit). assert (HSplit3 := HSplit).
        apply (SplitInclusiveIsInclusive (fun mp => justReturned (ms mp))) in HSplit2.
        apply SplitInclusiveProp in HSplit. rewrite H0 in H4.
        destruct H1; auto.
        pose (M'roll := MTraceOf (RollbackConf (ms (head MPpre)) (ms (head MPsuff)) m' (head M'suff))).
        exists M'suff. exists M'roll. destruct H1 as [mret'].
        assert (HHeadsEq: ms (head MPsuff) = head M'roll).
        { unfold M'roll. simpl. extensionality k.
          destruct H1 as [Hmret Hksame]. assert (mret' = head M'suff).
          { apply SplitInclusiveIsInclusive in Hsplit'.
            apply (LastUnique mret' (head M'suff) M'); auto. }
          assert (head M' = m').
          { apply SplitInclusiveHead in Hsplit'. rewrite <- Hsplit'. simpl. auto. }
          specialize Hksame with k. rewrite H1 in Hksame. unfold RollbackConf.
          destruct (weq (ms (head MPpre) k) (ms (head MPsuff) k)) eqn:Unchanged; simpl.
          - destruct (weq (m' k) ((head M'suff) k)) eqn:Unchanged'; simpl.
            + destruct (weq (ms (head MPpre) k) (m' k)) eqn:Unvaried; simpl.
              * apply weq_implies_eq in Unchanged.
                apply weq_implies_eq in Unchanged'.
                apply weq_implies_eq in Unvaried.
                rewrite <- Unchanged.
                rewrite Unvaried. auto.
              * apply weq_implies_eq in Unchanged. apply eq_sym. auto.
            + apply not_weq_implies_neq in Unchanged'.
              apply Hksame. right. rewrite H8. auto.
          - apply not_weq_implies_neq in Unchanged.
            apply Hksame. left. auto. }
        assert (HRealsuff : RealMPTrace'' MPsuff).
        { apply RealMPEquiv.
          apply (SplitSuffixReal' (fun mp => justReturned (ms mp)) MPcall MPpre MPsuff); auto.
          apply RealMPEquiv. auto. }
        split; auto. split; auto. rewrite H0. simpl.
        rewrite H5. assert (Last (ObsTraceOf MPpre) Tau).
        { apply (MPObsLast MPpre (head MPsuff)). auto. }
        assert (Last (ObsTraceOfM M') Tau).
        { apply (MObsLast M' (head M'suff)). apply SplitInclusiveIsInclusive in Hsplit'. auto. }
        split.
        -- intro Hfin. destruct Hfin as [mpfin Hfin].          
           apply (MPTracePrefixMTrace (head MPsuff) (head M'roll) (* mpfin *)) in HHeadsEq.
           eapply ObsTracePrefApp'; eauto.
           { apply ObsTraceEq_sym. auto. }
           { apply (ObsPrefOverEq (ObsTraceOf (MPTraceOf (head MPsuff)))
                                   (ObsTraceOf MPsuff)
                                   (ObsTraceOfM (MTraceOf (head M'roll)))).
             - apply ObsTraceOfTraceEq. apply TraceEqSym. apply HRealsuff.
             - auto. }
        -- intros. apply (MTraceEqInfMPTrace (head MPsuff) (head M'roll)) in HHeadsEq.
           { eapply ObsTraceEqApp; eauto.
              apply (ObsEqOverEq (ObsTraceOf (MPTraceOf (head MPsuff)))
                                 (ObsTraceOf MPsuff)
                                 (ObsTraceOfM (MTraceOf (head M'roll)))).
             - apply ObsTraceOfTraceEq. apply TraceEqSym. apply HRealsuff.
             - auto. }
           unfold not. intros. specialize H10 with mpfin.
           apply (LastTraceEq (MPTraceOf (head MPsuff)) MPsuff) in H11; auto.
           apply TraceEqSym. apply HRealsuff.
  - (* Case 2: MPcall stops short *)
    intros. specialize H1 with m' M'. destruct H1; auto.
    + destruct H3.
      * left. destruct H1 as [MPsuff]. exists MPsuff. destruct H1. auto.
      * right. destruct H1. destruct H3. split;auto.
    + destruct H6. specialize H6 with mpret. apply H6; auto.
  - (* Case 3: MPcall diverges *)
      intros. specialize H1 with m' M'. destruct H1; auto.
      + destruct H3.
        * left. destruct H1 as [Msuff]. destruct H1. eauto.
        * right. destruct H1. destruct H3. split; auto.
      + destruct H5. apply H6; auto.
Qed.

Lemma EagerImpliesLazyConf :
  forall C mp justReturned,
    EagerStackConfidentiality C mp justReturned ->
    ObservableConfidentiality C mp justReturned.
Proof.
  unfold EagerStackConfidentiality. unfold ObservableConfidentiality. intros. split.

  - (* this is case 1 *)
    intros. specialize H with m' callMPO call'MO. destruct H; auto.
    specialize H with mpret o. destruct H as [m'ret]; auto.
    destruct H as [o']. exists m'ret. exists o'.
    destruct H. split; auto. destruct H5 as [HTracesEq HSame].
    pose (m'roll := (RollbackConf (ms mp) (ms mpret) m' m'ret)).
    replace (RollbackConf (ms mp) (ms mpret) m' m'ret) with m'roll; auto.
    assert (HRetsEq: ms mpret = m'roll).
    { unfold m'roll. simpl. extensionality k. specialize HSame with k.
      unfold RollbackConf.
      destruct (weq (ms mp k) (ms mpret k)) eqn:Unchanged; simpl.
      - destruct (weq (m' k) (m'ret k)) eqn:Unchanged'; simpl.
        + destruct (weq (ms mp k) (m' k)) eqn:Unvaried; simpl.
          * apply weq_implies_eq in Unchanged.
            apply weq_implies_eq in Unchanged'.
            apply weq_implies_eq in Unvaried.
            rewrite <- Unchanged.
            rewrite Unvaried. auto.
          * apply weq_implies_eq in Unchanged. apply eq_sym. auto.
        + apply not_weq_implies_neq in Unchanged'.
          apply HSame. right. auto.
          - apply not_weq_implies_neq in Unchanged.
            apply HSame. left. auto. }
    rewrite <- HRetsEq. split; auto.
    apply MPRunPrefRun; auto.
  - (* Cases 2 and 3 are identical *)
    specialize H with m' callMPO call'MO. destruct H; auto.
Qed.

Theorem EagerSafetyImpliesLazy:
  forall cm rm em cdm,
    EagerStackSafety cm rm em cdm -> LazyStackSafety cm rm em cdm.
Proof.
  unfold EagerStackSafety. unfold LazyStackSafety. intros.
  specialize H with m p.
  pose (pm := (cm,rm,em,cdm)).
  destruct H; auto. split.
  - apply (EagerImpliesLazyConf (makeContour cdm 0 m) (m,p)). auto.
  - intros. specialize H1 with mp C. apply H1 in H2. destruct H2. split.
    + apply EagerImpliesLazyInt; auto.
    + apply EagerImpliesLazyConf; auto.
Qed.

(*Theorem EagerSafetyImpliesLazy:
  forall cm MP,
    RealMPTrace'' MP ->
    EagerStackSafety cm MP (makeContour 0 (ms (head MP))) -> LazyStackSafety cm MP.
Proof.
  unfold EagerStackSafety. unfold LazyStackSafety. intros. split.
  - destruct H0. apply (EagerImpliesLazyConf (makeContour 0 (ms (head MP))) MP).
    + auto.
    + right. split;try split; auto.
      * apply ForallTraceTautology. unfold not. intros. contradiction.
      * apply TraceEqRefl.
    + destruct H1. auto.
  - intros. assert (RealMPTrace'' MPcall).
    { apply FindCallReal in H1; auto. }
    split.
    + destruct H2.
      * destruct H2 as [MPsuff]. destruct H2.
        apply (EagerImpliesLazyInt C' MPcall MPpre MPsuffO); auto.
        { constructor. exists MPsuff. split; auto. }
        destruct H0. destruct H5. specialize H6 with MPpre MPcall C'.
        apply H6 in H1. destruct H1;auto. constructor.
        exists MPsuff. auto.
      * destruct H2. destruct H4. rewrite H5. unfold ObservableIntegrity. auto.
    + apply (EagerImpliesLazyConf C' MPcall); auto.
      destruct H0. destruct H4. specialize H5 with MPpre MPcall C'.
        destruct H5; auto.
        { unfold PrefixUpTo. destruct H2.
          - left. destruct H2 as [MPsuff]. destruct H2. exists MPsuff. auto.
          - right. destruct H2. destruct H5. split; auto. }
        assert (head MPcall = head MPpre).
        { destruct H2.
          - destruct H2 as [MPsuff]. destruct H2.
            apply SplitInclusiveHeadEq in H7. auto.
          - destruct H2. destruct H7. inversion H7;auto. }
        rewrite H7. auto.
Qed.*)

(*Conjecture Lazy'ImpliesLazy :
  forall cm C MM,
  LazyStackSafety' cm C MM -> LazyStackSafety cm C MM.

Conjecture LazyNotImpliesLazy' :
  exists cm C MM,
  LazyStackSafety cm C MM /\ ~ LazyStackSafety' cm C MM.*)
(* The counterexample:

main: mov #0 r1
      store r1 FP
      [call sequence to sub]
      ld FP r1
      bne r1 r2 #2
      mov #1 O
      beq #0 #0 #1
      mov #0 O
      halt

sub:  ld (FP-1) r2
      beq r2 #0 #2
      mov #1 r1
      store r1 (FP-1)
      [return sequence]

In observable confidentiality, if the variation keeps main's memory the same,
sub returns and the behavior is [1]. Of course that is the case for the actual trace as well.
If it changes, sub writes 1 to it and to r1, so the behavior is still [1].

In observable integrity, sub never does anything, because there is no variant. So
the behavior is [1] for both the ideal and actual traces.

But for confidentegrity, if main's memory varies, sub moves 1 to r1 and stores it
in main's memory. Then the rollback sets main's memory back to 0. So r1 and r2 will
not be equal, and the behavior is [0]. So confidentegrity does not hold. *)

(* ********* Well Bracketed Control Flow ******** *)

Definition ControlSeparation cm rm em cdm : Prop :=
  forall m p m1 p1 m2 p2 o n,
    initPolicyState m (cm,rm,em,cdm) = Some p ->
    InTrace (m1,p1) (MPTraceOf (m,p)) ->
    step m1 = (m2,o) ->
    pstep (m1,p1) = Some p2 ->
    cdm (m1 (Reg PC)) <> cdm (m2 (Reg PC)) ->
    cm (m1 (Reg PC)) = Some n \/ rm (m1 (Reg PC)).

(* UnmatchedReturn cm rm MPO MPO' 
   means that MPO' is the suffix of MPO such that 
   head MPO' is the first unmatched return in MPO *)
CoInductive UnmatchedReturn : CallMap -> RetMap -> MPTrace -> MPTrace -> Prop :=
| URNow : forall cm (rm:RetMap) MP m p,
    head MP = (m,p) ->
    cm (m (Reg PC)) = None ->
    rm (m (Reg PC)) ->
    UnmatchedReturn cm rm MP MP
| URLater : forall cm rm MP m p MP',
    cm (m (Reg PC)) = None ->
    ~ rm (m (Reg PC)) ->
    UnmatchedReturn cm rm MP MP' ->
    UnmatchedReturn cm rm (notfinished (m,p) MP) MP'
| URCall : forall cm rm n MP m p MPcallee mpret MPret MPafter MPresult,
    cm (m (Reg PC)) = Some n ->
    ~ rm (m (Reg PC)) ->
    MP = notfinished (m,p) MPcallee ->
    UnmatchedReturn cm rm MPcallee MPret ->
    MPret = (notfinished mpret MPafter) ->
    UnmatchedReturn cm rm MPafter MPresult ->
    UnmatchedReturn cm rm MP MPresult.


Definition ReturnIntegrity cm rm em cdm : Prop :=
  forall m p,
    let MPTop := MPTraceOf (m, p) in
    initPolicyState m (cm,rm,em,cdm) = Some p ->
    (forall C mpcall MPcallee MPret mpret,
        FindCallMP cm cdm MPTop C (notfinished mpcall MPcallee) ->
        UnmatchedReturn cm rm MPcallee (notfinished mpret MPret) ->
        justRet (ms mpcall) (ms (head MPret))) /\
    (forall MPret, ~ UnmatchedReturn cm rm MPTop MPret).

Definition EntryIntegrity cm rm em cdm : Prop :=
  forall m p m1 p1 m2 p2 o n,
    initPolicyState m (cm,rm,em,cdm) = Some p ->
    InTrace (m1,p1) (MPTraceOf (m,p)) ->
    step m1 = (m2,o) ->
    pstep (m1,p1) = Some p2 ->
    cm (m1 (Reg PC)) = Some n ->
    em (m2 (Reg PC)).

Definition WellBracketedControlFlow cm rm em cdm : Prop :=
  ControlSeparation cm rm em cdm /\
  ReturnIntegrity cm rm em cdm /\
  EntryIntegrity cm rm em cdm.

(*

(* ********* Tags and tagged properties and policies ********* *)

(* Type of tags and some tags of interest, with a minimalist form of blessed
   call and return sequences.

   RB: TODO: Concretize this? Share among related sections? *)
Variable Tag : Type.
Variable Instr : Tag.
Variable Call : Tag.
Variable Ret : Tag.
Variable PCdepth : nat -> Tag.
Variable SPtag : Tag.
Variable Stack : nat -> Tag.
Variable H1 : Tag.

Section EagerPolicy.

(* Machine states are enriched with mappings from components to tags. (Should a
   rich state be a pair of a machine state and the enrichment?) For now, lists
   are used in lieu of sets and an ordering assumed.

   RB: TODO: Previously called RichState, harmonize w.r.t. testing development.
*)
Definition TagState := Component -> list Tag.
Variable tagsOf : TagState -> Component -> list Tag.

(* Given a call map [cm] and contour [C], relate these to the rich state(s) [T]
   whose tagging is compatible with those. (Add an initial machine state?) *)
Variable InitialTags : CallMap -> Contour -> TagState -> Prop.

(* We need some way to update tags. *)
Variable updateTag : TagState -> Component -> list Tag -> TagState.

(* We need to know whether the currently executing instruction performs memory
   operations (loads and stores), and on which address they operate. *)
Variable isLoad : MachineState -> Addr -> Prop.
Variable isStore : MachineState -> Addr -> Prop.

CoInductive TaggedStep (M: MachineState) (T : TagState) : TagState -> Prop :=
| TCall : forall T' d,
    tagsOf T (Mem (M (Reg PC))) = [Call; Instr] ->
    tagsOf T (Reg PC) = [PCdepth d] ->
    updateTag T (Reg PC) [PCdepth (S d)] = T' ->
    TaggedStep M T T'
| TRet : forall T' d,
    tagsOf T (Mem (M (Reg PC))) = [Instr; Ret] ->
    tagsOf T (Reg PC) = [PCdepth (S d)] ->
    updateTag T (Reg PC) [PCdepth d] = T' ->
    TaggedStep M T T'
| TLoad : forall iaddr dPC dMem,
    isLoad M iaddr ->
    tagsOf T (Reg PC) = [PCdepth dPC] ->
    tagsOf T (Mem iaddr) = [Stack dMem] ->
    dPC <= dMem ->
    TaggedStep M T T
| TStore : forall T' iaddr d,
    isStore M iaddr ->
    tagsOf T (Reg PC) = [PCdepth d] ->
    updateTag T (Mem iaddr) [Stack d] = T' ->
    TaggedStep M T T'
(* ... *)
.

CoInductive TaggedRun : TagState -> MTrace -> Prop :=
| RunFinished : forall T M,
    TaggedRun T (finished M)
| RunNotfinished : forall T T' M MM O,
    step M = Some (head MM,O) ->
    TaggedStep M T T' ->
    TaggedRun T' MM ->
    TaggedRun T (notfinished M MM).

(* TODO: Add missing ingredients from testing and important details. *)

(* The eager policy allows a trace if said trace can result from a run of the
   rich machine starting from the initial enriched state. *)
CoInductive EagerPolicyTrace : CallMap -> Contour -> MTrace -> Prop :=
| EPTIntro : forall cm C T MM,
    InitialTags cm C T ->
    TaggedRun T MM ->
    EagerPolicyTrace cm C MM.

Conjecture EagerPolicy_StackSafety :
  forall cm MM C,
    EagerPolicyTrace cm C MM ->
    EagerStackSafety cm MM C.

End EagerPolicy.

Section EagerTestingProperty.

(* TODO: Consider moving towards a computable variant of the property. *)

(* The state of the PIPE is a tag map and a counter containing the next unique
   identifier to be generated. *)
Definition PipeState := (TagState * nat)%type.

(* The rich machine state is simply a pair of machine and PIPE states. *)
Definition RichState := (MachineState * PipeState)%type.

(* Simplified state description "tags" for the testing property. *)
Variant DescTag :=
| DTStack : nat -> DescTag
| DTInstr : DescTag
| DTOther : DescTag.

(* State description for the testing policy. *)
Record StateDesc := mkStateDesc {
  pcdepth : nat ;
  memdepth : Addr -> DescTag ;
  dstack : list (Addr * Addr * RichState) ;
  callinstrs : list Addr ;
  callsites : list Addr ;
}.

(* Tag helpers. *)
Definition callTag := [Call; Instr]. (* Should be "callerTag"? *)
Definition calleeTag := [H1; Instr].
(* From tag sets to description "tags". *)
Variable to_desc : list Tag -> DescTag.
  (* match ts with *)
  (* | [Stack n] => DSStack n *)
  (* | [PCdepth _] => DTOther *)
  (* | [SPtag] => DTOther *)
  (* | _ => DTInstr *)
  (* end. *)
(* These would be standard map and filter functions on finite memories. *)
Variable map : forall {A B C : Type} (m : A -> B) (f : B -> C), (A -> C).
Variable eqMap : forall {A B : Type} (m1 m2 : A -> B) (def : B -> Prop), Prop.
Variable mapFilter :
  forall {A B : Type} (m : A -> B) (f : A -> B -> Prop), (A -> B).

Arguments eqMap {_ _} _ _ _.
Arguments mapFilter {_ _} _ _ _.

Definition eqMapFilter {A B} (m1 m2 : A -> B) f d :=
  eqMap (mapFilter m1 f) (mapFilter m2 f) d.
(* More helpers for memories. *)
Variable memLayout : TagState -> (Addr -> DescTag).
Variable memCallers : TagState -> list Addr.
Variable memCallees : TagState -> list Addr.
(* And some more. *)
Variable stateMem : RichState -> (Addr -> Value).
Variable defMem : Value.

(* Default memory tag. *)
Definition initMem := [Stack 0].
Definition defDesc := to_desc initMem.

(* Initial state description. *)
Definition initDesc (ts : TagState) : StateDesc :=
  mkStateDesc
    0
    (memLayout ts)
    []
    (memCallers ts)
    (memCallees ts).

(* Test state as state of the main machine and a list of variant machines with
   their states. *)
Definition TestState := (RichState * list RichState)%type.

(* Attempt to take a step in all machine variants. *)
Variable testStep : TestState -> option TestState.

(* Helpers for single-step stack safety. *)
Definition tagOf (def : DescTag) (addr : Addr) (sd : StateDesc) : DescTag :=
  (memdepth sd) addr. (* Not using the default here, vs. sparse memory maps. *)

Definition accessibleTag (t : DescTag) (depth : nat) : Prop :=
  match t with
  | DTStack n => n >= depth
  | DTInstr => False
  | DTOther => False
  end.

Definition isAccessible (def : DescTag) (addr : Addr) (sd : StateDesc) : Prop :=
  accessibleTag (tagOf def addr sd) (pcdepth sd).

Definition isInaccessible (def : DescTag) (addr : Addr) (sd : StateDesc) : Prop :=
  ~ accessibleTag (tagOf def addr sd) (pcdepth sd).

Definition isInstruction (def : DescTag) (addr : Addr) (sd : StateDesc) : Prop :=
  match (tagOf def addr sd) with
  | DTInstr => True
  | _ => False
  end.

(* single_step_stack_safety *)
Inductive EagerTestingSingleStep
           (s  : RichState)
           (d  : StateDesc)
           (t  : RichState) (* variant of [s] w.r.t. [d] *)
           (s' : RichState) (* state such that [s] steps to it *)
           (d' : StateDesc) (* state description of [s'] *)
           (t' : RichState) (* state such that [t] steps to it *)
  : Prop :=
| ETsingle :
    (* Instruction memory of [s'] and [t'] w.r.t. [d] agrees. *)
    let isInstruction' addr _ := isInstruction defDesc addr d in
    eqMapFilter (stateMem s') (stateMem t') isInstruction' (fun _ => False) ->
    (* Accessible memory of [s'] and [t'] w.r.t. [d] agrees. *)
    let isAccessible' addr _ := isAccessible defDesc addr d in
    eqMapFilter (stateMem s') (stateMem t') isAccessible' (fun x => x = defMem) ->
    (* Inaccessible memory of [t] and [t'] w.r.t. [d] agrees. *)
    let isInaccessible' addr _ := isInaccessible defDesc addr d in
    eqMapFilter (stateMem t) (stateMem t') isInaccessible' (fun x => x = defMem) ->
    (* The step eagerly satisfies stack safety. *)
    EagerTestingSingleStep s d t s' d' t'.

(* next_state *)
Variable next_desc :
  forall (def : DescTag) (s : RichState) (d : StateDesc) (s' : RichState),
  option StateDesc.

(* prop_stack_safety_full (1)
   (1) works on genVariationTestState (2)
       and uses to_desc, callTag and calleeTag to get initDesc
       and passes this to stack_safety_full (3)
   (2) takes a few arguments for generation, including isSecretMP (4)
       leaving this abstract at the moment
   (3) operates on traces of TestStates (Main + Variants) *)
(* TODO: Synchronize MTrace and TestState. *)
CoInductive EagerTestingFull : MTrace -> StateDesc -> TestState -> Prop :=
| ETFdone : forall M d ts,
    EagerTestingFull (finished M) d ts
| ETFstep : forall M MM dInput dUpdated tsInput tsScrambled tsStepped,
    (* First, check if the currently executed instruction is (the destination
       of) a call. If it is, scramble. *)
    (* In (M (Reg PC)) (callsites d) -> *)
    (* Take a step in all machine variants. *)
    testStep tsScrambled = Some tsStepped ->
    (* Compute the next state description. *)
    next_desc defDesc (fst tsInput) dInput (fst tsStepped) = Some dUpdated ->
    (* Call single-step stack safety for each variant.*)
    (* ... *)
    EagerTestingFull (notfinished M MM) dInput tsInput.

Variable EagerTesting : Prop.

(* Conjecture EagerTesting_StackSafety : ... *)

End EagerTestingProperty.

*)

(*
(* Following attempts to encode subtraces that start on transition to NOTME, but can end anywhere as long as still NOTME.
There is surely still a prettier way! *)


Definition notme (id: Identity) : Prop :=
  match id with
  | NOTME _ _ _ _ => True
  | _ => False
  end.

Definition notme' (cid : Contour * Identity * MachineState) := notme (snd (fst cid)).

CoInductive subtraceAux : CTrace -> MTrace -> Contour -> Prop :=
| subtraceAuxNow: forall C id m MM MM',
     ~ notme id -> TracePrefix MM MM' -> ForallTrace notme' MM' -> subtraceAux (notfinished (C,id,m) MM) (mapTrace snd MM') C
| subtraceAuxLater: forall cim C MM MM' ,  subtraceAux MM MM' C -> subtraceAux (notfinished cim MM) MM' C
.

Definition subtrace (retSP: Value) (cm :CallMap) (C0: Contour) (super: MTrace) (sub: MTrace) (C:Contour) :=
  subtraceAux (CTraceOf retSP C0 super cm) sub C.


(* APT: As things stand, retSP is always initSP.  Is this right? *)
(* LEO: The retSP should always be the stack pointer of the callee of the "initial" process. So when recursing in StackSafety the retSP should be the SP of (head Mcallee) I think. *)
(* APT: Does the adjustment below do the trick? *)

End foo.


(* There are many well-formedness conditions on this... *)

Inductive Identity :=
| ME : Value -> (* SP below which I can't access things *)
       Identity
| NOTME : Value -> (* PC at the time of call *)
          Value -> (* SP at the time of call *)
          nat -> (* local state size *)
          Value -> (* SP of callee *)
          Identity
| TRANS :
    list Value -> (* Instructions remaining in the sequence *)
    nat ->        (* local state size to be allocated *)
    Value ->      (* PC at the time of call *)
    Value ->      (* SP at the time of call *)
    Value ->      (* SP of callee *)
    Identity.

Definition ITrace := Trace (Identity * MachineState).

(* APT: Recast as operator over MTraces.
        Assumes each call sequence starts with the JAL, right?
        Is this essential, or was it just to make things a bit simpler? *)
(* LEO: Each call sequence starts with a jal : that makes the
formalization significantly simpler as you can figure out the
information you need for contour changes the moment you start the
transition. Is it too unrealistic an assumption? *)
(* APT: I think this is fine, provided that we allow the callee to
access the piece of the callers stack containing the arguments. To do
this, we can add an additional parameter to the call map entries
giving the number of args.  (Note that this prevents our handling
dynamic frame sizes, but that is a feature that is ok to omit at least
at first.)  *)
(* LEO: Note that this way the handling of arguments/returns is not
part of the blessed sequence. And we could either (1) assume there is
enough local stack space for all calls or (2) handle stack allocation
and deallocation in the contours.  *)

CoFixpoint ITraceOfAux (id : Identity) (MM : MTrace) (M: MachineState) (cm : CallMap) : ITrace :=
  match MM with
  | finished _ => finished (id, M)
  | notfinished _ MM' =>
    let M' := head MM' in
    match id with
    | ME meSP =>
      match find (fun cme =>
                    match cme with
                    | (h::_, _) => valueEq h (valueOf PC M')
                    | _ => false
                    end) cm with
      | Some (seq, sz) =>
        notfinished (id,M) (ITraceOfAux (TRANS seq
                                               sz
                                               (valueOf PC M')
                                               (valueOf SP M')
                                               meSP)
                                        MM' M' cm)
      | None =>
        notfinished (id,M) (ITraceOfAux (ME meSP) MM' M' cm)
      end
    | TRANS seq sz jalPC jalSP meSP =>
      match seq with
      | _im :: im' :: ims =>
        notfinished (id,M)
                    (ITraceOfAux (TRANS (im' :: ims) sz jalPC jalSP meSP) MM' M' cm)
      | _ =>
        (* Potential check: should be a singleton list always (_im) *)
        notfinished (id, M)
                    (ITraceOfAux (NOTME jalPC jalSP sz meSP) MM' M' cm)
      end
    | NOTME jalPC jalSP sz meSP =>
      if andb (valueEq (valueOf PC M') (vplus jalPC 4))
              (valueEq (valueOf SP M') jalSP) then
        notfinished (id,M) (ITraceOfAux (ME meSP) MM' M' cm)
      else
        notfinished (id,M) (ITraceOfAux (NOTME jalPC jalSP sz meSP) MM' M' cm)
    end
  end.

Definition CTrace := Trace (Contour * Identity * MachineState).

Definition updateContour (C : Contour) (id id' : Identity) (M M' : MachineState) :=
  match id, id' with
  | ME _, ME _ => C
  | NOTME _ _ _ _, NOTME _ _ _ _ => C
  | TRANS _ _ _ _ _, TRANS _ _ _ _ _ => C
  | ME _, TRANS _ sz _ _ _=>
    (* Everything other than the sz top parts of the stack becomes unreachable. *)
    fun k => if cle k (componentOf (vminus (valueOf SP M) sz))
             then (HC, HI) else C k
  | TRANS _ _ _ _ _, NOTME _ jalSP _ _=>
    (* Everything between the size of SP at the call, and the current SP
       is now "local state" *)
    fun k => if andb (cle k (componentOf (valueOf SP M')))
                     (clt (componentOf jalSP) k)
             then (LC, LI)
             else C k
  | NOTME _ _ (* jalSP *) _ _, ME meSP =>
    (* Everything above the SP at the call becomes unreadable again,
       Everything below the SP but above the low limit of ME becomes
       readable again. *)
    fun k => if andb (clt (componentOf meSP) k)
                     (cle k (componentOf (valueOf SP M')))
             then (LC, LI)
             else if clt (componentOf (valueOf SP M')) k then (HC, HI)
             else C k
  | _, _ => (* ERROR CASE *)
    C
  end.

CoFixpoint ContouredTraceOf (C : Contour) (it : ITrace) :=
  match it with
  | finished (id, M) =>
    finished (C, id, M)
  | notfinished (id, M) MM =>
    let (id', M') := head MM in
    let C' := updateContour C id id' M M' in
    notfinished (C, id, M) (ContouredTraceOf C' MM)
  end.

Definition CTraceOf (retSP : Value) (C : Contour) (MM : MTrace) (cm : CallMap) :=
  ContouredTraceOf C (ITraceOfAux (ME retSP) MM (head MM) cm).


Definition updateObs (s : StateObs) (C' : Contour) (M' : MachineState) : StateObs :=
  fun k => match confidentialityOf (C' k) with
           | LC => Some (valueOf k M')
           | HC => s k
           end.

CoFixpoint ObsTraceAux (s : StateObs) (ct : CTrace) : OTrace :=
  match ct with
  | finished (C, id, M) =>
    finished (updateObs s C M)
  | notfinished (C, id, M) CIMs =>
    let s' := updateObs s C M in
    notfinished s' (ObsTraceAux s' CIMs)
  end.

Definition ObsTrace (ct : CTrace) : OTrace :=
  let '(C,_,M) := head ct in
  let s0 := fun k =>
              match confidentialityOf (C k) with
              | LC => Some (valueOf k M)
              | HC => None
              end in
  ObsTraceAux s0 ct.


*)

Section PaperVersions.

  (* This section contains simplified versions of the properties as presented in the paper
     (though using the more complex machinery we've used elsewhere. *)
  (* Translating to the larger development: in general, these definitions correspond to
     those named XOld, but factored for easier explanation. But the older definitions
     use MTraces that are just machine states and MPTraces that are just machine*policy pairs,
     with observations extracted separately.
     
     MPTrace is Trace (MachineState * PolicyState. MPTrace' is the paper-style
     Trace (MachineState * PolicyState * Observation). MTrace' is the paper-style
     Trace (MachineState * Observation). *)
  
  (* So if MP is a Trace (MachineState * PolicyState) and MPO is a
     Trace (MachineState * PolicyState * Observation), and MP was created by MPTraceOf,
     ObsTraceOf MP = ObsOfMP MPO
     And in paper terms, ObsOfMP is directly equivalent to pi_o(MPO)
     The same relation exists between ObsTraceOfM and ObsOfM on machine traces *)

  
  Variable cm : CallMap.
  Variable cdm : CodeMap.
  Variable em : EntryMap.
  Variable rm : RetMap.

  Definition pm := (cm,rm,em,cdm).

  (* This property is the one that holds on the trace in EagerStackIntegrityEnd,
     but taking the trace as an argument instead. *)
  Definition TraceIntegrityPaper (C:Contour) (MP:MPTrace') : Prop :=
    forall mp1 mp2,
      (head MP) = mp1 ->
      Last MP mp2 ->
      (forall k, integrityOf (C k) = HI -> (ms (fst mp1)) k = (ms (fst mp2)) k).

  (* Then the part where we find calls is the same as in StackSafetyOld, but split out
     for StackIntegrity. Since we don't actually care about the observations, we can use
     MPTraceOf instead of MPRunOf to find the calls. Then we take the induced trace from the
     entry state (a step from the call state found by FindCallMP) and use trace integrity. *)
  Definition StackIntegrityPaper : Prop :=
    forall m p MPcall,
      initPolicyState m pm = Some p ->
      (forall (mpc : MPState) me pe oe C,
          FindCallMP cm cdm (MPTraceOf (m,p)) C (MPTraceOf mpc) -> (* Find call*)
          mpstep mpc = Some (me,pe,oe) ->
          RunUpTo (fun mp => justRet m (ms mp)) (MPRunOf (me,pe)) MPcall ->
          TraceIntegrityPaper C MPcall).

  (* The cases of TraceConfidentiality are the same as in EagerStackConfidentialityOld,
     but with the variation and construction of the trace factored out. *)
  Definition ReturnCase (R:MachineState -> Prop) (MP:MPTrace') (M:MTrace') : Prop :=
    forall m p o,
      Last MP (m,p,o) ->
      R m ->
      exists m' o',
        Last M (m',o') /\
        R m' /\
        ObsOfMP MP ~=_O ObsOfM M /\
        forall k, ((ms (fst (head MP))) k <> m k \/ (fst (head M)) k <> m' k) -> m k = m' k.

  (* Unlike EagerStackConfidentialityOld, we use the infinite predicate, which is equivalent to
     forall a, ~ Last T a *)
  Definition InfCase (MP:MPTrace') (M:MTrace') : Prop :=
    Infinite MP ->
    Infinite M ->
    ObsOfMP MP ~=_O ObsOfM M.

  Definition FailCase (R:MachineState -> Prop) (MP:MPTrace') (M:MTrace') : Prop :=
    forall mpo,
      Last MP mpo ->
      ~ R (ms (fst mpo)) ->
      ObsOfMP MP <=_O ObsOfM M.

  Definition TraceConfidentialityPaper (R:MachineState -> Prop) (MP:MPTrace') (M:MTrace') : Prop :=
    ReturnCase R MP M /\ InfCase MP M /\ FailCase R MP M.

  Definition StackConfidentialityPaper : Prop :=
    forall m m' p,
      let initC := makeContour cdm 0 m in
      initPolicyState m pm = Some p ->
      variantOf m m' initC ->
      (* we've omitted this from the paper... should put it back *)
      (TraceConfidentialityPaper (fun _ => False) (MPRunOf (m,p)) (RunOf m')) /\
      (forall (mp : MPState) m' C MPcall Mcall,
          FindCallMP cm cdm (MPTraceOf (m,p)) C (MPTraceOf mp) -> (* Find call*)
          variantOf (ms mp) m' C ->
          RunUpTo (fun mp' => justRet (ms mp) (ms mp')) (MPRunOf mp) MPcall ->
          RunUpTo (justRet (ms mp)) (RunOf m') Mcall ->
          TraceConfidentialityPaper (justRet (ms mp)) MPcall Mcall).

  Definition StackSafetyPaper :=
    StackIntegrityPaper /\ StackConfidentialityPaper.

  Definition LazyTraceIntPaper (C:Contour) (MP:MPTrace') : Prop :=
    forall mp1 mp2,
      (head MP) = mp1 ->
      Last MP mp2 ->
      ObsOfMP (MPRunOf (fst mp2)) <=_O ObsOfM (RunOf (RollbackInt C (ms (fst mp1)) (ms (fst mp2)))).

  Definition LazyStackIntPaper : Prop :=
    forall m p MPcall,
      initPolicyState m pm = Some p ->
      (forall (mp : MPState) C,
          FindCallMP cm cdm (MPTraceOf (m,p)) C (MPTraceOf mp) -> (* Find call*)
          RunUpTo (fun mp => justRet m (ms mp)) (MPRunOf mp) MPcall ->
          LazyTraceIntPaper C MPcall).

  Definition ReturnCaseLazy (R:MachineState -> Prop) (MP:MPTrace') (M:MTrace') : Prop :=
    forall m p o,
      Last MP (m,p,o) ->
      R m ->
      exists m' o',
        Last M (m',o') /\
        R m' /\
        ObsOfMP MP ~=_O ObsOfM M /\
        ObsOfMP (MPRunOf (m,p)) <=_O ObsOfM (RunOf (RollbackConf (ms (fst (head MP))) (fst (head M)) m m')).

  Definition LazyTraceConfPaper (R:MachineState -> Prop) (MP:MPTrace') (M:MTrace') : Prop :=
    ReturnCaseLazy R MP M /\ InfCase MP M /\ FailCase R MP M.

  Definition LazyStackConfPaper : Prop :=
    forall m m' p,
      let initC := makeContour cdm 0 m in
      initPolicyState m pm = Some p ->
      variantOf m m' initC ->
      (* we've omitted this from the paper... should put it back *)
      (LazyTraceConfPaper (fun _ => False) (MPRunOf (m,p)) (RunOf m')) /\
      (forall (mp : MPState) m' C MPcall Mcall,
          FindCallMP cm cdm (MPTraceOf (m,p)) C (MPTraceOf mp) -> (* Find call*)
          variantOf (ms mp) m' C ->
          RunUpTo (fun mp' => justRet (ms mp) (ms mp')) (MPRunOf mp) MPcall ->
          RunUpTo (justRet (ms mp)) (RunOf m') Mcall ->
          LazyTraceConfPaper (justRet (ms mp)) MPcall Mcall).

  Definition LazyStackSafetyPaper : Prop :=
    LazyStackIntPaper /\ LazyStackConfPaper.
