Require Import List.
Import ListNotations.
Require Import Bool.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Omega.
Require Import Trace.
Require Import Machine.
Require Import ObsTrace.
Require Import Paco.paco.

(* todo: Rename MPState to State and MPTrace to Trace, mp -> t *)
Definition MTrace := TraceOf MachineState.

CoFixpoint MTraceOf (M : MachineState) : MTrace :=
  notfinished M (MTraceOf (fst (step M))).

Definition MPTrace := TraceOf MPState.

CoFixpoint MPTraceOf (mp : MPState) : MPTrace :=
  match pstep mp with
  | None => finished mp
  | Some p' => notfinished mp (MPTraceOf (fst (step (ms mp)), p'))
  end.


(****************************)
(***** Eager Integrity ******)
(****************************)

(* Latex-like definition. *)
Definition EagerStackIntegrity (C : Contour) (MP: MPTrace) : Prop :=
    forall (k: Component), integrityOf (C k) = HI ->
      forall (mp : MPState),
        InTrace mp MP -> ms (head MP) k = ms mp k.

Create HintDb StackSafety.

(* CoInductive variant *)
(* RB: TODO: Indexing over the contour as well to get cleaner coinduction with
   Paco while sorting things out. *)
Inductive EagerStackIntegrity'_gen R :
  Contour -> MPTrace -> Prop :=
| SI_finished : forall C mp,
    EagerStackIntegrity'_gen R C (finished mp)
| SI_notfinished :
    forall (C : Contour) (mp: MPState) (MP : MPTrace),
    (forall (k: Component), integrityOf (C k) = HI -> ms mp k = ms (head MP) k) ->
    R C MP ->
    EagerStackIntegrity'_gen R C (notfinished mp MP).
Hint Constructors EagerStackIntegrity'_gen : core.

Definition EagerStackIntegrity' (C : Contour) (MP : MPTrace) :=
  paco2 EagerStackIntegrity'_gen bot2 C MP.
Hint Unfold EagerStackIntegrity' : core.
Lemma EagerStackIntegrity'_mon : monotone2 EagerStackIntegrity'_gen. Proof. pmonauto. Qed.
Hint Resolve EagerStackIntegrity'_mon : paco.

(* RB: TODO: See if these work as well as the old version. *)
Hint Constructors EagerStackIntegrity'_gen : StackSafety.

Lemma StackIntegrityEquiv : forall (C:Contour) (MP: MPTrace),
     EagerStackIntegrity C MP -> EagerStackIntegrity' C MP.
Proof.
  intros C. pcofix COFIX.
  intros MP H; pfold.
  destruct MP.
  - constructor.
  - constructor.
    + intros. unfold EagerStackIntegrity in H.  simpl in H.
      apply H; auto. constructor. apply head_InTrace.
    + right. apply COFIX.
      unfold EagerStackIntegrity in *.  intros. simpl in H.
      erewrite <- H; auto.
      * apply H; auto.  constructor. auto.
      * constructor. apply head_InTrace.
Qed.

Lemma StackIntegrity'Equiv : forall (C:Contour) (MP: MPTrace),
     EagerStackIntegrity' C MP -> EagerStackIntegrity C MP.
Proof.
  unfold EagerStackIntegrity.
  intros C MP H1 k H2 mp H3.
  induction H3 as [| | ? ? ? IHInTrace].
  - auto.
  - auto.
  - simpl. pinversion H1. subst. rewrite <- IHInTrace.
    +  punfold H6.
    +  apply H6.
Qed.

Definition EagerStackIntegrity'' (C:Contour) (mp:MPState) (justReturned:MachineState -> Prop) : Prop :=
  forall MP mp',
    PrefixUpTo (fun mp => justReturned (ms mp)) (MPTraceOf mp) MP ->
    Last MP mp' ->
    (forall k, integrityOf (C k) = HI -> (ms mp) k = (ms mp') k).

(* NB: It doesn't matter whether we calculate this at a
call instruction (as in a subtrace) or at the first
instruction of the callee (as in the top-level trace)
assuming that registers remain LI,LC at all times. *)

Definition variantOf (M N : MachineState) (C : Contour) :=
  forall (k : Component), confidentialityOf (C k) = LC ->
                          M k = N k.

Hint Unfold variantOf : StackSafety.

CoFixpoint ObsTraceOfM (M: MTrace) : ObsTrace :=
  match M with
  | finished m =>
    finished Tau
  | notfinished m M' =>
    let (m', O) := step m in
    notfinished O (ObsTraceOfM M')
  end.

CoFixpoint ObsTraceOf (MP: MPTrace) : ObsTrace := 
  match MP with
  | finished mp =>
    finished Tau
  | notfinished mp MP' =>
    let (m', O) := step (ms mp) in
    notfinished O (ObsTraceOf MP')
  end.

Hint Constructors ObsTraceEq_gen : StackSafety.

Hint Constructors ObsTracePrefix_gen : StackSafety.


(* The entire trace MP represents a callee, that terminates when (and if)
   control has returned to the caller, according to the "justReturned" predicate.
   Note: If we are at a toplevel trace, "justReturn" will never hold. *)
Definition EagerStackConfidentiality (C : Contour) (MP : MPTrace)
           (justReturned : MachineState -> Prop) :=
  forall m' M',
    (* If m' is a variant of the initial state of MP... *)
    variantOf (ms (head MP)) m' C ->
    (* And if M' is the longest prefix of the traced generated by m'
       up to and including the point where control has returned to the
       caller (or the whole trace if the callee doesn't return control)... *)
    PrefixUpTo justReturned (MTraceOf m') M' ->
    (* There are three cases to consider now: *)

    (* 1. The callee ends succesfully with a return. *)
    (forall mpret, Last MP mpret -> justReturned (ms mpret) ->
     (* Then: 
        - M' also terminates in some state mret'.
        - And for every component k whose value changed either between the 
          initial and final states of MP or of M', then the final states agree 
          on the value of k.
        - And the observations of MP and M' are the same. 
      *)
      (exists mret', Last M' mret' /\
                     forall k, 
                       (ms (head MP) k <> ms mpret k \/ (head M') k <> mret' k) ->
                       ms mpret k = mret' k) /\
      (ObsTraceOf MP) ~=_O (ObsTraceOfM M')) /\

    (* 2. The callee trace is cut short by a monitor fault. *)
    (forall mpret, Last MP mpret -> (* mpstep mpret = None -> *)
                   ~ justReturned (ms mpret) ->
     (* Then: 
        - The observations of the MP trace are a prefix of the 
          observations of M'.
      *)
     (ObsTraceOf MP) <=_O (ObsTraceOfM M')) /\
    
    (* 3. The callee trace never returns. *) 
    ((forall mpret, ~ Last MP mpret) ->
     (* Then: 
        - The variant trace never returns.
        - The observations of MP and M' are the same. 
      *)
     forall mret', ~ Last M' mret' /\
                   (ObsTraceOf MP) ~=_O (ObsTraceOfM M')).

Hint Unfold EagerStackConfidentiality : StackSafety.

Definition EagerStackConfidentiality' (C : Contour) (mp : MPState) (justReturned : MachineState -> Prop) :=
  forall m' MP M',
    variantOf (ms mp) m' C ->
    PrefixUpTo (fun mp => justReturned (ms mp)) (MPTraceOf mp) MP ->
    PrefixUpTo justReturned (MTraceOf m') M' ->
    (forall mpret, Last MP mpret -> justReturned (ms mpret) ->
                   (exists mret', Last M' mret' /\
                                  forall k, 
                       (ms (head MP) k <> ms mpret k \/ (head M') k <> mret' k) ->
                       ms mpret k = mret' k) /\
                   (ObsTraceOf MP) ~=_O (ObsTraceOfM M')) /\
    (forall mpret, Last MP mpret -> (* mpstep mpret = None -> *)
                   ~ justReturned (ms mpret) ->
                   (ObsTraceOf MP) <=_O (ObsTraceOfM M')) /\
    ((forall mpret, ~ Last MP mpret) ->
     forall mret', ~ Last M' mret' /\
                   (ObsTraceOf MP) ~=_O (ObsTraceOfM M')).

Inductive StrongEagerStackConfidentiality_gen (R : MachineState -> Prop) Rcoind :
  MPTrace -> MTrace -> Prop :=
| StrongConfStep :
    (* Maybe the top one should have a not ret *)
    forall mp MP m' M' O,
      mpstep mp = Some (ms (head MP), ps (head MP), O) ->
      step m' = (head M', O) ->
      (forall k, ms (head MP) k <> ms mp k \/
                 (head M') k <> m' k -> ms (head MP) k = head M' k) ->
      Rcoind MP M' ->
      StrongEagerStackConfidentiality_gen R Rcoind (notfinished mp MP) (notfinished m' M')
| StrongConfEnd :
    forall mp m,
      R (ms mp) -> R m ->
      StrongEagerStackConfidentiality_gen R Rcoind (finished mp) (finished m)
| StrongConfNotMStep :
    forall mp MV,
      ~ (R (ms mp)) ->
      (* mpstep mp = None ->  *)
      StrongEagerStackConfidentiality_gen R Rcoind (finished mp) MV.
Hint Constructors StrongEagerStackConfidentiality_gen : core.

Definition StrongEagerStackConfidentiality (R : MachineState -> Prop) MP M :=
  paco2 (StrongEagerStackConfidentiality_gen R) bot2 MP M.
Hint Unfold StrongEagerStackConfidentiality : core.
Lemma StrongEagerStackConfidentiality_mon (R : MachineState -> Prop) : monotone2 (StrongEagerStackConfidentiality_gen R). Proof. pmonauto. Qed.
Hint Resolve StrongEagerStackConfidentiality_mon : paco.

Hint Constructors StrongEagerStackConfidentiality_gen : StackSafety.

Lemma confStepPreservesVariant :
  forall C mp m' p' OM mv mv' ON,
    mpstep mp = Some (m', p', OM) ->
    step mv = (mv', ON) ->
    (forall k, m' k <> ms mp k \/ mv' k <> mv k -> m' k = mv' k) ->
    variantOf (ms mp) mv C ->
    variantOf m' mv' C.
Proof.
  unfold variantOf.
  intros C mp m' p' OM mv mv' ON StepM StepN Conf Var k Hk.
  destruct (WordEqDec (m' k) (ms mp k)) as [eqM | neqM];
  destruct (WordEqDec (mv' k) (mv k)) as [eqN | neqN];
  try solve [ apply Conf; auto ];
  rewrite eqM; rewrite eqN; auto.
Qed.

Hint Resolve confStepPreservesVariant : StackSafety.

Ltac frob x :=
  rewrite (idTrace_eq x); simpl.

Ltac extract_mpstep :=
  match goal with
  | [H : mpstep ?MP = Some (?M, ?P, ?O) |- _ ] =>
    match goal with
    | [ H'  : step (ms MP) = _ , H'' : pstep MP = _
        |- _ ] => fail 1
    | _ => 
      unfold mpstep in H;
      let m' := fresh "m" in
      let o' := fresh "o" in
      let MStep := fresh "MStep" in
      let PStep := fresh "PStep" in
      destruct (step (ms MP)) as [m' o'] eqn:MStep;
      destruct (pstep MP) eqn:PStep;
      inversion H; subst; clear H;
      assert (H: mpstep MP = Some (M, P, O))
        by (unfold mpstep; rewrite MStep; rewrite PStep; auto)
    end
  end.

Ltac rewriteHyp :=
  match goal with
    | [ H : _ |- _ ] => rewrite H by solve [ auto ]
  end.

Hint Constructors Last : StackSafety.

Ltac last_reasoning :=
  match goal with
  | [ H : Last (finished _) _ |- _ ] => inversion H; subst; clear H
  | [ H : Last (notfinished _ _ ) _ |- _ ] => inversion H; subst; clear H
  end.

Lemma NotLastProgress {A} : forall (M : TraceOf A) m m',
    ~ Last (notfinished m M) m' -> ~ Last M m'.
Proof.
  intros. intro.
  eapply H.
  constructor; auto.
Qed.

Hint Resolve NotLastProgress : StackSafety.

Ltac inv H := (pinversion H || inversion H); subst; clear H.

Ltac frobber F :=
  match goal with
  | [ |- context[(F ?T)] ] =>
    match goal with
    | [ |- context[notfinished _ (F T)] ] => fail 1
    | _ => frob (F T); simpl
    end
  end.

(** Run [f] on every element of [ls], not just the first that doesn't fail. *)
Ltac all f ls :=
  match ls with
    | (?LS, ?X) => f X; all f LS
    | (_, _) => fail 1
    | _ => f ls
  end.

(* Invert a particular symbol. *)
Ltac invert F :=
  match goal with 
  | [ H : F _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ _ _ |- _ ] => inv H; simpl in *
  | [ H : F _ _ _ _ _ |- _ ] => inv H; simpl in *
  end.

Ltac induct F :=
  match goal with 
  | [ H : F _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ _ _ |- _ ] => induction H; subst; clear H; simpl in *
  | [ H : F _ _ _ _ _ |- _ ] => induction H; subst; clear H; simpl in *
  end.

Ltac destruct_observations :=
  match goal with
  | |- context[notfinished Tau _] => idtac
  | |- context[notfinished (Out _) _] => idtac
  | |- context[notfinished ?O _] => destruct O
  end.

Ltac simplifications :=
  match goal with
  | [ |- _ /\ _ ] => split
  | [H : _ \/ _ |- _ ] => destruct H
  | [H : _ /\ _ |- _ ] => destruct H
  | [H : exists x, _ |- _] => destruct H
  end.

Ltac conf_progress :=
  repeat progress (try all frobber (ObsTraceOf, ObsTraceOfM);
                   try extract_mpstep;
                   try rewriteHyp;
                   try last_reasoning;
                   try destruct_observations;
                   try simplifications
                  ).

Ltac seauto :=
  try intros; try pfold;
  eauto 10 with core paco StackSafety;
  try solve [exfalso; eauto 10 with core paco StackSafety].

Lemma StrongConfImpliesObsEq_Ret :
  forall C R MP MV,
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV ->
    forall mpret,
      Last MP mpret -> R (ms mpret) ->
      (ObsTraceOf MP) ~=_O (ObsTraceOfM MV).
Proof.
  pcofix COFIX.
  intros; invert StrongEagerStackConfidentiality; conf_progress; seauto.
Qed.

Lemma StrongConfImpliesObsEq_Fault :
  forall C R MP MV,
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV ->
    forall mpret,
      Last MP mpret -> ~ (R (ms mpret)) ->
      (ObsTraceOf MP) <=_O (ObsTraceOfM MV).
Proof.  
  pcofix COFIX.
  intros; invert StrongEagerStackConfidentiality; conf_progress; seauto.
Qed.  
Hint Transparent not : StackSafety.

Hint Unfold not : StackSafety.
Lemma StrongConfImpliesObsEq_Inf :
  forall C R MP MV,
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV ->
    (forall mpret, ~ Last MP mpret) ->
    ObsTraceEq (ObsTraceOf MP) (ObsTraceOfM MV).
Proof.
  unfold not; pcofix COFIX.
  intros; invert StrongEagerStackConfidentiality; conf_progress; seauto.
  (* RB: TODO: Fix tactics to apply Paco lemmas and solve last case. Naive hints
     on constructors of Paco generators do not work as well: after [pfold]ing, a
     constructor can be applied, but before another can be applied the resulting
     [upaco] must pick its left disjunct, that is, the corecursive [paco] (not
     not the parametric relation on the right) and [pfold] it again. *)
  constructor. left. pfold. constructor. seauto.
Qed.

Lemma ComponentConfTrans :
  forall (M0 M1 M2 N0 N1 N2 : MachineState),
    (forall k : Component, M1 k <> M0 k \/ N1 k <> N0 k -> M1 k = N1 k) ->
    (forall k : Component, M1 k <> M2 k \/ N1 k <> N2 k -> M2 k = N2 k) ->
    (forall k : Component, M0 k <> M2 k \/ N0 k <> N2 k -> M2 k = N2 k).
Proof.
  intros M0 M1 M2 N0 N1 N2 H01 H12.
  intros k [HM02 | HN02].
  - destruct (WordEqDec (M2 k) (M1 k)) as [eqM | neqM].
    + assert (M1 k <> M0 k) as HM01.
      { intros Contra.
        apply HM02.
        rewrite Contra in eqM.
        auto.
      }
      specialize (H01 k (or_introl HM01)).
      destruct (WordEqDec (N2 k) (N1 k)) as [eqN | neqN].
      * rewrite eqM; rewrite eqN; auto.
      * apply H12; eauto.
    + eapply H12; eauto.
  - destruct (WordEqDec (N2 k) (N1 k)) as [eqN | neqN].
    + assert (N1 k <> N0 k) as HN01.
      { intros Contra.
        apply HN02.
        rewrite Contra in eqN.
        auto.
      }
      specialize (H01 k (or_intror HN01)).
      destruct (WordEqDec (M2 k) (M1 k)) as [eqM | neqM].
      * rewrite eqM; rewrite eqN; auto.
      * apply H12; eauto.
    + eapply H12; eauto.
Qed.

(*
Lemma StrongConfImpliesCotermination :
  forall C R MP MV,
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV ->
    (exists mpret, IsEnd MP mpret) <-> (exists mvret, IsEnd MV mvret).
Proof.
  intros C R MP MV Var Conf; split.
  - intros [mpret HEnd].
    generalize dependent MV.
    induction HEnd; subst; eauto; intros MV Var Conf;
    inversion Conf; subst; eauto; clear Conf; simpl in *.
    + exists m.
      constructor.
    + exists m. constructor.
    + destruct (IHHEnd M'); eauto using confStepPreservesVariant.
      exists x; constructor; eauto.
  - intros [mvret HEnd].
    generalize dependent MP.
    induction HEnd; subst; eauto; intros MP Var Conf;
    inversion Conf; subst; eauto; clear Conf; simpl in *.
    + exists mp.
      constructor.
    + exists mp; constructor.
    + destruct (IHHEnd MP0); eauto using confStepPreservesVariant.
      exists x; constructor; eauto.
Qed.
 *)

Lemma StrongConfImpliesIndist_Ret :
  forall C R MP MV,
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV ->
    (forall mpret, Last MP mpret -> R (ms mpret) ->
      (exists mret, Last MV mret /\
                     forall k, 
                       (ms (head MP) k <> ms mpret k \/ (head MV) k <> mret k) ->
                       ms mpret k = mret k)).
Proof.
  intros C R MP MV Var Conf mpret HLast HR.
  generalize dependent MV.
  induction HLast; subst; eauto; intros MV Var Conf;
  pinversion Conf; subst; eauto; clear Conf; simpl in *.
  - exists m; split; [constructor|].
    intros k Hk.
    inversion Hk; exfalso; eauto.
  - exfalso; eauto.
  - destruct (IHHLast HR M') as [mret [HLastMret HConf]];
      eauto using confStepPreservesVariant.
    exists mret; split.
    + constructor; auto.
    + intros k Hk.
      eauto using ComponentConfTrans.

(*
  intros. generalize dependent MV.
  induct (@Last MPState); seauto.
  invert StrongEagerStackConfidentiality; seauto.
  - eexists; repeat (conf_progress; seauto).
  - edestruct (IHLast H2 MV) as [? [? ?]]; seauto.
    eapply confStepPreservesVariant; seauto.
    conf_progress; seauto.
*)  
      
Qed.

Lemma StrongConfImpliesInf_Inf : 
  forall C R MP MV,
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV ->
    (forall mpret, ~ Last MP mpret) ->
    (forall mv, ~ Last MV mv).
Proof.
  unfold not.
  intros; generalize dependent MP.
  induct (@Last MachineState); intros; 
  invert StrongEagerStackConfidentiality;
  conf_progress; seauto.
Qed.

Theorem StrongConfImpliesConf (C: Contour) (R: MachineState -> Prop) (MP : MPTrace) :
  (forall (MV : MTrace),
    variantOf (ms (head MP)) (head MV) C ->
    StrongEagerStackConfidentiality R MP MV) ->
  EagerStackConfidentiality C MP R.
Proof.
  intros Conf.
  unfold EagerStackConfidentiality.
  intros mv MV HVar HPre.
  specialize (Conf MV).
  assert (head MV = mv) as HN
      by (erewrite <- PrefixUpToHead; eauto; auto).
  rewrite <- HN in HVar.
  specialize (Conf HVar).
  split; [|split].
  - intros mpret HLast HR; split.
    + eapply StrongConfImpliesIndist_Ret; eauto.
    + eapply StrongConfImpliesObsEq_Ret; eauto.
  - intros mpret HLast HNotR.
    eapply StrongConfImpliesObsEq_Fault; eauto.
  - intros HNotLast mvret'. split.
    * eapply StrongConfImpliesInf_Inf; eauto.
    * eapply StrongConfImpliesObsEq_Inf; eauto.
Qed.        


Definition updateContour (C: Contour) (args: nat) (m: MachineState) : Contour :=
  fun k =>
    match k with
    | Mem a =>
      let a' := wminus (m (Reg SP)) args in
      if wle a a' then
        (HC, HI)
      else if andb (wlt a' a) (wle a (m (Reg SP))) then
        (LC, LI)
      else if wlt (m (Reg SP)) a then
        (HC, LI)
      else C k (* impossible *)
    | _ => C k
    end.

(* LEO: TODO: Instruction memory should be tagged LC HI *)
(* SNA: Since we never actually use the old contour in updateContour,
   I made this for FindCall, below. (Importantly, if we did use the old contour,
   newer versions of subtrace would be wrong.) *)
Definition makeContour (args : nat) (m : MachineState) : Contour :=
  fun k =>
    match k with
    | Mem a =>
      let a' := wminus (m (Reg SP)) args in
      if wle a a' then
        (HC, HI)
      else if andb (wlt a' a) (wle a (m (Reg SP))) then
        (LC, LI)
      else (*if wlt (M (Reg SP)) a then*)
        (HC, LI)
    | _ => (LC, LI)
    end.

(*
CoInductive Subtrace (cm: CallMap) : Contour -> MTrace -> Contour -> MTrace -> Prop :=
  | SubNow : forall C C' MM MM' args,
      (* Current instruction is a call *)
      isCall cm (head MM) args ->
      (* Take the prefix until a return *)
      LongestPrefix (fun M => ~ (isRet (head MM) M)) MM MM' ->
      (* Construct the new contour *)
      updateContour C args (head MM) = C' ->
      Subtrace cm C MM C' MM'
  | SubNotNow: forall C MM C' MM' M,
      (forall args, ~ isCall cm (head MM) args) ->
      Subtrace cm C MM C' MM' ->
      Subtrace cm C (notfinished M MM) C' MM'
  | SubSkipCall : forall C MM C' MMskip args MM' MM'',
      isCall cm (head MM) args ->
      TraceSpan (fun M => ~ (isRet (head MM) M)) MM MMskip (Some MM')  ->
      Subtrace cm C MM' C' MM'' ->
      Subtrace cm C MM C' MM''.
 *)
(* Make this "Make Contour" *)
(*
CoInductive Subtrace (cm: CallMap) : Contour -> MTrace -> Contour -> MTrace -> Prop :=
  | SubNow : forall C C' MM MM' args,
      (* Current instruction is a call *)
      isCall cm (head MM) args ->
      (* Take the prefix until a return *)
      LongestPrefix (fun M => ~ (isRet (head MM) M)) MM MM' ->
      (* Construct the new contour *)
      updateContour C args (head MM) = C' ->
      Subtrace cm C MM C' MM'
  | SubNotNow: forall C MM C' MM' M,
      Subtrace cm C MM C' MM' ->
      Subtrace cm C (notfinished M MM) C' MM'.
*)
(* APT+SNA: rather than two subtraces, with and without suffix, we could just
   find the starts of calls and then take prefixes/suffixes when we need them.
   Also we don't really need to update contours so much as just generate them
   from the state. *)
Inductive FindCall_gen (cm: CallMap) R :
  MTrace -> Contour -> MTrace -> Prop :=
  | FindCallNow : forall C MM MM' args,
      (* Current instruction is a call *)
      isCall cm (head MM) args ->
      (* Construct the contour *)
      makeContour args (head MM) = C ->
      FindCall_gen cm R MM C MM'
  | FindCallLater: forall C MM MM' M,
      R MM C MM' ->
      FindCall_gen cm R (notfinished M MM) C MM'.
Hint Constructors FindCall_gen : core.

Definition FindCall (cm : CallMap) (M : MTrace) (C : Contour) (M' : MTrace) :=
  paco3 (FindCall_gen cm) bot3 M C M'.
Hint Unfold FindCall : core.
Lemma FindCall_mon cm : monotone3 (FindCall_gen cm). Proof. pmonauto. Qed.
Hint Resolve FindCall_mon : paco.

(* SNA: FindCall via SplitInclusive turns out to work well with other lemmas *)               
Inductive FindCallMP (cm: CallMap) : MPTrace -> Contour -> MPTrace -> Prop :=
| NextCall : forall C MP MPpre MPsuff args,
    SplitInclusive (fun mp => isCall cm (ms mp) args) MP MPpre MPsuff ->
    makeContour args (ms (head MPsuff)) = C ->
    FindCallMP cm MP C MPsuff
| LaterCall : forall C C' mp MP MP' MPsuff MPcall,
    FindCallMP cm MP C MPsuff ->
    MPsuff = notfinished mp MP' ->
    FindCallMP cm MP' C' MPcall ->
    FindCallMP cm MP C' MPcall.

(* TODO: Write find call MP coinductively, prove equiv? *)

(*
CoInductive StackSafety (cm : CallMap) : MTrace -> Contour -> Prop :=
  ss : forall (MM : MTrace) (C : Contour),
       (StackIntegrity C MM) ->
       (StackConfidentiality C MM) ->
       (forall MM' C', Subtrace cm C MM C' MM' -> StackSafety cm MM' C') ->
       StackSafety cm MM C.
 *)

(* SNA: Changed this so that it can include the return, which helps with my proofs
   and doesn't seem to break anyone else's. *)
Definition EagerStackSafety (cm : CallMap) : MPTrace -> Contour -> Prop :=
  fun (MP : MPTrace) (C : Contour) =>
    (EagerStackIntegrity C MP) /\
    (EagerStackConfidentiality C MP (fun _ => False)) /\
    (forall (MPpre' MP' : MPTrace) C',
        FindCallMP cm MP C' MP' -> (* Find call*)
        PrefixUpTo (fun mp => isRet (ms (head MP')) (ms mp)) MP' MPpre' ->
        EagerStackIntegrity C' MPpre' /\
        EagerStackConfidentiality C' MPpre' (isRet (ms (head MPpre')))).

Definition EagerStackSafety'' (cm : CallMap) : Prop :=
  forall m,
    let initC := makeContour 0 m in
    let p := initPolicyState m cm in
    (EagerStackConfidentiality' initC (m,p) (fun _ => False)) /\
    (forall (mp : MPState) C,
        FindCallMP cm (MPTraceOf (m,p)) C (MPTraceOf mp) -> (* Find call*)
        EagerStackIntegrity'' C mp (isRet (ms mp)) /\
        EagerStackConfidentiality' C mp (isRet (ms mp))).

Definition EagerStackSafety' (cm : CallMap) (m : MachineState) :=
  let initC := makeContour 0 m in
  let p := initPolicyState m cm in
  let MP := MPTraceOf (m,p) in
  EagerStackSafety cm MP initC.


(* TODO: step by step property that implies the rest *)

(* TODO: Rename this to SafeTrace or something, then write StackSafe
   as a top-level property that either quantifies over all traces (for
   a dynamic analysis) or only over a subset (e.g., those produced by
   a stack-protecting compiler). *)

(***** TESTING Property **********)
(* Note: This enforces lockstep due to PC equality.
   TODO: How not to enforce lockstep? *)

Definition EagerIntegrityTest (C : Contour) (M M' : MachineState) : Prop :=
  forall (k : Component), integrityOf (C k) = HI -> M k = M' k.

Hint Unfold EagerIntegrityTest : StackSafety.

Definition EagerConfidentialityTest (isRet : MachineState -> Prop)
           (M M' N N' : MachineState) (OM ON : Observation) : Prop :=
  OM = ON /\
  forall (k : Component),  M k <> M' k \/ N k <> N' k -> M' k = N' k.

Hint Unfold EagerConfidentialityTest : StackSafety.

(* Elements of the Variant Stack. *)
Record VSE := {
  init_machine : MachineState;
  init_variant : MachineState;
  curr_variant : MachineState;
  contour : Contour;
  retP : MachineState -> Prop
}.

Definition upd_curr (mv : MachineState) (vse : VSE) : VSE :=
  {| init_machine := init_machine vse;
     init_variant := init_variant vse;
     curr_variant := mv;
     contour := contour vse;
     retP := retP vse
  |}.

Definition VSE_step (vse : VSE) :=
  match step (curr_variant vse) with
  | (mv',_) => upd_curr mv' vse
  end.

Definition VarStack := list VSE.

Definition VSEs_step (vs : VarStack) := map VSE_step vs.

Inductive FinLast {A : Type} : A -> list A -> Prop :=
| FLastSing : forall x, FinLast x [x]
| FLastTail : forall x h t, FinLast x t -> FinLast x (h::t).

Hint Constructors FinLast : StackSafety.

Lemma FinLast_unique {A : Type} (x x' : A) (l : list A) :
  FinLast x l -> FinLast x' l -> x = x'.
Proof.
  intro H; induction H; intro HLast; inversion HLast; subst; clear HLast; eauto;
    match goal with
    | [ H : FinLast _ [] |- _ ] => inversion H
    end.
Qed.

Hint Resolve FinLast_unique : StackSafety.

Lemma FinLast_singleton {A : Type} (x x' : A) :
  FinLast x [x'] -> x = x'.
Proof.
  intros H. inversion H; easy.
Qed.

Hint Resolve FinLast_singleton : StackSafety.

Inductive FinLastN {A} : nat -> list A -> list A -> Prop :=
| FinLastNow : forall n l, length l = n -> FinLastN n l l
| FinLastLater : forall n x xs l, FinLastN n xs l -> FinLastN n (x::xs) l.

Lemma FinLastN_length {A} : forall n (L l : list A), FinLastN n L l -> length l = n.
Proof.
  intros n L l H; induction H; eauto.
Qed.

Lemma FinLastN_length2 {A} : forall n (L l : list A), FinLastN n L l -> length L >= n.
Proof.
  intros n L l H; induction H; eauto.
  - rewrite H; apply le_n.
  - simpl.
    apply le_S.
    eauto.
Qed.


Lemma FinLastN_unique {A : Type} n (l l' L : list A) :
  FinLastN n L l -> FinLastN n L l' -> l = l'.
Proof.
  intros H.
  generalize dependent l'.
  induction H; intros l' H';
  inversion H'; subst; clear H'; simpl in *; eauto.
  - apply FinLastN_length2 in H0; omega.
  - apply FinLastN_length2 in H; omega.
Qed.

Lemma VSEs_step_preserves_length: forall vs vs', VSEs_step vs = vs' ->
                                  forall n, length vs = n -> length vs' = n.
Proof.
  intros.
  unfold VSEs_step in *.
  rewrite <- H.
  rewrite <- H0.
  apply map_length; eauto.
Qed.
  
Lemma VSE_step_preserves_LastN :
  forall n VS vs, FinLastN n VS vs ->
  forall VS' vs', 
    VSEs_step vs = vs' ->
    VSEs_step VS = VS' ->
    FinLastN n VS' vs'.
Proof.
  intros n Vs vs H; induction H; intros VS' vs' SV Sv.
  - rewrite SV in Sv; subst; eapply FinLastNow; eapply VSEs_step_preserves_length; eauto.
  - inversion Sv; subst; simpl in *.
    eapply FinLastLater.
    eapply IHFinLastN; eauto.
Qed.    
    
Lemma VSE_step_preserves_in :
  forall vse vs vs' mv' O,
    In vse vs ->
    VSEs_step vs = vs' ->
    step (curr_variant vse) = (mv',O) ->
    In (upd_curr mv' vse) vs'.
Proof.
  intros vse vs vs' mv' O HIn HForall HStep.
  rewrite <- HForall.
  apply in_map_iff.
  exists vse.
  split; auto.
  unfold VSE_step. rewrite HStep.
  auto.
Qed.

Hint Resolve VSE_step_preserves_in : StackSafety.

Lemma map_preserves_last :
  forall {A B} (f : A -> B)  x l, FinLast x l -> FinLast (f x) (map f l).
Proof.
  intros A B f x l H; induction H; simpl in *; seauto.
Qed.

Lemma VSE_step_preserves_last :
  forall vse vse' vs vs',
    FinLast vse vs ->
    VSEs_step vs = vs' ->
    VSE_step vse = vse' ->
  FinLast vse' vs'.
Proof.
  intros vse vse' vs vs' HLast HVS HVSE.
  rewrite <- HVS.
  unfold VSEs_step.
  rewrite <- HVSE.
  apply map_preserves_last; auto.
Qed.

Hint Resolve VSE_step_preserves_last : StackSafety.

Corollary VSE_step_preserves_last' :
  forall vse vses vses' N' O,
    FinLast vse vses ->
    VSEs_step vses = vses' ->
  step (curr_variant vse) = (N',O) ->
  FinLast (upd_curr N' vse) vses'.
Proof.
  intros; eapply VSE_step_preserves_last; eauto.
  unfold VSE_step. rewriteHyp. auto.
Qed.  

Hint Resolve VSE_step_preserves_last' : StackSafety.

Lemma FinLast_implies_In {A : Type} (x : A) (l : list A) :
  FinLast x l -> In x l.
Proof.
  intros Last; induction Last.
  - left; auto.
  - right; auto.
Qed.

Hint Resolve FinLast_implies_In : StackSafety.

Lemma FinLastNHead_implies_In {A} (x : A) n L l :
  FinLastN n L l -> hd_error l = Some x -> In x L.
Proof.
  intros H; induction H; intros; eauto.
  - destruct l; eauto.
    + inversion H0; eauto.
    + inversion H0; subst; left; eauto.
  - right; eauto.
Qed.
    

(* Well-formedness conditions on the stack with respect to a current MS. *)
Definition WellFormedVS (M : MachineState) (vs : VarStack) : Prop :=
  (* The curr_variant field is a variant of the current state. *)
  Forall (fun vse => variantOf M (curr_variant vse) (contour vse)) vs /\
  (* The stack is nonempty and the last retP is const False *)
  (exists vse, FinLast vse vs /\ retP vse = fun _ => False) /\
  (* The current state is in the trace of *every* init machine. *)
  (Forall (fun vse => InTrace M (MTraceOf (init_machine vse))) vs) /\
  (* The variant state is in the trace of its own init variant. *)
  (Forall (fun vse => InTrace (curr_variant vse) (MTraceOf (init_variant vse))) vs).

Hint Unfold WellFormedVS : StackSafety.

(* Indexed Stack Safety Test to signify when a return should finish a trace. *)
Inductive EagerStackSafetyTest_gen (cm : CallMap) R
  : nat -> MPTrace -> VarStack -> Prop :=
| EagerTestFinFault :
    forall depth mp vs,
      WellFormedVS (ms mp) vs ->
      mpstep mp = None ->
      EagerStackSafetyTest_gen cm R depth (finished mp) vs
| EagerTestFinRet :
    forall depth mp vse vs,
      WellFormedVS (ms mp) (vse :: vs) ->
      length (vse :: vs) = depth ->
      retP vse (ms mp) ->
      EagerStackSafetyTest_gen cm R depth (finished mp) vs
| EagerTestStep :
    forall depth mp MP vs vs' m' p' OM,
      (* Not a call or a return *)
      (forall args, ~ isCall cm (ms mp) args) ->
      (forall vse, In vse vs -> ~ (retP vse (ms mp))) ->
      (* Take a step. *)
      mpstep mp = Some (m', p', OM) ->
      WellFormedVS (ms mp) vs ->
      (* Enforce confidentiality for each variant. *)
      (forall vse,
          In vse vs ->
          exists mv' OV, step (curr_variant vse) = (mv', OV) /\
          EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' OM OV) ->
      (* Enforce integrity for main trace, but for each possible level in NCRs? *)
      (forall vse,
          In vse vs ->
          EagerIntegrityTest (contour vse) (ms mp) m') ->
      (* Step all variants and just recurse *)
      VSEs_step vs = vs' ->
      head MP = (m',p') ->
      R depth MP vs' ->
      (* Conclude for current. *)
      EagerStackSafetyTest_gen cm R depth (notfinished mp MP) vs
| EagerTestCall :
    forall depth args mp MP vs vs' m' p' OM C,      
      (* Is a call *)
      isCall cm (ms mp) args ->
      (* Also need it to NOT be a return *)
      (forall vse, In vse vs -> ~ (retP vse (ms mp))) ->      
      (* Take a step. *)
      mpstep mp = Some (m', p', OM) ->
      WellFormedVS (ms mp) vs ->
      (* Enforce confidentiality for each variant. *)
      (forall vse,
          In vse vs ->
          exists mv' OV, step (curr_variant vse) = (mv', OV) /\
          EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' OM OV) ->
      (* Enforce integrity for main trace, but for each possible level in NCRs? *)
      (forall vse,
          In vse vs ->
          EagerIntegrityTest (contour vse) (ms mp) m') ->
      (* Step all variants. *)
      VSEs_step vs = vs' ->
      head MP = (m', p') ->
      (* Calculate the new contour based on the top of the current machine. *)
      (* LEO: TODO: Current machine, or HEAD MP? *)
      makeContour args (ms mp) = C ->
      (* Recurse with every variant at the new contour at the top. *)
      (forall mvar, variantOf (ms (head MP)) mvar C ->
                    R depth MP
                      ({| init_machine := ms mp
                          ; init_variant := mvar
                          ; curr_variant := mvar
                          ; contour := C
                          ; retP := isRet (ms mp)
                       |} :: vs')) ->
      (* Conclude for current. *)
      EagerStackSafetyTest_gen cm R depth (notfinished mp MP) vs
| EagerTestRet :
    forall depth mp MP vs vs' m' p' OM,          
      (* Is a return *)
      (* isCall cm M args -> *)
      (exists vse vsrest, vs = vse :: vsrest  /\ retP vse (ms mp) /\ depth <= length vsrest) ->
        (* (forall N C R, In (N,C,R) NCRs -> ~ R M) -> *)
      (* Take a step. *)
      mpstep mp = Some (m', p', OM) ->
      WellFormedVS (ms mp) vs ->
      (* Enforce confidentiality for each variant. *)
      (forall vse,
          In vse vs ->
          exists mv' OV, step (curr_variant vse) = (mv', OV) /\
          EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' OM OV) ->
      (* Enforce integrity for main trace, but for each possible level in NCRs? *)
      (forall vse,
          In vse vs ->
          EagerIntegrityTest (contour vse) (ms mp) m') ->
      (* Step all variants. *)
      VSEs_step vs = vs' ->
      head MP = (m',p') ->
      (* Recurse but take of the top of the stack. *)
      R depth MP (tl vs') ->
      (* Conclude for current. *)
      EagerStackSafetyTest_gen cm R depth (notfinished mp MP) vs.
Hint Constructors EagerStackSafetyTest_gen : core.

Definition EagerStackSafetyTest
           (cm : CallMap) (depth : nat) (MP : MPTrace) (vs : VarStack) :=
  paco3 (EagerStackSafetyTest_gen cm) bot3 depth MP vs.
Hint Unfold EagerStackSafetyTest : core.
Lemma EagerStackSafetyTest_mon cm : monotone3 (EagerStackSafetyTest_gen cm). Proof. pmonauto. Qed.
Hint Resolve EagerStackSafetyTest_mon : paco.

Definition EagerStackSafetyTest' cm C MP :=
  forall mv, variantOf (ms (head MP)) mv C ->
             EagerStackSafetyTest cm 1 MP [Build_VSE (ms (head MP)) mv mv C (fun _ => False)].

Hint Unfold EagerStackSafetyTest' : StackSafety.

Ltac in_reasoning :=
  repeat match goal with
         | [ H : In _ [] |- _ ] => inversion H
         | [ H : In _ [_] |- _ ] => inversion H; subst; clear H
         | [ H : (_,_,_,_) = (_,_,_,_) |- _ ] => inversion H; subst; clear H
         end.

Ltac progress_integrity :=
  repeat match goal with
         | [ H : WellFormedVS ?M ?VS |- _ ] =>
           destruct H as [HVar [[vse_last' [HLast' HRet]] [HMTrace HNTrace]]]
         | [ H1 : Last ?X ?L, H2 : Last ?Y ?L |- _ ] =>
           assert (Y = X) by (eapply FinLast_unique; eauto); subst; clear H2
         end.

Ltac int_progress' :=
  (try all frobber (ObsTraceOf, ObsTraceOfM);
   try extract_mpstep;   
   try rewriteHyp;
   try last_reasoning;
   try simplifications
  ).

Ltac int_progress := repeat progress int_progress'.

Inductive MStepCompatible_gen R : MTrace -> Prop :=
| MCompStep :
    forall m M o,
      step m = (head M, o) ->
      R M ->
      MStepCompatible_gen R (notfinished m M).
Hint Constructors MStepCompatible_gen : core.

Definition MStepCompatible (M : MTrace) :=
  paco1 MStepCompatible_gen bot1 M.
Hint Unfold EagerStackSafetyTest : core.
Lemma MStepCompatible_mon : monotone1 MStepCompatible_gen. Proof. pmonauto. Qed.
Hint Resolve MStepCompatible_mon : paco.

Lemma MTraceOf_Compatible : forall m, MStepCompatible (MTraceOf m).
Proof.
  pcofix COFIX.
  intros m; pfold; frobber MTraceOf.
  destruct (step m) as [m' o] eqn:Step.
  eapply MCompStep; eauto.
Qed.    

Lemma InMTrace_Compatible : forall m M, InTrace m M ->
                      MStepCompatible M ->
                      forall m' o', step m = (m',o') ->
                      InTrace m' M.
Proof.
  intros m M H; induction H; intros Comp m'' o'' MStep.
  - pinversion Comp.
  - apply In_later.
    pinversion Comp; subst; eauto.
    rewrite H1 in MStep. inv MStep. pinversion H2; subst; auto.
    destruct H2; simpl; constructor.
  - apply In_later. eapply IHInTrace; eauto.
    pinversion Comp; eauto.
Qed.

Corollary InMTrace_step : forall m m0, InTrace m (MTraceOf m0) ->
                      forall m' o', step m = (m',o') ->
                      InTrace m' (MTraceOf m0).
Proof.
  intros; eapply InMTrace_Compatible; eauto using MTraceOf_Compatible.
Qed.

Inductive MPStepCompatible_gen (R : MachineState -> Prop) Rcoind : MPTrace -> Prop :=
| CompError :
    forall mp, mpstep mp = None -> MPStepCompatible_gen R Rcoind (finished mp)
| CompRet :
    forall mp, R (ms mp) -> MPStepCompatible_gen R Rcoind (finished mp)
| CompStep :
    forall mp MP,
      (exists o, mpstep mp = Some (ms (head MP), ps (head MP), o)) ->
      ~ (R (ms mp)) ->
      Rcoind MP ->
      MPStepCompatible_gen R Rcoind (notfinished mp MP).
Hint Constructors MPStepCompatible_gen : core.

Definition MPStepCompatible (R : MachineState -> Prop) (MP : MPTrace) :=
  paco1 (MPStepCompatible_gen R) bot1 MP.
Hint Unfold MPStepCompatible : core.
Lemma MPStepCompatible_mon R : monotone1 (MPStepCompatible_gen R). Proof. pmonauto. Qed.
Hint Resolve MPStepCompatible_mon : paco.

Lemma variantOf_id C m : variantOf m m C.
Proof.
  unfold variantOf. reflexivity.
Qed.

Theorem TestImpliesIntegrityNested :
  forall cm C MP vs n vscall vse,
         FinLastN n vs vscall ->
         hd_error vscall = Some vse ->
         contour vse = C ->
         MPStepCompatible (retP vse) MP ->
  EagerStackSafetyTest cm n MP vs -> EagerStackIntegrity' C MP.
Proof.
  pcofix COFIX.
  intros cm C MP vs n vscall vse Last Hvse HC HNotR Safety; pfold.
  inv Safety.
  - apply SI_finished.
  - apply SI_finished.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H6; simpl.
      eapply H4; eauto using FinLastNHead_implies_In.
    + right.
      eapply (COFIX cm (contour vse) MP0 (VSEs_step vs) n (VSEs_step vscall) (VSE_step vse)); eauto.
      * eapply VSE_step_preserves_LastN; eauto.
      * destruct vscall; inversion Hvse; subst; simpl; auto.
      * unfold VSE_step; simpl; auto.
        destruct (step (curr_variant vse)); simpl; auto.
      * unfold not; intros; pfold; eauto.
        pinversion HNotR; subst; auto.
        unfold VSE_step; simpl; destruct (step (curr_variant vse)); auto.
        simpl.
        eapply paco1_unfold with (x0 := MP0); eauto with paco.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H6; simpl.
      eauto using FinLastNHead_implies_In.
    + remember (Build_VSE (ms mp) (ms (head MP0)) (ms (head MP0)) (makeContour args (ms mp)) (isRet (ms mp))) as vse_call.
      right.
      apply (COFIX cm (contour vse) MP0 (vse_call::(VSEs_step vs)) n (VSEs_step vscall) (VSE_step vse)); eauto.
      * eapply FinLastLater.
        eapply VSE_step_preserves_LastN; eauto.
      * destruct vscall; inversion Hvse; subst; simpl; auto.
      * unfold VSE_step; simpl; auto.
        destruct (step (curr_variant vse)); simpl; auto.
      * unfold not; intros; eauto.
        unfold VSE_step.
        destruct (step (curr_variant vse)); auto.
        pinversion HNotR; subst; auto.
      * pfold. rewriteHyp.
        specialize (H8 (ms (head MP0)) (variantOf_id _ _)).
        destruct H8 as [H8 | H8]; [| easy].
        (* RB: TODO: Revisit similar cases to try to simplify like so: *)
        punfold H8.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H5.
      eauto using FinLastNHead_implies_In.
    + right.
      apply (COFIX cm (contour vse) MP0 (tl (VSEs_step vs)) n (VSEs_step vscall) (VSE_step vse)); auto.
      * destruct vs; simpl in *.
        -- inversion Last; subst; simpl in *; try solve [constructor]; eauto.
        -- inversion Last; subst; simpl in *; eauto.
           ++ inversion Hvse; subst; simpl in *.
              destruct H as [vseC [vsrest [Eq [Hret Hd]]]].
              exfalso.
              inversion Eq; subst.
              pinversion HNotR; subst; auto.
           ++ eapply VSE_step_preserves_LastN; eauto.
      * destruct vscall; inversion Hvse; subst; eauto.
      * unfold VSE_step; simpl; auto.
        destruct (step (curr_variant vse)); simpl; auto.
      * unfold not; intros; eauto.
        pinversion HNotR; subst; auto.
        unfold VSE_step; destruct (step (curr_variant vse)); simpl; auto.
Qed.

Lemma FinLastN1_FinLast : forall {A} (l : list A) x,
    FinLastN 1 l [x] -> FinLast x l.
Proof.
  intros.
  remember 1.
  remember [x].
  generalize dependent x.
  induction H; intros; subst; seauto.
Qed.

Lemma FinLast_FinLastN1 : forall {A} (l : list A) x,
    FinLast x l -> FinLastN 1 l [x].
Proof.
  intros.
  induction H.
  - constructor; simpl; auto.
  - constructor; eauto.
Qed.

(*
Lemma EagerTestTermination :
  forall cm MP vs, EagerStackSafetyTest cm MP vs ->
  forall vse, FinLast vse vs ->
  forall mp, InTrace mp MP -> 
             ~ retP vse (ms mp) \/ mpstep mp = None.
Proof.
  intros.
  induction H1; inversion H; subst; simpl in *; eauto.
  - left; eauto using FinLast_implies_In.
  - left; eauto using FinLast_implies_In.
  - 
    *)

Corollary TestImpliesIntegrityToplevel :
  forall cm C MP vs,
    MPStepCompatible (fun _ => False) MP ->
    (exists vse, FinLast vse vs /\ contour vse = C) ->
    EagerStackSafetyTest cm 1 MP vs -> EagerStackIntegrity' C MP.
Proof.
  intros cm C MP vs Comp Last Safety.
  destruct Last as [vse [Last HC]].
  eapply TestImpliesIntegrityNested with (n:=1) (vscall := [vse]); eauto.
  - eapply FinLast_FinLastN1; eauto.
  - simpl; auto.
  - pfold.
    invert EagerStackSafetyTest.
    + constructor; auto.
    + apply CompRet; auto.
      destruct vs; simpl in *.
      * inversion Last.
      * congruence.
    + destruct H2 as [Var [[vse' [Last' Ret]] [InM InV]]] eqn:wf.
      assert (vse = vse') by (eapply FinLast_unique; eauto).
      pinversion Comp; subst; eauto.
      constructor; eauto; rewrite Ret; auto.
    + destruct H2 as [Var [[vse' [Last' Ret]] [InM InV]]] eqn:wf.
      assert (vse = vse') by (eapply FinLast_unique; eauto).
      subst.
      pinversion Comp; subst; eauto.
      constructor; eauto; rewrite Ret; auto.
    + destruct H1 as [Var [[vse' [Last' Ret]] [InM InV]]] eqn:wf.
      assert (vse = vse') by (eapply FinLast_unique; eauto).
      subst.
      pinversion Comp; subst; eauto.
      constructor; eauto; rewrite Ret; auto.
Qed.

(*
Theorem TestImpliesIntegrityToplevel :
  forall cm C MM vs,
    (exists vse, FinLast vse vs /\ contour vse = C) ->
  EagerStackSafetyTest cm MM vs -> EagerStackIntegrity' C MM.
Proof.
  cofix COFIX.
  intros cm C MP vs [vse_last [HLast HC]] Safety.
  inversion Safety; subst.
  - apply SI_finished.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H6; simpl.
      eauto using FinLast_implies_In.
    + apply (COFIX cm (contour vse_last) MP0 vs'); auto.
      unfold VSEs_step in *.
      destruct (H3 vse_last (FinLast_implies_In vse_last vs HLast))
        as [N' [ON [HN' HConf]]].
      exists (upd_curr N' vse_last); split; auto.
      eapply VSE_step_preserves_last'; eauto.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H5.
      eauto using FinLast_implies_In.
    + apply (COFIX cm (contour vse_last) MP0 ((Build_VSE (ms mp) (ms (head MP0)) (ms (head MP0)) (makeContour args (ms mp)) (isRet (ms mp)))::vs')).
      * unfold VSEs_step in *.
        destruct (H2 vse_last)
          as [N' [ON [HN' HConf]]]; eauto using FinLast_implies_In.
        exists (upd_curr N' vse_last); split; auto.
        right; eauto using VSE_step_preserves_last.
      * apply H7.
        unfold variantOf.
        intros k Hk.
        auto.
  - apply SI_notfinished; progress_integrity.
    + intros k Hk.
      unfold MPState, EagerIntegrityTest in *.
      rewrite H5.
      eauto using FinLast_implies_In.
    + apply (COFIX cm (contour vse_last) MP0 (tl vs')); auto.
      unfold VSEs_step in *.
      destruct (H2 vse_last)
        as [N' [ON [HN' HConf]]]; eauto using FinLast_implies_In.
      destruct vs.
      * inversion H4; subst.
        inversion HLast.
      * simpl in *.
        destruct vs'; inversion H4; subst; clear H4; simpl in *.
        inversion HLast; subst; clear HLast; eauto using VSE_step_preserves_last.
        { destruct H as [vse [vserest [Contra Contra']]].
          + subst.
            inversion HLast'; subst.
            * inversion Contra; subst.
              rewrite HRet in Contra'.
              inversion Contra'.
            * inversion H4.
        }
Qed.
*)


(*
Ltac extract_mpstep :=
  match goal with
  | [H : mpstep ?MP = Some (?M, ?P, ?O) |- _ ] =>
    unfold mpstep in H;
    let m' := fresh "m" in
    let o' := fresh "o" in
    let MStep := fresh "MStep" in
    let PStep := fresh "PStep" in
    destruct (step (ms MP)) as [m' o'] eqn:MStep;
    destruct (pstep MP) eqn:PStep;
    inversion H; subst; clear H;
    assert (H: mpstep MP = Some (M, P, O))
      by (unfold mpstep; rewrite MStep; rewrite PStep; auto)
  end.
*)                       
Lemma VSE_step_preserves_WellFormed :
  forall vs mp, WellFormedVS (ms mp) vs ->
  forall m' p' o', mpstep mp = Some (m', p', o') ->
  forall vs', VSEs_step vs = vs' ->
  (forall vse : VSE,
       In vse vs ->
       exists (mv' : MachineState) (OV : Observation),
         step (curr_variant vse) = (mv', OV) /\
         EagerConfidentialityTest (retP vse) (ms mp) m' (curr_variant vse) mv' o' OV) ->
  WellFormedVS m' vs'.              
Proof.
  intro vs; induction vs; intros mp WF m' p' o' MPStep vs' Step Conf.
  - inversion Step; subst.
    destruct WF as [Var [[vse [Last Ret]] [InM InV]]] eqn:wf.
    inversion Last.
  - inversion Step; subst.
    destruct WF as [Var [[vse [Last Ret]] [InM InV]]] eqn:wf.
    extract_mpstep.    
    inversion Var; inversion Last; inversion InM; inversion InV; subst; simpl in *.
    + inversion H3; subst; clear H3.
(*       inversion H1; subst; clear H1.*)
      repeat split.
      * constructor; simpl in *; eauto.
(*        remember (Build_VSE m0 mv0 mv C R) as vse. *)
        specialize (Conf a (or_introl eq_refl)).
        destruct Conf as [mv'' [ov'' [MVStep [OEq Conf]]]].
        simpl in *.
        rewrite OEq in *.
(*        clear H0; clear H1; clear OEq; clear MVStep. *)
        eapply confStepPreservesVariant; eauto.
        -- unfold VSE_step.
           rewrite MVStep.
           eauto.
        -- intros k Hk.
           unfold VSE_step in *.
           rewrite MVStep in *.
           simpl.
           eapply Conf; eauto.
           destruct Hk; [ left | right ]; eauto.
        -- unfold VSE_step in *; rewrite MVStep; eauto.
      * exists (VSE_step a); split; auto using FLastSing.
        unfold VSE_step in *.
        destruct (step (curr_variant a)); simpl; auto.
      * constructor; simpl in *; eauto.
        eapply InMTrace_step; eauto.
        unfold VSE_step; destruct (step (curr_variant a)); simpl; auto.
      * constructor; simpl in *; eauto.
        unfold VSE_step; destruct (step (curr_variant a)) eqn:S; simpl; eauto.
        destruct H; eapply InMTrace_step; eauto.
    + repeat split.
      * constructor; simpl in *; eauto.
        -- eapply confStepPreservesVariant; eauto.
           ++ specialize (Conf a (or_introl eq_refl)).
              unfold VSE_step in *; simpl in *.           
              destruct Conf as [mv'' [ov'' [MVStep [OEq Conf]]]].
              simpl in *.
              rewrite MVStep; eauto.
              rewrite OEq in *; eauto.
           ++ intros k Hk.
              unfold VSE_step in *; simpl in *.
              destruct (Conf a (or_introl eq_refl)) as [mv'' [ov'' [MVStep [OEq Conf']]]].
              rewrite MVStep in *; simpl in *.
              eapply Conf'.
              destruct Hk; [left | right]; eauto.
           ++ intros k Hk.
              unfold VSE_step in *; simpl in *.
              destruct (Conf a (or_introl eq_refl)) as [mv'' [ov'' [MVStep [OEq Conf']]]].
              rewrite MVStep in *; simpl in *.
              unfold variantOf in H2.
              eapply H2; eauto.
        -- eapply IHvs; eauto.
           repeat split; eauto.
      * destruct (step (curr_variant vse)) as (mv'', ov'') eqn:Step_vse.
        exists (upd_curr mv'' vse).
        split; subst; simpl; auto.
        apply FLastTail.
        eapply VSE_step_preserves_last; eauto.
        unfold VSE_step in *; simpl in *.
        rewrite Step_vse; auto.
      * constructor; simpl in *; eauto.
        -- eapply InMTrace_step; eauto.
           unfold VSE_step in *; simpl.
           destruct (step (curr_variant a)); simpl; auto.
        -- eapply IHvs; eauto.
           repeat split; eauto.
      * destruct (step (curr_variant a)) eqn:S; simpl; eauto.           
        constructor; simpl in *; eauto.
        -- unfold VSE_step in *.
           rewrite S; simpl in *.
           eapply InMTrace_step; eauto.
        -- eapply IHvs; eauto.
           repeat split; eauto.
Qed.

Lemma well_formed_extend :
  forall M vse vs,
    WellFormedVS M vs ->
    variantOf M (curr_variant vse) (contour vse) ->
    InTrace M (MTraceOf (init_machine vse)) ->
    InTrace (curr_variant vse) (MTraceOf (init_variant vse)) ->
    WellFormedVS M (vse :: vs).
Proof.
  intros M vse vs [H1 [[vse' [HLast HR]] [H3 H4]]] Var InM InV.
  repeat split; try solve [constructor; eauto].
  exists vse'; split; eauto using FLastTail.
Qed.

Lemma FinLastN_depth : forall {A} n (x : A) (xs l : list A), 
  FinLastN n (x :: xs) l -> n <= length xs -> FinLastN n xs l.
Proof.
  intros A n x xs l H.
  remember (x :: xs) as L.
  generalize dependent xs.
  generalize dependent x.
  induction H; intros y ys Eq Len.
  - rewrite Eq in H. simpl in *.
    destruct n; inversion H; subst; auto.
    omega.
  - simpl in *.
    inversion Eq; subst; eauto.
Qed.    

(*
Lemma preserve...
(forall vs, (exists vse, FinLast vse vs /\ contour vse = C) ->
                WellFormedVS (ms (head MP)) vs ->
                EagerStackSafetyTest cm MP vs)
     *)

Lemma hd_error_map : forall {A B} (f : A -> B) l x,
    hd_error l = Some x -> hd_error (map f l) = Some (f x).
Proof.
  intros A B f l x H; induction l; simpl in *. 
  - congruence.
  - inversion H; subst; auto.
Qed.
    
Theorem TestImpliesConfidentialityNested :
  forall cm C MP vs n vscall vse,
    FinLastN n vs vscall ->
    hd_error vscall = Some vse ->
    contour vse = C ->
    MPStepCompatible (retP vse) MP ->
    WellFormedVS (ms (head MP)) vs ->
    EagerStackSafetyTest cm n MP vs ->
    variantOf (ms (head MP)) (curr_variant vse) C ->
    StrongEagerStackConfidentiality (fun _ => False) MP (MTraceOf (curr_variant vse)).
Proof.
  pcofix COFIX.
  intros cm C MP vs n vscall vse LastN hCall HC Comp [HVar [[vselast [HLast RFalse]] [InMP InVar]]] Safety Var;
    pfold.
  destruct MP.
  - apply StrongConfNotMStep.
    intros Contra. inversion Contra.
  - destruct (step (curr_variant vse)) as [mv' o'] eqn:StepV.
    pinversion Comp; subst; clear Comp.
    match goal with
    | [H : exists _, _ |- _] => destruct H as [o MPStep]
    end.
    frobber MTraceOf.
    extract_mpstep.
    pinversion Safety; subst; clear Safety.
    + destruct (H7 vse) as [mv'' [ov [VStep VConf]]];
        eauto using FinLastNHead_implies_In.
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      rewrite HO in *; auto; clear HO.
      rewrite MPStep in H5; inversion H5; subst; auto.
      eapply StrongConfStep; simpl in *; eauto.
      * rewriteHyp; simpl; auto.
      * intros k [Diff | Diff]; simpl in *; repeat rewriteHyp; simpl in *; auto.
        -- apply HConf. right; intros Contra.
           rewrite VStep in Diff; simpl in *; exfalso; eauto.
      * rewriteHyp; simpl.
        remember (VSE_step vse) as vse'.
        assert (HMV' : curr_variant vse' = mv')
          by (subst; unfold VSE_step; simpl; rewriteHyp; simpl; auto).
        rewrite <- HMV'.
        right.
        apply (COFIX cm (contour vse) MP (VSEs_step vs) n (VSEs_step vscall) vse');
          eauto.
        -- eapply VSE_step_preserves_LastN; eauto.
        -- unfold VSEs_step; simpl.
           rewriteHyp; apply hd_error_map; auto.
        -- unfold VSE_step in *; repeat rewriteHyp; auto.
        -- rewriteHyp; unfold VSE_step; rewriteHyp; simpl; auto.
        -- (* Safe step preserves wellformed *)
           eapply VSE_step_preserves_WellFormed; eauto.
        -- (* RB: This (easy) goal is no longer discharged by eauto. *)
           destruct H13 as [H13 | H13]; [| easy].
           punfold H13.
        -- repeat rewriteHyp; eapply confStepPreservesVariant; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
    + destruct (H7 vse) as [mv'' [ov [VStep VConf]]];
        eauto using FinLastNHead_implies_In.
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      rewrite HO in *; simpl in *; clear HO.
      rewrite MPStep in H5; inversion H5; subst; auto.
      eapply StrongConfStep; simpl in *; eauto.
      * repeat rewriteHyp; simpl; auto. 
      * intros k [Diff | Diff]; simpl in *; repeat rewriteHyp; simpl in *; auto.
        apply HConf. right; intros Contra.
        rewrite VStep in Diff; simpl in *; exfalso; eauto.
      * (* Recursive call with self variant. *)
        rewriteHyp; simpl.
        remember (VSE_step vse) as vse'.
        assert (HMV' : curr_variant vse' = mv')
          by (subst; unfold VSE_step; simpl; rewriteHyp; simpl; auto).
        rewrite <- HMV'.
        remember (Build_VSE (ms m) (ms (head MP)) (ms (head MP)) (makeContour args (ms m)) (isRet (ms m))) as vse_call.
        right.
        apply (COFIX cm (contour vse) MP (vse_call :: (VSEs_step vs)) n (VSEs_step vscall) vse'); eauto.
        -- constructor; eapply VSE_step_preserves_LastN; eauto.
        -- unfold VSEs_step; simpl.
           rewriteHyp; apply hd_error_map; auto.
        -- unfold VSE_step in *; repeat rewriteHyp; auto.
        -- rewriteHyp; unfold VSE_step; rewriteHyp; simpl; auto.
        -- (* Safe step preserves wellformed *)
          eapply well_formed_extend; eauto.
          ++ eapply VSE_step_preserves_WellFormed; eauto.
          ++ rewrite Heqvse_call; simpl in *; eauto.
             unfold variantOf.
             intros k HK. auto.
          ++ rewrite Heqvse_call; simpl in *; eauto.
             frobber MTraceOf.
             apply In_later.
             frobber MTraceOf.
             rewrite MStep; simpl.
             apply In_now.
          ++ frobber MTraceOf. rewrite Heqvse_call; simpl; apply In_now.
        -- (* RB: This (easy) goal is no longer discharged by eauto. *)
           rewrite Heqvse_call.
           specialize (H14 _ (variantOf_id _ _)).
           destruct H14 as [H14 | H14]; [| easy].
           punfold H14.
        -- repeat rewriteHyp; eapply confStepPreservesVariant; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
    + destruct (H6 vse) as [mv'' [ov [VStep VConf]]];
        eauto using FinLastNHead_implies_In.
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      rewrite HO in *; eauto.
      rewrite MPStep in H4; inversion H4; subst; auto.
      rewriteHyp; simpl.
      eapply StrongConfStep; simpl in *; eauto.
      * intros k [Diff | Diff]; simpl in *; repeat rewriteHyp; simpl in *; auto.
      * (* Recursive call with the tail. *)
        destruct vs as [| vseret vs].
        (* vs is not empty *)
        { inversion HLast. } 

        destruct H1 as [vser [vsrest [Eq [RetR Len]]]].
        inversion Eq; subst; eauto.
        rename vsrest into vs.
        rename vser into vseret.

        remember (VSE_step vse) as vse'.
        assert (HMV' : curr_variant vse' = mv')
          by (subst; unfold VSE_step; simpl; rewriteHyp; simpl; auto).
        rewrite <- HMV'.

        right.
        apply (COFIX cm (contour vse) MP (VSEs_step vs) n (VSEs_step vscall) vse'); eauto.
        -- eapply FinLastN_depth.
           eapply VSE_step_preserves_LastN; unfold VSEs_step; simpl; eauto.
           ++ simpl; eauto.
           ++ unfold VSEs_step; simpl.
              rewrite map_length; auto.
        -- unfold VSEs_step; simpl.
           rewriteHyp; apply hd_error_map; auto.
        -- unfold VSE_step in *; repeat rewriteHyp; auto.
        -- rewriteHyp; unfold VSE_step; rewriteHyp; simpl; auto.
        -- assert (WF : WellFormedVS (ms (head MP)) (VSE_step vseret :: VSEs_step vs)).
           { eapply VSE_step_preserves_WellFormed; eauto. }
           destruct WF as [HVar' [HLast' [HInM' HInV']]].
           repeat split.
           ** inversion HVar'; eauto.
           ** destruct HLast' as [vseL [HPvseL HRetL]]; exists vseL; split; eauto.
              inversion HPvseL; subst; eauto.
              (* Case where we returned from the last stack element,
                 but that can't happen. But this proof is hideous *)
              symmetry in H8.
              unfold VSEs_step in *.
              apply map_eq_nil in H8.
              subst; auto.
              inversion HLast; subst; eauto.
              --- exfalso.
                  rewrite RFalse in RetR.
                  inversion RetR.
              --- inversion H1. 
             ** inversion HInM'; eauto.
             ** inversion HInV'; eauto.
        -- (* RB: Another goal no longer solved by auto. *)
           destruct H12 as [H12 | H12]; [| easy].
           punfold H12.
        -- repeat rewriteHyp. eapply confStepPreservesVariant; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
Qed.

(*
TestImpliesIntegrityToplevel
     : forall (cm : CallMap) (C : Contour) (MP : MPTrace) (vs : list VSE),
       MPStepCompatible (fun _ : MachineState => False) MP ->
       (exists vse : VSE, FinLast vse vs /\ contour vse = C) ->
       EagerStackSafetyTest cm 1 MP vs -> EagerStackIntegrity' C MP
 *)
(*
Corollary TestImpliesConfidentialityToplevel :
  forall cm C MP vs n vse,
    FinLast vse vs ->
    contour vse = C ->
    MPStepCompatible (fun _ => False) MP ->
    WellFormedVS (ms (head MP)) vs ->
    EagerStackSafetyTest cm n MP vs ->
    variantOf (ms (head MP)) (curr_variant vse) C ->
    StrongEagerStackConfidentiality (fun _ => False) MP (MTraceOf (curr_variant vse)).
*)

(*
  
Theorem TestImpliesConfidentialityToplevel :
  forall cm C MP vs,
    MPStepCompatible MP ->
    WellFormedVS (ms (head MP)) vs ->
    EagerStackSafetyTest cm MP vs ->
    (forall mv, (exists vse, FinLast vse vs /\ curr_variant vse = mv /\ contour vse = C) ->
                variantOf (ms (head MP)) mv C ->
                StrongEagerStackConfidentiality (fun _ => False) MP (MTraceOf mv)).
Proof.
  cofix COFIX.
  intros cm C MP vs Comp [HVar [[vse [HLast RFalse]] [InMP InVar]]] Safety mv [vse' [HLast' [HCurr HC]]] Var.
  destruct MP.
  - apply StrongConfNotMStep.
    intros Contra. inversion Contra.
  - destruct (MTraceOf mv) as [mv' | mv' MV] eqn:HMV;
    rewrite (idTrace_eq (MTraceOf mv)) in HMV; simpl in *;
      inversion HMV; subst; clear HMV.
    
    inversion Comp; subst; clear Comp.
    match goal with
    | [H : exists _, _ |- _] => destruct H as [o MPStep]
    end.

    assert (Eq: vse' = vse)
      by (eapply FinLast_unique; eauto); subst; clear HLast'.

    unfold mpstep in MPStep.
    destruct (step (ms m)) as [m' o'] eqn:MStep.
    destruct (pstep m) eqn:PStep; inversion MPStep; subst; clear MPStep.
    destruct (step (curr_variant vse)) as [mv' o'] eqn:StepV.
    
    inversion Safety; subst; clear Safety.
    + destruct (H6 vse) as [mv'' [ov [VStep VConf]]]; eauto using FinLast_implies_In.
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      (* TODO: Make this robust. *)
      rewrite HO in H4; auto.
      unfold mpstep in H4.
      rewrite MStep in H4.
      rewrite PStep in H4.
      inversion H4; subst; clear H4.
      simpl; auto.
      
      eapply StrongConfStep; simpl in *; eauto.
      * unfold mpstep.
        rewrite MStep.
        rewrite PStep.
        auto.
      * intros k [Diff | Diff].
        -- apply HConf.
           left. intros Contra. apply Diff. auto.
        -- apply HConf.
           right.
           intros Contra; auto.
      * apply (COFIX cm (contour vse) MP vs') ; eauto.
        -- (* Safe step preserves wellformed *)
          eapply VSE_step_preserves_WellFormed; eauto.
          unfold mpstep.
          rewrite MStep; rewrite PStep; eauto.
        -- exists (upd_curr mv' vse).
           split; simpl in *; eauto.
           eapply VSE_step_preserves_last; eauto.
        -- eapply confStepPreservesVariant; eauto.
           ++ unfold mpstep; rewrite MStep; rewrite PStep; eauto.
           ++ intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
    + destruct (H5 vse) as [mv'' [ov [VStep VConf]]]; eauto using FinLast_implies_In.
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      (* TODO: Make this robust. *)
      rewrite HO in H3; auto.
      unfold mpstep in H3.
      rewrite MStep in H3.
      rewrite PStep in H3.
      inversion H3; subst; clear H3.
      simpl; auto.
      
      eapply StrongConfStep; simpl in *; eauto.
      * unfold mpstep.
        rewrite MStep.
        rewrite PStep.
        auto.
      * intros k [Diff | Diff].
        -- apply HConf.
           left. intros Contra. apply Diff. auto.
        -- apply HConf.
           right.
           intros Contra; auto.
      * (* Self-variant? *)
        remember (Build_VSE (ms m) (ms (head MP)) (ms (head MP)) (makeContour args (ms m)) (isRet (ms m))) as vse_call.
        apply (COFIX cm (contour vse) MP (vse_call :: vs')); eauto.
        -- (* Safe step preserves wellformed *)
          eapply well_formed_extend; eauto.
          ++ eapply VSE_step_preserves_WellFormed; eauto.
             unfold mpstep.
             rewrite MStep; rewrite PStep; eauto.
          ++ rewrite Heqvse_call; simpl in *; eauto.
             unfold variantOf.
             intros k HK. auto.
          ++ rewrite Heqvse_call; simpl in *; eauto.
             mfrob.
             apply In_later.
             mfrob.
             rewrite MStep; simpl.
             apply In_now.
          ++ mfrob. rewrite Heqvse_call; simpl; apply In_now.
        -- rewrite Heqvse_call; eapply H11.
           intros k HC.
           auto.
        -- exists (upd_curr mv' vse).
           split; simpl in *; eauto.
           constructor.
           eapply VSE_step_preserves_last; eauto; split.
        -- eapply confStepPreservesVariant; eauto.
           ++ unfold mpstep; rewrite MStep; rewrite PStep; eauto.
           ++ intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
    + destruct (H5 vse) as [mv'' [ov [VStep VConf]]]; eauto using FinLast_implies_In.
      rewrite VStep in StepV.
      inversion StepV; subst; clear StepV.
      destruct VConf as [HO HConf].
      (* TODO: Make this robust. *)
      rewrite HO in H3; auto.
      unfold mpstep in H3.
      rewrite MStep in H3.
      rewrite PStep in H3.
      inversion H3; subst; clear H3.
      simpl; auto.
      
      eapply StrongConfStep; simpl in *; eauto.
      * unfold mpstep.
        rewrite MStep.
        rewrite PStep.
        auto.
      * intros k [Diff | Diff].
        -- apply HConf.
           left. intros Contra. apply Diff. auto.
        -- apply HConf.
           right.
           intros Contra; auto.
      * (* Recursive call with the tail. *)
        destruct vs' as [| vseret vs'].
        (* vs is not empty *)
        { inversion H7; subst; inversion HLast. }

        apply (COFIX cm (contour vse) MP vs'); eauto.
        -- assert (WF : WellFormedVS (ms (head MP)) (vseret :: vs')).
           { eapply VSE_step_preserves_WellFormed; eauto.
             unfold mpstep. rewrite MStep. rewrite PStep. reflexivity. } 
           destruct WF as [HVar' [HLast' [HInM' HInV']]].
           repeat split.
           ** inversion HVar'; eauto.
           ** destruct HLast' as [vse' [? ?]]; exists vse'; split; eauto.
              inversion H; subst; eauto.
              (* Case where we returned from the last stack element,
                 but that can't happen. But this proof is hideous *)
              exfalso.
              destruct H1 as [vse0 [vrest0 [Eq Ret]]].
              inversion H7; subst; eauto.
              inversion H9; subst; eauto.
              inversion H12; subst; eauto.
              inversion HLast; subst; eauto.
              --- rewrite RFalse in Ret.
                  inversion Ret.
              --- inversion H13; subst; eauto.
             ** inversion HInM'; eauto.
             ** inversion HInV'; eauto.
        -- 
          destruct H1 as [vse0 [vrest0 [Eq Ret]]].
          inversion H7; subst; eauto.
          inversion H1; subst; eauto.
          inversion HLast; subst; eauto.
          ++ rewrite RFalse in Ret.
             inversion Ret.
          ++ exists (upd_curr mv' vse); split; eauto.
             ** eapply VSE_step_preserves_last; eauto.
        -- eapply confStepPreservesVariant; eauto.
           unfold mpstep; rewrite MStep; rewrite PStep; eauto.
           intros k [Hk | Hk]; eapply HConf; [left | right]; eauto.
Qed.
*)

(*
Lemma MTraceOf_eq M : MTraceOf M = notfinished M (MTraceOf (fst (step M))).
Admitted.

Lemma mpstep_step_some mp m p OM :
  mpstep mp = Some (m, p, OM) -> step (ms mp) = (m, OM).
Proof.
  unfold mpstep.
  destruct (step (ms mp)) as [m' OM'].
  destruct (pstep mp) as [mp' |];
    intros H;
    now inversion H.
Qed.

Lemma In_singleton {A : Type} (x : A) : In x [x].
Proof.
  left. reflexivity.
Qed.

Lemma InTrace_MTraceOf m : InTrace m (MTraceOf m).
Proof.
  rewrite MTraceOf_eq. now apply In_now.
Qed.

Definition StrongEagerStackConfidentiality' (MP : MPTrace) (m : MachineState) :=
  StrongEagerStackConfidentiality (fun _ => False) MP (MTraceOf m).

Goal
  forall (cm : CallMap) (MP : MPTrace) (C : Contour),
    EagerStackSafetyTest' cm C MP ->
  forall (m : MachineState),
    variantOf (ms (head MP)) m C ->
    (* StrongEagerStackConfidentiality' MP m. *)
    StrongEagerStackConfidentiality (fun _ => False) MP (MTraceOf m).
Proof.
  cofix CH.
  intros cm MP C Htest n Hvariant.
  specialize (Htest n Hvariant).
  inversion Htest
    as [ mp' vs' Hwf
       | mp MP' ? vs' m' p' OM Hcall Hret Hstep Hwf Hconf Hint Hvssteps Hhead Htest'
       | |];
    subst; clear Htest;
    (* Give a name to the variant so as to keep the context clean and readable. *)
    try match goal with
    | H : WellFormedVS _ [?VSE] |- _ => remember VSE as vse eqn:Hvse
    end.
  - now apply StrongConfNotMStep.
  - rewrite MTraceOf_eq.
    specialize (Hconf _ (In_singleton vse)) as [n' [OM' [Hstep' Hconf]]].
    specialize (Hret _ (In_singleton vse)).
    specialize (Hint _ (In_singleton vse)).
    rewrite Hvse in Hstep'. simpl in Hstep'.
    destruct Hconf as [HOM Hvary]; subst OM'. (* EagerConfidentialityTest *)
    rewrite Hstep'. simpl.
    apply StrongConfStep with OM.
    + rewrite Hstep.
      now setoid_rewrite Hhead.
    + now rewrite Hstep'.
    + (* Proof tree repeats below. *)
      setoid_rewrite Hhead. simpl.
      intros k Hvary'.
      specialize (Hvary k).
      apply Hvary.
      destruct Hvary' as [Hvary' | Hvary'].
      * left. now auto.
      * rewrite Hvse. simpl.
        right. now auto.
    + apply CH with cm C.
      * intros n_ Hvariant_.
        destruct MP' as [mp' | mp' MP'].
        -- apply EagerTestHalt.
           split; [| split; [| split]].
           ++ constructor; [| now constructor].
              simpl. now apply Hvariant_.
           ++ match goal with
              | |- exists _, FinLast _ [?VSE] /\ _ => exists VSE
              end.
              split.
              ** now constructor.
              ** reflexivity.
           ++ constructor; [| now constructor].
              simpl. now apply InTrace_MTraceOf.
           ++ constructor; [| now constructor].
              simpl. now apply InTrace_MTraceOf.
        -- simpl.
           inversion Hvssteps as [| v1 vse' l1 l2 Hvsstep HForall2 Heq Hcons];
             subst v1 l1.
           inversion HForall2; subst l2 vs'; clear Hvssteps HForall2.
           rewrite Hvse in Hvsstep.
           inversion Hvsstep as [m1 m2 m3 n'_ C1 R [OM' Hstep'_]];
             subst m1 m2 m3 C1 R vse'.
           rewrite Hstep' in Hstep'_.
           inversion Hstep'_; subst n'_ OM'; clear Hstep'_ Hvsstep.
           simpl in Hhead; subst mp'.
           destruct mp as [m p]. simpl in *.

           (* Print EagerStackSafetyTest. *)

      * eapply confStepPreservesVariant;
          [ setoid_rewrite Hhead; now apply Hstep
          | now rewrite Hstep'
          |
          | now apply Hvariant].
        -- (* Same subproof as above. *)
           admit.
  -
*)

(* ********* SNA Beware : Lazy Properties ********* *)

(* Since eager property protects everything that is HI,
   an integrity rollback restores all HI components. *)
Definition RollbackInt (C: Contour) (Mstart Mend : MachineState) : MachineState :=
  fun k => match integrityOf (C k) with
           | HI => Mstart k
           | _ => Mend k
           end.

Definition LazyReturnMP (justReturned : MachineState -> Prop) (MP MPpre : MPTrace) (MPsuffO : option MPTrace) :=
  (exists MPsuff, MPsuffO = Some MPsuff /\ SplitInclusive (fun mp => justReturned (ms mp)) MP MPpre MPsuff)
  \/ (ForallTrace (fun mp => ~ (justReturned (ms mp))) MP /\ TraceEq MP MPpre /\ MPsuffO = None).

Definition LazyReturnM (justReturned : MachineState -> Prop) (M Mpre : MTrace) (MsuffO : option MTrace) :=
  (exists Msuff, MsuffO = Some Msuff /\ SplitInclusive justReturned M Mpre Msuff)
  \/ (ForallTrace (fun m => ~ (justReturned m)) M /\ TraceEq M Mpre /\ MsuffO = None).

(* Observable properties take a contour and a trace, with an optional additional trace.
   The contour C represents the security levels for trace MM, and MMOouter is the
   execution following after MM when C no longer applies. *)
Definition ObservableIntegrity (C:Contour) (MP:MPTrace) (MPsuffO:option MPTrace) : Prop :=
 match MPsuffO with
 | Some actual =>
   let ideal := MTraceOf (RollbackInt C (ms (head MP)) (ms (head actual))) in
   ((exists mpfin, Last actual mpfin) -> (ObsTraceOf actual) <=_O (ObsTraceOfM ideal)) /\
   ((forall mp, ~ Last actual mp) -> ObsTraceEq (ObsTraceOf actual) (ObsTraceOfM ideal))
 | None => True
 end.

Definition ObservableIntegrity' (C:Contour) (mp:MPState) (justReturned:MachineState -> Prop) : Prop :=
  forall MPpre MPsuff,
    SplitInclusive (fun mp => justReturned (ms mp)) (MPTraceOf mp) MPpre MPsuff ->
    let M' := MTraceOf (RollbackInt C (ms mp) (ms (head MPsuff))) in
    (exists mpfin, Last MPsuff mpfin) -> ObsTraceOf MPsuff <=_O (ObsTraceOfM M') /\
    ((forall mpfin, ~ Last MPsuff mpfin) -> (ObsTraceEq (ObsTraceOf MPsuff) (ObsTraceOfM M'))).

(* A confidentiality rollback aims to undo a variation, so it restores the values of the
   original, unvaried state. But if the varied values were overwritten after they were varied,
   the changes should be kept. Otherwise we are building in some integrity. *)
Definition RollbackConf (Mstart Mend M'start M'end : MachineState) : MachineState :=
  fun k => if weq (Mstart k) (Mend k) && weq (M'start k) (M'end k) && negb (weq (Mstart k) (M'start k))
           then Mstart k
           else M'end k.

(* MP is a callee's trace that terminates when/if control has just returned to the caller
   according to justReturned. MPsuffO is the trace of the caller starting when control has
   just returned to it, or None if MP does not return, either due to nontermination or
   because it is cut short by a monitor fault.
   In a top level trace justReturned will never hold. *)
Definition ObservableConfidentiality (C : Contour) (MP:MPTrace) (MPsuffO:option MPTrace)
           (justReturned : MachineState -> Prop) :=
  forall m' M' M'suffO,
    (* If m' is a variant of the initial state of MP... *)
    variantOf (ms (head MP)) m' C ->
    (* If the trace from m' return control to the caller at some state,
       M'pre is its prefix up to and including that state,
       and M'suffO is the (non-empty) trace of the caller starting at that state
       (with the caller's memory still varied.)
       If the trace from m' does not return control, M'pre is the whole
       trace and M'suffO is None. *)
    LazyReturnM justReturned (MTraceOf m') M' M'suffO ->

    let O := (ObsTraceOf MP)^(option_map ObsTraceOf MPsuffO) in
    (* Here are the three cases from EagerConf: *)

    (* 1. The callee ends successfully with a return. *)
    (forall MPsuff,
        MPsuffO = Some MPsuff ->
       (* Previously: forall mpret, Last MP mpret ->
                      justReturned (ms mpret) -> 
          But these should fall out of LazyReturnMP *)

        (* Then M'pre also terminates in some state, which is at the head of M'suff.
           And we rollback the head of M'suff to undo the variation and get its trace. *)
        (exists M'suff M'roll,
              M'suffO = Some M'suff /\
              M'roll = MTraceOf (RollbackConf (ms (head MP)) (ms (head MPsuff)) m' (head M'suff)) /\
              let O' := (ObsTraceOfM M') ^ Some (ObsTraceOfM M'roll) in
              (* Two sub-cases: either MPsuffO is an infinite trace,
                 or it stops short due to the monitor. In the first
                 case it should produce the same observation trace as M'suff,
                 in the latter a prefix. *)
              ((exists mpfin, Last MPsuff mpfin) -> O <=_O O') /\
              (* Above exists is superfluous, but demonstrates that these are disjoint cases *)
              ((forall mpfin, ~(Last MPsuff mpfin)) -> ObsTraceEq O O'))) /\

    (* 2. The callee is cut short by a monitor fault. *)
    (forall mpret, Last MP mpret -> (* mpstep mpret = None -> *)
                   ~ justReturned (ms mpret) ->
     (* Then: 
        - The observations of the MP trace are a prefix of the 
          observations of M'.
      *)
     (ObsTraceOf MP) <=_O (ObsTraceOfM M')) /\
    
    (* 3. The callee trace never returns. *) 
    ((forall mpret, ~ Last MP mpret) ->
     (* Then: 
        - The variant trace never returns.
        - The observations of MP and M' are the same. 
      *)
     forall mret', ~ Last M' mret' /\
                   ObsTraceEq (ObsTraceOf MP) (ObsTraceOfM M')).

Definition ObservableConfidentiality' (C : Contour) (mp:MPState) (justReturned : MachineState -> Prop) : Prop :=
  forall m' MPpre MPsuffO M'pre M'suffO,
    variantOf (ms mp) m' C ->
    LazyReturnMP justReturned (MPTraceOf mp) MPpre MPsuffO ->
    LazyReturnM justReturned (MTraceOf m') M'pre M'suffO ->
    let O := (ObsTraceOf MPpre)^(option_map ObsTraceOf MPsuffO) in
    (forall MPsuff,
        MPsuffO = Some MPsuff ->
        (exists M'suff M'roll,
            M'suffO = Some M'suff /\
            M'roll = MTraceOf (RollbackConf (ms mp) (ms (head MPsuff)) m' (head M'suff)) /\
            let O' := (ObsTraceOfM M'pre) ^ Some (ObsTraceOfM M'roll) in
            ((exists mpfin, Last MPsuff mpfin) -> O <=_O O') /\
            ((forall mpfin, ~ Last MPsuff mpfin) -> ObsTraceEq O O'))) /\
    (forall mpfin, Last MPpre mpfin ->
                   ~ justReturned (ms mpfin) ->
                   ObsTraceOf MPpre <=_O ObsTraceOfM M'pre) /\
    ((forall mpfin, ~ Last MPpre mpfin) ->
     forall m'fin, ~ Last M'pre m'fin /\
                   ObsTraceEq (ObsTraceOf MPpre) (ObsTraceOfM M'pre)).

Definition LazyStackSafety (cm : CallMap) (MP:MPTrace) : Prop :=
  ObservableConfidentiality (makeContour 0 (ms (head MP))) MP None (fun _ => False) /\
  (forall MPcall MPpre C' MPsuffO,
    FindCallMP cm MP C' MPcall ->
    LazyReturnMP (fun m => isRet (ms (head MPcall)) m) MPcall MPpre MPsuffO ->
    ObservableIntegrity C' MPpre MPsuffO /\
    ObservableConfidentiality C' MPpre MPsuffO (isRet (ms (head MPcall)))).

Definition LazyStackSafety' (cm : CallMap) : Prop :=
  forall m,
    let initC := makeContour 0 m in
    let p := initPolicyState m cm in
    ObservableConfidentiality' initC (m,p) (fun _ => False) /\
    (forall mp C,
      FindCallMP cm (MPTraceOf (m,p)) C (MPTraceOf mp) ->
      ObservableIntegrity' C mp (isRet (ms mp)) /\
      ObservableConfidentiality' C mp (isRet (ms mp))).

(* More conjectural stuff follows. *)

(* This is meant to rollback in all of the cases that either an integrity or a confidentiality
   rollback would. If a component is HI, it should always be rolled back; if HC but LI, it
   should be rolled back only if it kept the value of its variant. *)
(*Definition RollbackCI (C: Contour) (Mstart Nstart Nend : MachineState) : MachineState :=
  RollbackInt C Mstart (RollbackConf Mstart Nstart Nend).

Definition ObservableConfidentegrity (C:Contour) (MP:MPTrace) (MPsuffO:option MPTrace) (isRet:MachineState -> Prop) :=
  forall n N NO,
    variantOf (ms (head MP)) n C ->
    TraceSpan (fun n' => ~ isRet n') (MTraceOf n) N NO ->
    let actual := MP ^ MPsuffO in
    let ideal := N ^ (option_map (fun N' => MTraceOf (RollbackCI C (ms (head MP)) n (head N'))) NO) in
    (ObsTraceOf actual) <=_O (ObsTraceOfM ideal).

Definition LazyStackSafety' (cm : CallMap) (MP:MPTrace) : Prop :=
  ObservableConfidentegrity (makeContour 0 (ms (head MP))) MP None (fun _ => False) /\
  (forall MP' MP'' C' MPsuffO, FindCall cm (mapTrace ms MP) C' (mapTrace ms MP') ->
                          TraceSpan (fun mp => ~isRet (ms (head MP')) (ms mp)) MP' MP'' MPsuffO ->
                          ObservableConfidentegrity C' MP'' MPsuffO (isRet (ms (head MP'')))).    *)

Lemma MTraceOfHead :
  forall m,
    head (MTraceOf m) = m.
Proof.
  intros. rewrite (idTrace_eq (MTraceOf m)). simpl. auto.
Qed.

Lemma isRet_dec :
  forall m1 m2,
    isRet m1 m2 \/ ~isRet m1 m2.
Proof.
  unfold isRet. intros.
  destruct (WordEqDec (m2 (Reg PC)) (wplus (m1 (Reg PC)) 4)).
  - destruct (WordEqDec (m2 (Reg SP)) (m1 (Reg SP))).
    + left; rewrite e, e0; auto. 
    + right. intros [H1 H2]. rewrite H2 in n; apply n; auto.
  - right. intros [H1 H2].  rewrite H1 in n; apply n; auto.
Qed.

Lemma MapTraceHead :
  forall MP,
    head (mapTrace ms MP) = ms (head MP).
Proof.
  intros. destruct MP; simpl; auto.
Qed.

(* APT: I thought some of these might be approachable if we change to this
definition but I couldn't actually make any of the proofs go through. *)
(* Definition RealMPTrace' (MP:MPTrace) : Prop := 
  TraceEq MP (MPTraceOf (head MP)).*)

CoInductive RealMPTrace'_gen R : MPState -> MPTrace -> Prop :=
| RMP0 : forall mp, pstep mp = None -> RealMPTrace'_gen R mp (finished mp)
| RMP1 : forall mp MP p', pstep mp = Some p' ->
                       R (fst (step (ms mp)), p') MP ->
                       RealMPTrace'_gen R mp (notfinished mp MP).
Hint Constructors RealMPTrace'_gen : core.

Definition RealMPTrace' (mp : MPState) (MP : MPTrace) :=
  paco2 RealMPTrace'_gen bot2 mp MP.
Hint Unfold RealMPTrace' : core.
Lemma RealMPTrace'_mon : monotone2 RealMPTrace'_gen. Proof. pmonauto. Qed.
Hint Resolve RealMPTrace'_mon : paco.

Lemma MPTraceOfHead: forall mp, mp = head (MPTraceOf mp).
Proof.
  intros. destruct mp.  simpl. 
  destruct (pstep (m,p)); auto.
Qed.

Definition RealMPTrace'' MP := TraceEq MP (MPTraceOf (head MP)).

(* Ltac inv H := (pinversion H || inversion H); subst; clear H. *)

Lemma RealMPTrace'Same : forall m MP, RealMPTrace' m MP ->
                                    TraceEq MP (MPTraceOf m).
Proof.
 pcofix COFIX.
 intros m mp H; pfold.
 inv H.
 - rewrite idTrace_eq; simpl.
   rewrite H0.
   constructor.
 - rewrite idTrace_eq; simpl.
   rewrite H0.
   constructor.
   right. eapply COFIX; eauto.
Qed.

Lemma RealMPTrace'Eq : forall m MP,
    RealMPTrace' m MP ->
    forall MP1,
      TraceEq MP MP1 ->
      RealMPTrace' m MP1. 
Proof.
  pcofix COFIX.
  intros m MP H MP1 H0; pfold.
  inv H.
  - destruct MP1. 
    + inv H0. constructor; auto.
    + inv H0.
  - destruct MP1.       
    + inv H0. 
    + inv H0. 
      econstructor; eauto.
Qed.

Lemma RealMPTrace''Same : forall MP, RealMPTrace'' MP -> RealMPTrace' (head MP) MP. 
Proof.
  unfold RealMPTrace''.
  intro MP.
  remember (head MP) as m0.
  generalize dependent m0.
  generalize dependent MP.
  pcofix COFIX.
  intros MP m0 Heqm0 H; pfold.
  rewrite idTrace_eq in H. simpl in H.
  destruct MP as [m | m MP'] eqn:?.
  - destruct (pstep m0) eqn:?.
    + pinversion H.
    + subst m0. constructor; auto.
  - destruct (pstep m0) eqn:?.
    + inv H.
      econstructor; eauto.
      simpl.
      set (mp' := (fst (step (ms m)), p)).
      simpl in *. 
      right. apply COFIX.
      * erewrite TraceEqHead.
        apply MPTraceOfHead. auto.
      * auto.
    + pinversion H.
Qed.

Lemma RealMPEquiv : forall MP, RealMPTrace'' MP <-> RealMPTrace' (head MP) MP.
Proof.
  split; intros.
  - apply RealMPTrace''Same; auto.
  -  apply RealMPTrace'Same; auto.
Qed.

Lemma SplitSuffixReal' :
  forall P MP1 MP2 MP3,
    SplitInclusive P MP1 MP2 MP3 ->
    RealMPTrace' (head MP1) MP1 ->
    RealMPTrace' (head MP3) MP3.
Proof.
  induction 1; intros; auto. 
  apply IHSplitInclusive.
  pfold.
  simpl in H1.
  inv H1.
  inv H5; econstructor; eauto.
Qed.  

Lemma RealTail' :
  forall mp MP,
    RealMPTrace' mp (notfinished mp MP) ->
    RealMPTrace' (head MP) MP.  
Proof.
  intros mp MP H; pfold.
  inv H.
  destruct MP. 
  - simpl. inv H3. constructor. auto.
  - simpl. inv H3.
    econstructor.  eauto.
    auto.
Qed.

Lemma MPTracePrefixMTrace :
  forall mp m,
     ms mp = m -> 
     ObsTraceOf (MPTraceOf mp) <=_O ObsTraceOfM (MTraceOf m).
Proof.
  pcofix COFIX.
  intros mp m H; pfold.
  destruct mp. simpl in *.  subst.
  rewrite idTrace_eq. pattern (ObsTraceOfM (MTraceOf m)) at 1.  rewrite idTrace_eq.  simpl.
  destruct (pstep (m,p)); simpl.
  - destruct (step m).  simpl.
    destruct o. 
    * constructor. right. apply COFIX. auto.
    * constructor. left. pfold. constructor. right. apply COFIX. auto.
  - destruct (step m). simpl.
    constructor.
Qed.

Lemma MTraceEqInfMPTrace :
  forall mp m,
    ms mp = m ->
    (forall mpfin, ~ (Last (MPTraceOf mp) mpfin)) ->
    ObsTraceEq (ObsTraceOf (MPTraceOf mp)) (ObsTraceOfM (MTraceOf m)).
Proof.
  pcofix COFIX.
  intros mp m H H0; pfold.
  destruct mp. simpl in *. subst.
  rewrite idTrace_eq. rewrite (idTrace_eq (ObsTraceOf (MPTraceOf (m,p)))).  simpl.
  destruct (pstep (m,p)) eqn:?; simpl.
  - destruct (step m) eqn:?.  simpl.
    assert (Q: forall mpfin : MPState, ~ Last (MPTraceOf (m0, p0)) mpfin).
    { intros. intro.
      apply (H0 mpfin).
      rewrite (idTrace_eq (MPTraceOf (m,p))). simpl.
      rewrite Heqo. rewrite Heqp1.  simpl.
      constructor.  auto. }
    destruct o.
    + constructor. right. apply COFIX; auto.
    + constructor. left. pfold. constructor. right. apply COFIX; auto.
  - exfalso. eapply (H0 (m,p)).
    rewrite (idTrace_eq (MPTraceOf (m,p))).  simpl.
    rewrite Heqo.
    constructor.
Qed.

Lemma MPObsLast :
  forall MP mp,
    Last MP mp ->
    Last (ObsTraceOf MP) Tau.
Proof.
  intros. induction H.
  - rewrite (idTrace_eq (ObsTraceOf (finished a))). unfold ObsTraceOf. simpl. constructor.
  - destruct T.
    + rewrite (idTrace_eq (ObsTraceOf (notfinished a' (finished m)))). unfold ObsTraceOf. simpl.
      destruct (step (ms a')). constructor. auto.
    + rewrite (idTrace_eq (ObsTraceOf (notfinished a' (notfinished m T)))). unfold ObsTraceOf. simpl.
      destruct (step (ms a')). constructor. auto.
Qed.

Lemma MObsLast :
  forall M m,
    Last M m ->
    Last (ObsTraceOfM M) Tau.
Proof.
  intros. induction H.
  - rewrite (idTrace_eq (ObsTraceOfM (finished a))). unfold ObsTraceOfM. simpl. constructor.
  - destruct T.
    + rewrite (idTrace_eq (ObsTraceOfM (notfinished a' (finished m)))). unfold ObsTraceOfM. simpl.
      destruct (step a'). constructor. auto.
    + rewrite (idTrace_eq (ObsTraceOfM (notfinished a' (notfinished m T)))). unfold ObsTraceOfM. simpl.
      destruct (step a'). constructor. auto.
Qed.


Lemma ObsTraceOfTraceEq :
  forall MP MP',
    MP ~= MP' ->
    (ObsTraceOf MP) ~= (ObsTraceOf MP').
Proof.
  pcofix COFIX. intros MP MP' H; pfold. inv H.
  - rewrite (idTrace_eq (ObsTraceOf (finished a))).
    unfold ObsTraceOf. simpl. constructor.
  - rewrite (idTrace_eq (ObsTraceOf (notfinished a T1))).
    rewrite (idTrace_eq (ObsTraceOf (notfinished a T2))).
    destruct a. unfold ObsTraceOf. simpl.
    destruct (step m) eqn:?.
    constructor. right. apply COFIX. auto.
Qed.


Lemma MTraceOfInf :
  forall m m',
    ~ Last (MTraceOf m) m'.
Proof.  
  intros m m' H.
  remember (MTraceOf m) as M.
  generalize dependent m.
  induction H; intros m HeqM.
  - rewrite (idTrace_eq (MTraceOf m)) in HeqM.
    simpl in *.
    inversion HeqM.
  - rewrite (idTrace_eq (MTraceOf m)) in HeqM.
    simpl in *.
    inversion HeqM; subst; clear HeqM.
    eapply IHLast; eauto.
Qed.

Lemma FindCallReal :
  forall C MP C' MPcall,
    RealMPTrace'' MP ->
    FindCallMP C MP C' MPcall  ->
    RealMPTrace'' MPcall.
Proof.
  intros. induction H0.
  - apply SplitSuffixReal' in H0; apply RealMPEquiv; auto.
  - apply IHFindCallMP1 in H. rewrite H0 in H. apply RealMPEquiv in H. apply RealTail' in H.
    apply IHFindCallMP2; auto. apply RealMPEquiv. auto.
Qed.

Lemma EagerImpliesLazyInt :
  forall C MPcall MPpre MPsuffO,
    RealMPTrace'' MPcall ->
    LazyReturnMP (fun m => isRet (ms (head MPcall)) m) MPcall MPpre MPsuffO ->
    EagerStackIntegrity C MPpre ->
    ObservableIntegrity C MPpre MPsuffO.
Proof.
  unfold EagerStackIntegrity. unfold ObservableIntegrity. intros.
  destruct MPsuffO as [MPsuff |] eqn:E; auto.
  assert (HSplit : SplitInclusive (fun mp => isRet (ms (head MPcall)) (ms mp)) MPcall MPpre MPsuff).
  { unfold LazyReturnMP in H0. destruct H0.
    - destruct H0 as [MPsuffAgain]. destruct H0. inversion H0. eauto.
    - destruct H0. destruct H2. discriminate. }
  assert (InTrace (head MPsuff) MPpre).
  {  apply SplitInclusiveIsInclusive in HSplit. apply LastInTrace in HSplit. auto. }
  assert (forall k, integrityOf (C k) = HI -> (ms (head MPpre)) k = (ms (head MPsuff)) k).
  { intros. apply H1; auto. }
  assert (RollbackInt C (ms (head MPpre)) (ms (head MPsuff)) = (ms (head MPsuff))).
  { unfold RollbackInt. extensionality k. destruct (integrityOf (C k)) eqn:E2.
    - apply H3; auto.
    - auto. }
  rewrite H4. assert (RealMPTrace'' MPsuff).
  { apply RealMPEquiv. apply RealMPEquiv in H.
    apply (SplitSuffixReal' (fun mp => isRet (ms (head MPcall)) (ms mp)) MPcall MPpre MPsuff); auto. }
  pose (mp := head MPsuff). unfold RealMPTrace'' in H5.
  replace (head MPsuff) with mp; auto. replace (head MPsuff) with mp in H5; auto.
  assert (ObsTraceEq (ObsTraceOf MPsuff) (ObsTraceOf (MPTraceOf mp))).
  { apply ObsTraceOfTraceEq in H5. apply TraceEqImpliesObsTraceEq. auto. }
  split.
  - intros. apply (ObsPrefOverEq (ObsTraceOf (MPTraceOf mp)) (ObsTraceOf MPsuff)).
    + apply ObsTraceOfTraceEq. apply TraceEqSym. auto.
    + apply (MPTracePrefixMTrace mp (ms mp) (* mpfin*)). auto.
  - intros. auto.
    apply (ObsEqOverEq (ObsTraceOf (MPTraceOf mp)) (ObsTraceOf MPsuff) (ObsTraceOfM (MTraceOf (ms mp)))).
    + apply ObsTraceOfTraceEq. symmetry. auto.
    + apply MTraceEqInfMPTrace; auto. unfold not. intros. 
      specialize H7 with mpfin. apply TraceEqSym in H5.
      apply (LastTraceEq (MPTraceOf mp) MPsuff) in H8; auto.
Qed.

Lemma EagerImpliesLazyInt' :
  forall C mp justReturned,
    EagerStackIntegrity'' C mp justReturned ->
    ObservableIntegrity' C mp justReturned.
Proof.
  unfold EagerStackIntegrity''. unfold ObservableIntegrity'. intros C mp justReturned H MPpre MPsuff HSplit.
  assert (forall k, integrityOf (C k) = HI -> (ms mp) k = (ms (head MPsuff)) k).
  { intros. specialize H with MPpre (head MPsuff) k. apply H; auto.
    - unfold PrefixUpTo. left. exists MPsuff. auto.
    - apply SplitInclusiveIsInclusive in HSplit. auto. }
  assert (RollbackInt C (ms mp) (ms (head MPsuff)) = (ms (head MPsuff))).
  { unfold RollbackInt. extensionality k. destruct (integrityOf (C k)) eqn:E2.
    - apply H0; auto.
    - auto. }
  rewrite H1.
  pose (mp' := head MPsuff). assert (RealMPTrace'' MPsuff).
  { apply RealMPEquiv.
    apply (SplitSuffixReal' (fun mp => justReturned (ms mp)) (MPTraceOf mp) MPpre MPsuff); auto.
    apply RealMPEquiv. unfold RealMPTrace''. rewrite <- (MPTraceOfHead mp). apply TraceEqRefl. }
  split.
  - apply (ObsPrefOverEq (ObsTraceOf (MPTraceOf mp')) (ObsTraceOf MPsuff)).
    + apply ObsTraceOfTraceEq. apply TraceEqSym. apply H2.
    + apply (MPTracePrefixMTrace mp' (ms (head MPsuff)) (* mpfin*)). auto.
  - intros. auto.
    apply (ObsEqOverEq (ObsTraceOf (MPTraceOf mp')) (ObsTraceOf MPsuff)).
    + apply ObsTraceOfTraceEq. symmetry. auto.
    + apply MTraceEqInfMPTrace; auto. unfold not. intros. 
      specialize H4 with mpfin. apply TraceEqSym in H2.
      apply (LastTraceEq (MPTraceOf mp') MPsuff) in H5; auto.
Qed.

Lemma EagerImpliesLazyConf :
  forall C MPcall MPpre MPsuffO justReturned,
    RealMPTrace'' MPcall ->
    LazyReturnMP justReturned MPcall MPpre MPsuffO ->
    EagerStackConfidentiality C MPpre justReturned ->
    ObservableConfidentiality C MPpre MPsuffO justReturned.
Proof.
  unfold EagerStackConfidentiality. unfold ObservableConfidentiality. intros. split;try split.

  - (* this is case 1 *)
    intros. destruct H0.
    2: { destruct H0. destruct H5. rewrite H6 in H4. discriminate. }
    destruct H0 as [MPsuffAgain]. destruct H0 as [H0 HSplit].
    assert (MPsuffAgain = MPsuff). { rewrite H0 in H4; inversion H4; auto. }
    specialize H1 with m' M'.
    (* so assert right off the bat that M' returns *)
    
    assert (HM'sEx : exists M'suff, M'suffO = Some M'suff /\ SplitInclusive justReturned (MTraceOf m') M' M'suff).
    { destruct H3.
      - auto.
      - destruct H1; auto.
        + right. destruct H3. destruct H3. split; auto.
        + specialize H1 with (head MPsuff).
          destruct H1.
          * apply SplitInclusiveIsInclusive in HSplit. rewrite H5 in HSplit. auto.
          * apply SplitInclusiveProp in HSplit. rewrite H5 in HSplit. auto.
          * destruct H1 as [mret']. destruct H1. destruct H3. destruct H9.
            apply TraceEqSym in H9.
            eapply LastTraceEq in H1; eauto.
            destruct H6. apply MTraceOfInf in H1. contradiction. }

    destruct HM'sEx as [M'suff HM'sEx]. destruct HM'sEx as [HM'sEx Hsplit'].
    destruct H1;auto.
    + left. exists M'suff. auto.
    + specialize H1 with (head MPsuff).
      * rewrite H5 in HSplit.
        assert (HSplit2 := HSplit). assert (HSplit3 := HSplit).
        apply (SplitInclusiveIsInclusive (fun mp => justReturned (ms mp))) in HSplit2.
        apply SplitInclusiveProp in HSplit. rewrite H0 in H4.
        destruct H1; auto.
        pose (M'roll := MTraceOf (RollbackConf (ms (head MPpre)) (ms (head MPsuff)) m' (head M'suff))).
        exists M'suff. exists M'roll. destruct H1 as [mret'].
        assert (HHeadsEq: ms (head MPsuff) = head M'roll).
        { unfold M'roll. simpl. extensionality k.
          destruct H1 as [Hmret Hksame]. assert (mret' = head M'suff).
          { apply SplitInclusiveIsInclusive in Hsplit'.
            apply (LastUnique mret' (head M'suff) M'); auto. }
          assert (head M' = m').
          { apply SplitInclusiveHead in Hsplit'. rewrite <- Hsplit'. simpl. auto. }
          specialize Hksame with k. rewrite H1 in Hksame. unfold RollbackConf.
          destruct (weq (ms (head MPpre) k) (ms (head MPsuff) k)) eqn:Unchanged; simpl.
          - destruct (weq (m' k) ((head M'suff) k)) eqn:Unchanged'; simpl.
            + destruct (weq (ms (head MPpre) k) (m' k)) eqn:Unvaried; simpl.
              * apply weq_implies_eq in Unchanged.
                apply weq_implies_eq in Unchanged'.
                apply weq_implies_eq in Unvaried.
                rewrite <- Unchanged.
                rewrite Unvaried. auto.
              * apply weq_implies_eq in Unchanged. apply eq_sym. auto.
            + apply not_weq_implies_neq in Unchanged'.
              apply Hksame. right. rewrite H8. auto.
          - apply not_weq_implies_neq in Unchanged.
            apply Hksame. left. auto. }
        assert (HRealsuff : RealMPTrace'' MPsuff).
        { apply RealMPEquiv.
          apply (SplitSuffixReal' (fun mp => justReturned (ms mp)) MPcall MPpre MPsuff); auto.
          apply RealMPEquiv. auto. }
        split; auto. split; auto. rewrite H0. simpl.
        rewrite H5. assert (Last (ObsTraceOf MPpre) Tau).
        { apply (MPObsLast MPpre (head MPsuff)). auto. }
        assert (Last (ObsTraceOfM M') Tau).
        { apply (MObsLast M' (head M'suff)). apply SplitInclusiveIsInclusive in Hsplit'. auto. }
        split.
        -- intro Hfin. destruct Hfin as [mpfin Hfin].          
           apply (MPTracePrefixMTrace (head MPsuff) (head M'roll) (* mpfin *)) in HHeadsEq.
           eapply ObsTracePrefApp'; eauto.
           { apply ObsTraceEq_sym. auto. }
           { apply (ObsPrefOverEq (ObsTraceOf (MPTraceOf (head MPsuff)))
                                   (ObsTraceOf MPsuff)
                                   (ObsTraceOfM (MTraceOf (head M'roll)))).
             - apply ObsTraceOfTraceEq. apply TraceEqSym. apply HRealsuff.
             - auto. }
        -- intros. apply (MTraceEqInfMPTrace (head MPsuff) (head M'roll)) in HHeadsEq.
           { eapply ObsTraceEqApp; eauto.
              apply (ObsEqOverEq (ObsTraceOf (MPTraceOf (head MPsuff)))
                                 (ObsTraceOf MPsuff)
                                 (ObsTraceOfM (MTraceOf (head M'roll)))).
             - apply ObsTraceOfTraceEq. apply TraceEqSym. apply HRealsuff.
             - auto. }
           unfold not. intros. specialize H10 with mpfin.
           apply (LastTraceEq (MPTraceOf (head MPsuff)) MPsuff) in H11; auto.
           apply TraceEqSym. apply HRealsuff.
  - (* Case 2: MPcall stops short *)
    intros. specialize H1 with m' M'. destruct H1; auto.
    + destruct H3.
      * left. destruct H1 as [MPsuff]. exists MPsuff. destruct H1. auto.
      * right. destruct H1. destruct H3. split;auto.
    + destruct H6. specialize H6 with mpret. apply H6; auto.
  - (* Case 3: MPcall diverges *)
      intros. specialize H1 with m' M'. destruct H1; auto.
      + destruct H3.
        * left. destruct H1 as [Msuff]. destruct H1. eauto.
        * right. destruct H1. destruct H3. split; auto.
      + destruct H5. apply H6; auto.
Qed.

Lemma EagerImpliesLazyConf' :
  forall C mp justReturned,
    EagerStackConfidentiality' C mp justReturned ->
    ObservableConfidentiality' C mp justReturned.
Proof.
  unfold EagerStackConfidentiality'. unfold ObservableConfidentiality'. intros. split;try split.

  - (* this is case 1 *)
    intros. destruct H1.
    2: { destruct H1. destruct H4. rewrite H3 in H5. discriminate. }
    destruct H1 as [MPsuffAgain]. destruct H1 as [H1 HSplit].
    assert (MPsuffAgain = MPsuff). { rewrite H1 in H3; inversion H3; auto. }
    specialize H with m' MPpre M'pre.
    (* so assert right off the bat that M' returns *)
    
    assert (HM'sEx : exists M'suff, M'suffO = Some M'suff /\
                                    SplitInclusive justReturned (MTraceOf m') M'pre M'suff).
    { destruct H2.
      - auto.
      - destruct H; auto.
        + left. exists MPsuffAgain. auto.
        + right. destruct H2. destruct H2. split; auto.
        + specialize H with (head MPsuff).
          destruct H.
          * apply SplitInclusiveIsInclusive in HSplit. rewrite H4 in HSplit. auto.
          * apply SplitInclusiveProp in HSplit. rewrite H4 in HSplit. auto.
          * destruct H as [mret']. destruct H. destruct H2. destruct H8.
            apply TraceEqSym in H8.
            eapply LastTraceEq in H; eauto.
            destruct H5. apply MTraceOfInf in H. contradiction. }

    destruct HM'sEx as [M'suff HM'sEx]. destruct HM'sEx as [HM'sEx Hsplit'].
    destruct H;auto.
    + left. exists MPsuffAgain. auto.
    + left. exists M'suff. auto.
    + specialize H with (head MPsuff).
      * rewrite H4 in HSplit.
        assert (HSplit2 := HSplit). assert (HSplit3 := HSplit).
        apply (SplitInclusiveIsInclusive (fun mp => justReturned (ms mp))) in HSplit2.
        apply SplitInclusiveProp in HSplit. rewrite H1 in H3.
        destruct H; auto.
        assert (mp = head MPpre).
        { rewrite (MPTraceOfHead mp).
          apply (SplitInclusiveHead (fun mp => justReturned (ms mp)) (MPTraceOf mp) MPpre MPsuff). auto. }
        pose (M'roll := MTraceOf (RollbackConf (ms mp) (ms (head MPsuff)) m' (head M'suff))).
        exists M'suff. exists M'roll. destruct H as [mret'].
        assert (HHeadsEq: ms (head MPsuff) = head M'roll).
        { unfold M'roll. simpl. extensionality k.
          destruct H as [Hmret Hksame]. assert (mret' = head M'suff).
          { apply SplitInclusiveIsInclusive in Hsplit'.
            apply (LastUnique mret' (head M'suff) M'pre); auto. }
          assert (head M'pre = m').
          { apply SplitInclusiveHead in Hsplit'. rewrite <- Hsplit'. simpl. auto. }
          specialize Hksame with k. rewrite H in Hksame. unfold RollbackConf.
          destruct (weq (ms mp k) (ms (head MPsuff) k)) eqn:Unchanged; simpl.
          - destruct (weq (m' k) ((head M'suff) k)) eqn:Unchanged'; simpl.
            + destruct (weq (ms mp k) (m' k)) eqn:Unvaried; simpl.
              * apply weq_implies_eq in Unchanged.
                apply weq_implies_eq in Unchanged'.
                apply weq_implies_eq in Unvaried.
                rewrite <- Unchanged.
                rewrite Unvaried. auto.
              * apply weq_implies_eq in Unchanged. apply eq_sym. auto.
            + apply not_weq_implies_neq in Unchanged'.
              apply Hksame. right. rewrite H8. auto.
          - apply not_weq_implies_neq in Unchanged.
            apply Hksame. rewrite <- H7. left. auto. }
        assert (HRealsuff : RealMPTrace'' MPsuff).
        { apply RealMPEquiv.
          apply (SplitSuffixReal' (fun mp => justReturned (ms mp)) (MPTraceOf mp) MPpre MPsuff); auto.
          apply RealMPEquiv. unfold RealMPTrace''. rewrite <- MPTraceOfHead. apply TraceEqRefl. }
        split; auto. split; auto.
        assert (Last (ObsTraceOf MPpre) Tau).
        { apply (MPObsLast MPpre (head MPsuff)). auto. }
        assert (Last (ObsTraceOfM M'pre) Tau).
        { apply (MObsLast M'pre (head M'suff)). apply SplitInclusiveIsInclusive in Hsplit'. auto. }
        rewrite H1. rewrite H4. split.
        -- intro Hfin. destruct Hfin as [mpfin Hfin].          
           apply (MPTracePrefixMTrace (head MPsuff) (head M'roll) (* mpfin *)) in HHeadsEq.
           eapply ObsTracePrefApp'; eauto.
           { apply ObsTraceEq_sym. auto. }
           { apply (ObsPrefOverEq (ObsTraceOf (MPTraceOf (head MPsuff)))
                                   (ObsTraceOf MPsuff)
                                   (ObsTraceOfM (MTraceOf (head M'roll)))).
             - apply ObsTraceOfTraceEq. apply TraceEqSym. apply HRealsuff.
             - auto. }
        -- intros. apply (MTraceEqInfMPTrace (head MPsuff) (head M'roll)) in HHeadsEq.
           { eapply ObsTraceEqApp; eauto.
              apply (ObsEqOverEq (ObsTraceOf (MPTraceOf (head MPsuff)))
                                 (ObsTraceOf MPsuff)
                                 (ObsTraceOfM (MTraceOf (head M'roll)))).
             - apply ObsTraceOfTraceEq. apply TraceEqSym. apply HRealsuff.
             - auto. }
           unfold not. intros. specialize H10 with mpfin.
           apply (LastTraceEq (MPTraceOf (head MPsuff)) MPsuff) in H11; auto.
           apply TraceEqSym. apply HRealsuff.
  - (* Case 2: MPcall stops short *)
    intros. specialize H with m' MPpre M'pre. destruct H; auto.
    + destruct H1.
      * left. destruct H as [MPsuff]. exists MPsuff. destruct H. auto.
      * right. destruct H. destruct H1. split;auto.
    + destruct H2.
      * left. destruct H as [Msuff]. exists Msuff. destruct H. auto.
      * right. destruct H. destruct H2. split;auto.
    + destruct H5. specialize H5 with mpfin. apply H5; auto.
  - (* Case 3: MPcall diverges *)
      intros. specialize H with m' MPpre M'pre. destruct H; auto.
      + destruct H1.
        * left. destruct H as [Msuff]. destruct H. eauto.
        * right. destruct H. destruct H1. split; auto.
      + destruct H2.
        * left. destruct H as [Msuff]. exists Msuff. destruct H. auto.
        * right. destruct H. destruct H2. split;auto.
      + destruct H4. apply H5; auto.
Qed.

Theorem EagerSafetyImpliesLazy':
  forall cm,
    EagerStackSafety'' cm -> LazyStackSafety' cm.
Proof.
  unfold EagerStackSafety''. unfold LazyStackSafety'. intros.
  specialize H with m. pose (p := initPolicyState m cm).
  destruct H. split.
  - apply (EagerImpliesLazyConf' (makeContour 0 m) (m,p)). auto.
  - intros. specialize H0 with mp C. apply H0 in H1. destruct H1. split.
    + apply EagerImpliesLazyInt'; auto.
    + apply EagerImpliesLazyConf'; auto.
Qed.

Theorem EagerSafetyImpliesLazy:
  forall cm MP,
    RealMPTrace'' MP ->
    EagerStackSafety cm MP (makeContour 0 (ms (head MP))) -> LazyStackSafety cm MP.
Proof.
  unfold EagerStackSafety. unfold LazyStackSafety. intros. split.
  - destruct H0. apply (EagerImpliesLazyConf (makeContour 0 (ms (head MP))) MP).
    + auto.
    + right. split;try split; auto.
      * apply ForallTraceTautology. unfold not. intros. contradiction.
      * apply TraceEqRefl.
    + destruct H1. auto.
  - intros. assert (RealMPTrace'' MPcall).
    { apply FindCallReal in H1; auto. }
    split.
    + destruct H2.
      * destruct H2 as [MPsuff]. destruct H2.
        apply (EagerImpliesLazyInt C' MPcall MPpre MPsuffO); auto.
        { constructor. exists MPsuff. split; auto. }
        destruct H0. destruct H5. specialize H6 with MPpre MPcall C'.
        apply H6 in H1. destruct H1;auto. constructor.
        exists MPsuff. auto.
      * destruct H2. destruct H4. rewrite H5. unfold ObservableIntegrity. auto.
    + apply (EagerImpliesLazyConf C' MPcall); auto.
      destruct H0. destruct H4. specialize H5 with MPpre MPcall C'.
        destruct H5; auto.
        { unfold PrefixUpTo. destruct H2.
          - left. destruct H2 as [MPsuff]. destruct H2. exists MPsuff. auto.
          - right. destruct H2. destruct H5. split; auto. }
        assert (head MPcall = head MPpre).
        { destruct H2.
          - destruct H2 as [MPsuff]. destruct H2.
            apply SplitInclusiveHeadEq in H7. auto.
          - destruct H2. destruct H7. pinversion H7;auto. }
        rewrite H7. auto.
Qed.

(*Conjecture Lazy'ImpliesLazy :
  forall cm C MM,
  LazyStackSafety' cm C MM -> LazyStackSafety cm C MM.

Conjecture LazyNotImpliesLazy' :
  exists cm C MM,
  LazyStackSafety cm C MM /\ ~ LazyStackSafety' cm C MM.*)
(* The counterexample:

main: mov #0 r1
      store r1 FP
      [call sequence to sub]
      ld FP r1
      bne r1 r2 #2
      mov #1 O
      beq #0 #0 #1
      mov #0 O
      halt

sub:  ld (FP-1) r2
      beq r2 #0 #2
      mov #1 r1
      store r1 (FP-1)
      [return sequence]

In observable confidentiality, if the variation keeps main's memory the same,
sub returns and the behavior is [1]. Of course that is the case for the actual trace as well.
If it changes, sub writes 1 to it and to r1, so the behavior is still [1].

In observable integrity, sub never does anything, because there is no variant. So
the behavior is [1] for both the ideal and actual traces.

But for confidentegrity, if main's memory varies, sub moves 1 to r1 and stores it
in main's memory. Then the rollback sets main's memory back to 0. So r1 and r2 will
not be equal, and the behavior is [0]. So confidentegrity does not hold. *)

(*

(* ********* Tags and tagged properties and policies ********* *)

(* Type of tags and some tags of interest, with a minimalist form of blessed
   call and return sequences.

   RB: TODO: Concretize this? Share among related sections? *)
Variable Tag : Type.
Variable Instr : Tag.
Variable Call : Tag.
Variable Ret : Tag.
Variable PCdepth : nat -> Tag.
Variable SPtag : Tag.
Variable Stack : nat -> Tag.
Variable H1 : Tag.

Section EagerPolicy.

(* Machine states are enriched with mappings from components to tags. (Should a
   rich state be a pair of a machine state and the enrichment?) For now, lists
   are used in lieu of sets and an ordering assumed.

   RB: TODO: Previously called RichState, harmonize w.r.t. testing development.
*)
Definition TagState := Component -> list Tag.
Variable tagsOf : TagState -> Component -> list Tag.

(* Given a call map [cm] and contour [C], relate these to the rich state(s) [T]
   whose tagging is compatible with those. (Add an initial machine state?) *)
Variable InitialTags : CallMap -> Contour -> TagState -> Prop.

(* We need some way to update tags. *)
Variable updateTag : TagState -> Component -> list Tag -> TagState.

(* We need to know whether the currently executing instruction performs memory
   operations (loads and stores), and on which address they operate. *)
Variable isLoad : MachineState -> Addr -> Prop.
Variable isStore : MachineState -> Addr -> Prop.

CoInductive TaggedStep (M: MachineState) (T : TagState) : TagState -> Prop :=
| TCall : forall T' d,
    tagsOf T (Mem (M (Reg PC))) = [Call; Instr] ->
    tagsOf T (Reg PC) = [PCdepth d] ->
    updateTag T (Reg PC) [PCdepth (S d)] = T' ->
    TaggedStep M T T'
| TRet : forall T' d,
    tagsOf T (Mem (M (Reg PC))) = [Instr; Ret] ->
    tagsOf T (Reg PC) = [PCdepth (S d)] ->
    updateTag T (Reg PC) [PCdepth d] = T' ->
    TaggedStep M T T'
| TLoad : forall iaddr dPC dMem,
    isLoad M iaddr ->
    tagsOf T (Reg PC) = [PCdepth dPC] ->
    tagsOf T (Mem iaddr) = [Stack dMem] ->
    dPC <= dMem ->
    TaggedStep M T T
| TStore : forall T' iaddr d,
    isStore M iaddr ->
    tagsOf T (Reg PC) = [PCdepth d] ->
    updateTag T (Mem iaddr) [Stack d] = T' ->
    TaggedStep M T T'
(* ... *)
.

CoInductive TaggedRun : TagState -> MTrace -> Prop :=
| RunFinished : forall T M,
    TaggedRun T (finished M)
| RunNotfinished : forall T T' M MM O,
    step M = Some (head MM,O) ->
    TaggedStep M T T' ->
    TaggedRun T' MM ->
    TaggedRun T (notfinished M MM).

(* TODO: Add missing ingredients from testing and important details. *)

(* The eager policy allows a trace if said trace can result from a run of the
   rich machine starting from the initial enriched state. *)
CoInductive EagerPolicyTrace : CallMap -> Contour -> MTrace -> Prop :=
| EPTIntro : forall cm C T MM,
    InitialTags cm C T ->
    TaggedRun T MM ->
    EagerPolicyTrace cm C MM.

Conjecture EagerPolicy_StackSafety :
  forall cm MM C,
    EagerPolicyTrace cm C MM ->
    EagerStackSafety cm MM C.

End EagerPolicy.

Section EagerTestingProperty.

(* TODO: Consider moving towards a computable variant of the property. *)

(* The state of the PIPE is a tag map and a counter containing the next unique
   identifier to be generated. *)
Definition PipeState := (TagState * nat)%type.

(* The rich machine state is simply a pair of machine and PIPE states. *)
Definition RichState := (MachineState * PipeState)%type.

(* Simplified state description "tags" for the testing property. *)
Variant DescTag :=
| DTStack : nat -> DescTag
| DTInstr : DescTag
| DTOther : DescTag.

(* State description for the testing policy. *)
Record StateDesc := mkStateDesc {
  pcdepth : nat ;
  memdepth : Addr -> DescTag ;
  dstack : list (Addr * Addr * RichState) ;
  callinstrs : list Addr ;
  callsites : list Addr ;
}.

(* Tag helpers. *)
Definition callTag := [Call; Instr]. (* Should be "callerTag"? *)
Definition calleeTag := [H1; Instr].
(* From tag sets to description "tags". *)
Variable to_desc : list Tag -> DescTag.
  (* match ts with *)
  (* | [Stack n] => DSStack n *)
  (* | [PCdepth _] => DTOther *)
  (* | [SPtag] => DTOther *)
  (* | _ => DTInstr *)
  (* end. *)
(* These would be standard map and filter functions on finite memories. *)
Variable map : forall {A B C : Type} (m : A -> B) (f : B -> C), (A -> C).
Variable eqMap : forall {A B : Type} (m1 m2 : A -> B) (def : B -> Prop), Prop.
Variable mapFilter :
  forall {A B : Type} (m : A -> B) (f : A -> B -> Prop), (A -> B).

Arguments eqMap {_ _} _ _ _.
Arguments mapFilter {_ _} _ _ _.

Definition eqMapFilter {A B} (m1 m2 : A -> B) f d :=
  eqMap (mapFilter m1 f) (mapFilter m2 f) d.
(* More helpers for memories. *)
Variable memLayout : TagState -> (Addr -> DescTag).
Variable memCallers : TagState -> list Addr.
Variable memCallees : TagState -> list Addr.
(* And some more. *)
Variable stateMem : RichState -> (Addr -> Value).
Variable defMem : Value.

(* Default memory tag. *)
Definition initMem := [Stack 0].
Definition defDesc := to_desc initMem.

(* Initial state description. *)
Definition initDesc (ts : TagState) : StateDesc :=
  mkStateDesc
    0
    (memLayout ts)
    []
    (memCallers ts)
    (memCallees ts).

(* Test state as state of the main machine and a list of variant machines with
   their states. *)
Definition TestState := (RichState * list RichState)%type.

(* Attempt to take a step in all machine variants. *)
Variable testStep : TestState -> option TestState.

(* Helpers for single-step stack safety. *)
Definition tagOf (def : DescTag) (addr : Addr) (sd : StateDesc) : DescTag :=
  (memdepth sd) addr. (* Not using the default here, vs. sparse memory maps. *)

Definition accessibleTag (t : DescTag) (depth : nat) : Prop :=
  match t with
  | DTStack n => n >= depth
  | DTInstr => False
  | DTOther => False
  end.

Definition isAccessible (def : DescTag) (addr : Addr) (sd : StateDesc) : Prop :=
  accessibleTag (tagOf def addr sd) (pcdepth sd).

Definition isInaccessible (def : DescTag) (addr : Addr) (sd : StateDesc) : Prop :=
  ~ accessibleTag (tagOf def addr sd) (pcdepth sd).

Definition isInstruction (def : DescTag) (addr : Addr) (sd : StateDesc) : Prop :=
  match (tagOf def addr sd) with
  | DTInstr => True
  | _ => False
  end.

(* single_step_stack_safety *)
Inductive EagerTestingSingleStep
           (s  : RichState)
           (d  : StateDesc)
           (t  : RichState) (* variant of [s] w.r.t. [d] *)
           (s' : RichState) (* state such that [s] steps to it *)
           (d' : StateDesc) (* state description of [s'] *)
           (t' : RichState) (* state such that [t] steps to it *)
  : Prop :=
| ETsingle :
    (* Instruction memory of [s'] and [t'] w.r.t. [d] agrees. *)
    let isInstruction' addr _ := isInstruction defDesc addr d in
    eqMapFilter (stateMem s') (stateMem t') isInstruction' (fun _ => False) ->
    (* Accessible memory of [s'] and [t'] w.r.t. [d] agrees. *)
    let isAccessible' addr _ := isAccessible defDesc addr d in
    eqMapFilter (stateMem s') (stateMem t') isAccessible' (fun x => x = defMem) ->
    (* Inaccessible memory of [t] and [t'] w.r.t. [d] agrees. *)
    let isInaccessible' addr _ := isInaccessible defDesc addr d in
    eqMapFilter (stateMem t) (stateMem t') isInaccessible' (fun x => x = defMem) ->
    (* The step eagerly satisfies stack safety. *)
    EagerTestingSingleStep s d t s' d' t'.

(* next_state *)
Variable next_desc :
  forall (def : DescTag) (s : RichState) (d : StateDesc) (s' : RichState),
  option StateDesc.

(* prop_stack_safety_full (1)
   (1) works on genVariationTestState (2)
       and uses to_desc, callTag and calleeTag to get initDesc
       and passes this to stack_safety_full (3)
   (2) takes a few arguments for generation, including isSecretMP (4)
       leaving this abstract at the moment
   (3) operates on traces of TestStates (Main + Variants) *)
(* TODO: Synchronize MTrace and TestState. *)
CoInductive EagerTestingFull : MTrace -> StateDesc -> TestState -> Prop :=
| ETFdone : forall M d ts,
    EagerTestingFull (finished M) d ts
| ETFstep : forall M MM dInput dUpdated tsInput tsScrambled tsStepped,
    (* First, check if the currently executed instruction is (the destination
       of) a call. If it is, scramble. *)
    (* In (M (Reg PC)) (callsites d) -> *)
    (* Take a step in all machine variants. *)
    testStep tsScrambled = Some tsStepped ->
    (* Compute the next state description. *)
    next_desc defDesc (fst tsInput) dInput (fst tsStepped) = Some dUpdated ->
    (* Call single-step stack safety for each variant.*)
    (* ... *)
    EagerTestingFull (notfinished M MM) dInput tsInput.

Variable EagerTesting : Prop.

(* Conjecture EagerTesting_StackSafety : ... *)

End EagerTestingProperty.

*)

(*
(* Following attempts to encode subtraces that start on transition to NOTME, but can end anywhere as long as still NOTME.
There is surely still a prettier way! *)


Definition notme (id: Identity) : Prop :=
  match id with
  | NOTME _ _ _ _ => True
  | _ => False
  end.

Definition notme' (cid : Contour * Identity * MachineState) := notme (snd (fst cid)).

CoInductive subtraceAux : CTrace -> MTrace -> Contour -> Prop :=
| subtraceAuxNow: forall C id m MM MM',
     ~ notme id -> TracePrefix MM MM' -> ForallTrace notme' MM' -> subtraceAux (notfinished (C,id,m) MM) (mapTrace snd MM') C
| subtraceAuxLater: forall cim C MM MM' ,  subtraceAux MM MM' C -> subtraceAux (notfinished cim MM) MM' C
.

Definition subtrace (retSP: Value) (cm :CallMap) (C0: Contour) (super: MTrace) (sub: MTrace) (C:Contour) :=
  subtraceAux (CTraceOf retSP C0 super cm) sub C.


(* APT: As things stand, retSP is always initSP.  Is this right? *)
(* LEO: The retSP should always be the stack pointer of the callee of the "initial" process. So when recursing in StackSafety the retSP should be the SP of (head Mcallee) I think. *)
(* APT: Does the adjustment below do the trick? *)

End foo.


(* There are many well-formedness conditions on this... *)

Inductive Identity :=
| ME : Value -> (* SP below which I can't access things *)
       Identity
| NOTME : Value -> (* PC at the time of call *)
          Value -> (* SP at the time of call *)
          nat -> (* local state size *)
          Value -> (* SP of callee *)
          Identity
| TRANS :
    list Value -> (* Instructions remaining in the sequence *)
    nat ->        (* local state size to be allocated *)
    Value ->      (* PC at the time of call *)
    Value ->      (* SP at the time of call *)
    Value ->      (* SP of callee *)
    Identity.

Definition ITrace := Trace (Identity * MachineState).

(* APT: Recast as operator over MTraces.
        Assumes each call sequence starts with the JAL, right?
        Is this essential, or was it just to make things a bit simpler? *)
(* LEO: Each call sequence starts with a jal : that makes the
formalization significantly simpler as you can figure out the
information you need for contour changes the moment you start the
transition. Is it too unrealistic an assumption? *)
(* APT: I think this is fine, provided that we allow the callee to
access the piece of the caller’s stack containing the arguments. To do
this, we can add an additional parameter to the call map entries
giving the number of args.  (Note that this prevents our handling
dynamic frame sizes, but that is a feature that is ok to omit at least
at first.)  *)
(* LEO: Note that this way the handling of arguments/returns is not
part of the blessed sequence. And we could either (1) assume there is
enough local stack space for all calls or (2) handle stack allocation
and deallocation in the contours.  *)

CoFixpoint ITraceOfAux (id : Identity) (MM : MTrace) (M: MachineState) (cm : CallMap) : ITrace :=
  match MM with
  | finished _ => finished (id, M)
  | notfinished _ MM' =>
    let M' := head MM' in
    match id with
    | ME meSP =>
      match find (fun cme =>
                    match cme with
                    | (h::_, _) => valueEq h (valueOf PC M')
                    | _ => false
                    end) cm with
      | Some (seq, sz) =>
        notfinished (id,M) (ITraceOfAux (TRANS seq
                                               sz
                                               (valueOf PC M')
                                               (valueOf SP M')
                                               meSP)
                                        MM' M' cm)
      | None =>
        notfinished (id,M) (ITraceOfAux (ME meSP) MM' M' cm)
      end
    | TRANS seq sz jalPC jalSP meSP =>
      match seq with
      | _im :: im' :: ims =>
        notfinished (id,M)
                    (ITraceOfAux (TRANS (im' :: ims) sz jalPC jalSP meSP) MM' M' cm)
      | _ =>
        (* Potential check: should be a singleton list always (_im) *)
        notfinished (id, M)
                    (ITraceOfAux (NOTME jalPC jalSP sz meSP) MM' M' cm)
      end
    | NOTME jalPC jalSP sz meSP =>
      if andb (valueEq (valueOf PC M') (vplus jalPC 4))
              (valueEq (valueOf SP M') jalSP) then
        notfinished (id,M) (ITraceOfAux (ME meSP) MM' M' cm)
      else
        notfinished (id,M) (ITraceOfAux (NOTME jalPC jalSP sz meSP) MM' M' cm)
    end
  end.

Definition CTrace := Trace (Contour * Identity * MachineState).

Definition updateContour (C : Contour) (id id' : Identity) (M M' : MachineState) :=
  match id, id' with
  | ME _, ME _ => C
  | NOTME _ _ _ _, NOTME _ _ _ _ => C
  | TRANS _ _ _ _ _, TRANS _ _ _ _ _ => C
  | ME _, TRANS _ sz _ _ _=>
    (* Everything other than the sz top parts of the stack becomes unreachable. *)
    fun k => if cle k (componentOf (vminus (valueOf SP M) sz))
             then (HC, HI) else C k
  | TRANS _ _ _ _ _, NOTME _ jalSP _ _=>
    (* Everything between the size of SP at the call, and the current SP
       is now "local state" *)
    fun k => if andb (cle k (componentOf (valueOf SP M')))
                     (clt (componentOf jalSP) k)
             then (LC, LI)
             else C k
  | NOTME _ _ (* jalSP *) _ _, ME meSP =>
    (* Everything above the SP at the call becomes unreadable again,
       Everything below the SP but above the low limit of ME becomes
       readable again. *)
    fun k => if andb (clt (componentOf meSP) k)
                     (cle k (componentOf (valueOf SP M')))
             then (LC, LI)
             else if clt (componentOf (valueOf SP M')) k then (HC, HI)
             else C k
  | _, _ => (* ERROR CASE *)
    C
  end.

CoFixpoint ContouredTraceOf (C : Contour) (it : ITrace) :=
  match it with
  | finished (id, M) =>
    finished (C, id, M)
  | notfinished (id, M) MM =>
    let (id', M') := head MM in
    let C' := updateContour C id id' M M' in
    notfinished (C, id, M) (ContouredTraceOf C' MM)
  end.

Definition CTraceOf (retSP : Value) (C : Contour) (MM : MTrace) (cm : CallMap) :=
  ContouredTraceOf C (ITraceOfAux (ME retSP) MM (head MM) cm).


Definition updateObs (s : StateObs) (C' : Contour) (M' : MachineState) : StateObs :=
  fun k => match confidentialityOf (C' k) with
           | LC => Some (valueOf k M')
           | HC => s k
           end.

CoFixpoint ObsTraceAux (s : StateObs) (ct : CTrace) : OTrace :=
  match ct with
  | finished (C, id, M) =>
    finished (updateObs s C M)
  | notfinished (C, id, M) CIMs =>
    let s' := updateObs s C M in
    notfinished s' (ObsTraceAux s' CIMs)
  end.

Definition ObsTrace (ct : CTrace) : OTrace :=
  let '(C,_,M) := head ct in
  let s0 := fun k =>
              match confidentialityOf (C k) with
              | LC => Some (valueOf k M)
              | HC => None
              end in
  ObsTraceAux s0 ct.


*)
