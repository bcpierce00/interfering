\subsection{Testing The Stack Safety Menagerie}

In \cref{sec:intro}, we discussed several dimensions of flexibility
that our properties should exhibit: applicability to different system
features and different security requirements. Another important dimension
is applicability to multiple enforcement mechanisms.
In the following, we discuss how different existing mechanisms
might fit into our model.

\paragraph{Stack Canaries and Shadow Stacks}
%
Canaries are special values inserted by the caller at certain points of the
stack and checked for corruption on return, for protection against
some classes of control-flow hijacking (i.e., overwriting the caller's
return address through a buffer overflow that would also overwrite the canary
detectably). A shadow stack is a mirror image of the control-relevant parts of the stack,
maintained by the program to attempt to detect attempts to hijack its control
flow and ``restrict the flexibility available in creating gadget chains''
\cite{Shanbhogue+19}.
%
Interestingly, these are lazy enforcement mechanisms, in that
the attack may occur and be detected some time later, as long as
it is detected before it can become dangerous. That would make our
formalism a good fit for defining their security, except that
they are chiefly hardening techniques: they increase the difficulty
of some control-flow attacks on the stack, but cannot provide absolute
guarantees on \(\wbcf\) under a normal attacker model.

\paragraph{Split Stacks}
%
Code-pointer integrity seeks to prevent control-flow hijacking attacks by
splitting the program memory, including the stack, into a regular region and a
safe region; objects that require protection are placed in the latter and
all accesses to them protected by static or dynamic checks.
%
Like shadow stacks, bounds checking is a high-level technique designed to
protect code written in a high-level language, but it is designed to
offer protection under a stronger threat model that also considers the presence
of untrusted code. As with most other software-based methods, it purports to
protect exclusively the control-relevant parts of the stack, making no claims
about its data-relevant parts---we would solely be testing \(\wbcf\).

\paragraph{Bounds Checking}
%
Under a bounds checking discipline such as SoftBound \cite{NagarakatteZMZ09}, all the pointers
in a program are extended with some disjoint metadata, and these are combined
to gate memory accesses. These approaches enforce a form of \emph{memory safety},
and we would therefore expect them to enforce \(\clri\) and \(\clrc\). They aim
to enforce \(\wbcf\) by cutting off attacks that involve memory-safety violations,
but that may not be sufficient.

Bounds checking approaches require substantial compiler cooperation. This is not a
problem for our properties in general, but it is not very compatible with
generation-by-execution of low-level code. A better choice would be to generate
high-level code using a tool like CSmith \cite{DBLP:conf/pldi/YangCER11}, or prove the properties instead.

\paragraph{Capabilities}

Capability machines can represent and manipulate
unforgeable tokens of authority over specific regions of
memory using a combination of dedicated out-of-band memory and
specialized ISA instructions.
%
The most prominent contemporary representative of this long line of work is
CHERI \cite{DBLP:conf/sp/WatsonWNMACDDGL15}, a modern architecture designed to provide efficient fine-grained
memory protection and compartmentalization.
%
Previous work has uses these principles in simplified models to implement
\emph{secure calling conventions} for the call
stack \cite{SkorstengaardLocal,SkorstengaardSTKJFP,Georges22:TempsDesCerises}. Those conventions can be seen as combining the
protections of bounds-checking with software-based methods of control-flow protection.

There are several proposals around the use of CHERI capabilities to enforce stack safety,
including mechanisms that use the standard CHERI hardware (which includes local
capabilities) \cite{SkorstengaardLocal},
and others that propose entirely new types of capabilities, such as linear
\cite{SkorstengaardSTK}, uninitialized \cite{Georges+21}, lifetime
\cite{Tsampas+19}, and directed \cite{Georges22:TempsDesCerises} capabilities.
It is a high priority to test this most recent work by Georges et al., as it is designed
to be similar to all of our properties except for \(\clei\).

\subsection{More Features}

Several common features did not make it into this work: most importantly concurrency and
exceptions. We plan to extend the model to include them, and then test them. We would also
like to test the model given in \cref{app:ptr} for arbitrary memory-safe pointer sharing.
