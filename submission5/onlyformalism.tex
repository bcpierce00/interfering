%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[10pt,conference]{ieeetran}%\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{amsmath,amsthm,amssymb}

\usepackage{xcolor,listings}

\usepackage{multirow}

\usepackage{stmaryrd}

\usepackage[noadjust]{cite}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\input{macros}

\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\begin{document}

%% Title information
\title{Formalizing Stack Safety as a Security Property}

\author{
  \IEEEauthorblockN{
    Sean Noble Anderson
  }
  \IEEEauthorblockA{
    Portland State University\\
    ander28@pdx.edu\\
  }
  \and
  \IEEEauthorblockN{
    Leonidas Lampropoulos
  }
  \IEEEauthorblockA{
    University of Maryland, College Park\\
    leonidas@umd.edu\\
  }
  \and
  \IEEEauthorblockN{
    Roberto Blanco
  }
  \IEEEauthorblockA{
    Max Planck Institute for Security and Privacy\\
    roberto.blanco@mpi-sp.org\\
  }
  \linebreakand
  \IEEEauthorblockN{
    Benjamin C. Pierce,
  }
  \IEEEauthorblockA{
    University of Pennsylvania\\
    bcpierce@cis.upenn.edu\\
  }
  \and
  \IEEEauthorblockN{
    Andrew Tolmach
  }
  \IEEEauthorblockA{
    Portland State University\\
    tolmach@pdx.edu\\
  }
}



%% Keywords
%% comma separated list
\ifcameraready
\keywords{Stack Safety, Micro-Policies}  %% \keywords are mandatory in final camera-ready submission
\fi

\maketitle

\section{Threat Model, Machines, and Enforcement }

Before introducing our formal model of stack safety, we describe
our machine exemplar, enforcement mechanism, and threat model.

We begin with a RISC-V-like machine enhanced with PIPE, a tag-based reference
monitory. We extend this machine with a {\it security overlay semantics}:
a semantics in which calls, returns, and other operations of interest are condensed
into atomic {\it macro-instructions}, which update an additional security context.
As opposed to a fully-abstract overlay semantics, in which the semantics is safe
by construction and compilation to an enforcement mechanism must be proved fully abstract,
our machine's semantics are not safe unless the tag policy is correctly
instantiated, but the security context informs trace properties that
must hold under a policy for that policy to be considered valid.

The underlying machine is a standard RISC-V ISA as modeled in [MIT-RISCV].
Our overlay semantics provide macro-instructions for the following code features:
\begin{itemize}
\item Function calls and returns, with caller- and callee-saved registers according
  to the RISC-V ABI
\item Arguments passed by reference
\item Exceptions
\item Tail-call Elimination
\end{itemize}

\paragraph*{What is a ``call''?} Some ISAs have a single ``call''
instruction that does all the required manipulation of the program counter
(\(\PCname\)) and stack pointer; others perform a series of instructions
whose constituent opcodes may be used in some places for other purposes.
Our RISC-V machine is the latter, so calls must be explicitly designated
as such by the compiler, by identifying them as macro-instructions.
The same goes for other operations, such as exceptions.
Macro-instructions connect the enforcement mechanism to the property: we don't
expect the enforcement mechanism to provide any guarantees for code sequences
that resemble calls or returns, but which are not macro-instructions.

Because macro-instructions must be generated by the compiler, they only
carry data that can be known by the compiler at compile-time. For example,
the \(\mathbf{call}\) macro-instruction identifies the register \(r_{target}\) containing
the address of the function to be called, as well as the registers that hold arguments.

%\paragraph*{Enforcement Model and Properties}

%A machine state consists of the standard addresses and registers, as well as
%additional policy state used by the enforcement mechanism. Our properties
%refer only to addresses and registers; they do not constrain the behavior
%of policy state. We model an execution step as a partial function on states:
%when the machine does not step from a given state, this
%is a {\em failstop}, halting the program before it can perform an
%action that would violate the security property.
%our properties are therefore naturally \emph{termination insensitive.}

\paragraph*{Threat Model}

We trust the compiler has correctly placed macro-instructions according to
the semantics of the source language, but we do not assume that the code
is otherwise reasonable. In particular, while we are agnostic as to the source
language, C is very plausible, and so any source function might contain undefined
behavior resulting in its compilation to arbitrary machine code.

In general, it is impossible to distinguish buggy source code from an attacker;
we assume nothing about the intent of the source code, except that it makes calls
and returns, and we must guarantee that the caller and callee are protected from one
another.

This is a strong threat model, but hardware and timing attacks are out of scope,
and our properties are termination insensitive as a result of the enforcement mechanism
(below).

\paragraph*{Limitations}

We do not support dynamic code generation, and our concurrency model is fairly
simplistic, assuming a fixed number of threads each with its own dedicated processor.
We model memory safe stack objects, but not a heap. Regions outside of
stacks can be used however the compiler likes, including as a heap, but no protection is
built in and our properties assume that if a pointer to a stack object is stored there,
it is permanently compromised.

\section{The Basic Machine}

The building blocks of the machine are {\em words} and {\em registers}.
Words (\(\WORDS\)) are 64-bit integers ranged over by \(\word\) and, when used as addresses,
\(\addr\). The processor has 32 registers, ranged over in general by \(\reg \in \REGS\),
plus a program counter (\(\PCname\)). The following table divides
the registers into metavariables, some belonging to caller- or callee- sets:

\vspace{\abovedisplayskip}
\begin{tabular}{| l | l | l |}
  \hline
  Set & Names & Purpose \\
  \hline
  CLR\_SV & \(rt_0 - rt_6\) & Caller-saved temps \\
  & \(ra_0 - ra_1\) & Caller-saved args / return vals \\
  & \(ra_2 - ra_7\) & Caller-saved args \\
  \hline
  CLE\_SV & \(rs_0 - rs_7\) & Callee-saved \\
  \hline
  PUBLIC & \(rra\) & Return Address \\
  & \(rsp\) & Stack Pointer \\
  & \(pc\) & Program Counter \\
  \hline
\end{tabular}
\vspace{\abovedisplayskip}

Collectively addresses and registers are {\em state elements} \(\component\)
in the set \(\COMPONENTS ::= \WORDS + \REGS\).
%
A {\em machine state} \(\mach \in \MACHS\) is a type that exposes a mapping
\(\mach[\component]\) from state elements to values, and may also contain additional
security state. For convenience, we abbreviate
multiple updates \(m[\component_0 \mapsto \word_0][\component_1 \mapsto \word_1]\dots\)
as \(m \llbracket A \mapsto B | C \rrbracket\), where \(A\) and \(B\)
are fomulae with free variables bound to sets in \(C\).
The base machine step function
\(\mach \stepstounder{} \mach' \in \MACHS \rightharpoonup \MACHS\) represents a single step.
It is partial to represent the capacity of the machine to failstop.
In order to accommodate failstop behavior, our properties will be {\it termination insensitive}.

The set of instructions, \(I \subseteq \WORDS\), corresponds to the RISC-V ISA.
We further introduce {\it macro-instructions}: sequences of
instructions that operate as if they were single, atomic pseudoinstructions.
A macro-instruction consists of both a list
of instructions and a pseudoinstruction that identifies its purpose in the
property. The pseudoinstructions, and the data that they carry, are as follows.

\begin{align*}
\psi \in \Psi ::= & \mathbf{call} ~ \reg_{target} ~ \overline{\reg_{args}} & \\
| & \mathbf{tailcall} ~ \reg_{target} ~ \overline{\reg_{args}} & \\
| & \mathbf{return} & \\
| & \mathbf{alloc} ~ size & size \in \mathbb{N} \\
| & \mathbf{setex} ~ \addr_{buf} \\
| & \mathbf{throwex} ~ \addr_{buf} \\
\end{align*}

An macro-instruction \((\bar{i},\psi) \in J\) is a pair of a pseudoinstruction and
a non-empty list of instructions. In order to implement the atomic nature of
executing macro-instructions,
we define a {\it ranged-step} relation that, given a pair of addresses
\(a_{low}\) and \(a_{high}\), steps as long the program counter is between them.

\judgment[Done]
         {\(\mach[\PCname] < a_{low} \lor \mach[\PCname] > a_{high}\)}
         {\(a_{low},a_{high} \vdash \mach \manystepstounder{} \mach\)}

\judgmenttwobrlong[Step]
                  {\(a_{low} \leq \mach[\PCname] < a_{high}\)}
                  {\(\mach \stepstounder{} \mach'\)}
                  {\(a_{low},a_{high} \vdash \mach' \manystepstounder{} \mach''\)}
                  {\(a_{low},a_{high} \vdash \mach \manystepstounder{} \mach''\)}

Now we're ready to introduce the overlay semantics.
Additionally, we keep track of security context information
specific to each stack over the course of the run.
This data is not relevant to execution,
it is only used to define the stack safety property. We define a set of
{\it security classes}:
\[sc \in SEC ::= \public | \sealed | \unsealed\]
A {\it security view} \(V \in \mathit{VIEW} ::= \COMPONENTS \rightarrow SEC\) divides the machine
elements in terms of their purpose relative to the active function.
The {\it initial view} \(V_0\) maps all stack locations and non-public registers
to \(\unsealed\) and all other locations and public registers to \(\public\).
A set of {\it targets} identify the addresses of the program counter or
stack pointer at a return point:
\[\begin{split}
tar \in TAR ::= & \mathit{Return} ~ a_{pc} ~ a_{sp} \\
& \mathit{Catch} ~ a_{buf} ~ a_{pc} ~ a_{sp} \\
& \mathit{Done} \\
\end{split}\]
And a {\it stack context} is a non-empty stack of pairs of targets and views:
\[\context \in \CONTEXTS ::= \mathit{list} ~ (\mathit{TAR} \times \mathit{VIEW})\]

The initial stack context \(\context_0\) is \(\left[ (\mathit{Done}, V_0) \right]\).

An {\it overlay state} \(\sigma\) consists of a pair of a machine state
and a stack contexts.
\[\sigma = (\mach, \context) \in \mathcal{S} ::= \MACHS \times \CONTEXTS\]

The labeled step function for overlay states
\(\sigma \stepstounder{\psi?} \sigma' \in
\mathcal{S} \rightarrow  (\Psi + \bot) \times \mathcal{S}\)
proceeds by an {\it overlay step}
if the program counter points to the start of a macro-instruction's instruction sequence.
Otherwise, it proceeds by the default step. The definitions of context steps
\(\constep{\psi} \in \MACHS \times \CONTEXTS \times \Psi \rightarrow \CONTEXTS\)
will be defined for each pseudoinstruction as we introduce new topics.

\judgmentthreebrlong[Overlay]
                    {\((\bar{i}, \psi) \in J\)}
                    {\(\mach',\context \constep{\psi} \context'\)}
                    {\(\mach \manystepstounder{} \mach'\)}
                    {\(\mach[\PCname+n] = \bar{i}[n]\) for each \(n\) where \(0 \leq n < |\bar{i}|\)}
                    {\((\mach,\context) \stepstounder{\psi} (\mach',\context')\)}

\judgment[Default]
         {\(\mach \stepstounder{} \mach'\)}
         {\((\mach,\context) \stepstounder{\bot} (\mach',\context)\)}

\paragraph*{Macro-instruction definitions}

[TBD]

Note that there can be multiple macro-instructions with different instructions
that represent the same pseudoinstruction.
[This is less likely when we have smaller pseudoinstructions.]

\paragraph*{Events and Traces}

Some macro-instructions may be interpreted as {\it events} that can be observed
from outside the system. For now we define events \(\obs \in \OBSS\) as calls, labeled
with the target address and the values of the arguments, or else as the silent
event \(\tau\):
\[\begin{split}
\obs \in \OBSS ::= & ~ \mathbf{callE} ~ a_{target} ~ \overline{w_{args}} \\
| & ~ \tau \\
\end{split}\]

We convert macro-instructions into events via the \(\mathit{observe}\)
function, observing the values of relevant registers, defined in Figure \ref{fig:observe}.

A {\em trace} is a nonempty, finite or infinite sequence
of pairs of processors and events, ranged over by \(\obsT\).
We use ``\(\notfinished{}{}\)'' to represent ``cons'' for traces, reserving ``::''
for list-cons.

\begin{figure*}
\[\mathit{observe} ~ \psi? ~ m =
\begin{cases}
  \mathbf{callE} ~ m[\PCname] ~ m \llbracket r | r \in \overline{r_{args}} \rrbracket
  & \textnormal{when } ~ \psi = \mathbf{call} ~ r_{target} ~ \overline{r_{args}} \\
  \mathbf{callE} ~ m[\PCname] ~ m \llbracket r | r \in \overline{r_{args}} \rrbracket
  & \textnormal{when } ~ \psi = \mathbf{tailcall} ~ r_{target} ~ \overline{r_{args}} \\
%  (\rho, \mathbf{returnE} ~ m[\PCname] & \textnormal{when } \psi = \mathbf{return} \\
  \tau & \textnormal{otherwise} \\
\end{cases}\]
\caption{Converting overlay steps to events}
\label{fig:observe}
\end{figure*}

We write that execution from a state produces an observation trace \(\sigma \hookrightarrow \obsT\)
as follows, coinductively:

\judgment{\(\not \exists \mach' ~ \context'. (\mach,\context) \stepstounder{\psi?} (\mach',\context')\)}
         {\((\mach,\context) \hookrightarrow \tau\)}

\judgmenttwo{\((\mach,\context) \stepstounder{\psi?} (\mach',\context')\)}
            {\((\mach',\context') \hookrightarrow \obsT\)}
            {\((\mach,\context) \hookrightarrow \notfinished{\mathit{observe} ~ \psi? ~ \mach}{\obsT}\)}

Naturally, most states will admit many possible traces, depending on the order in which
processors step.

We define another relation that takes a trace of a callee up to its return, or until
an exception is thrown, if either occurs.
We write this \(\context' \downarrow (\mach,\context) \hookrightarrow \obsT\), where \(\context\)
is the context of the caller.

\judgment{\(|\context| \leq |\context'|\)}
         {\(\context' \downarrow (\mach,\context) \hookrightarrow \tau\)}

\judgmenttwobrlong{\((\mach,\context) \stepstounder{\psi?} (\mach',\context')\)}
                  {\(|\context'| > |\context''|\)}
                  {\(\context'' \downarrow (\mach',\context') \hookrightarrow \obsT\)}
                  {\(\context'' \downarrow (\mach,\context) \hookrightarrow \notfinished{\mathit{observe} ~ \psi? ~ \mach}{\obsT}\)}

\paragraph*{Observational Similarity}

We say that two event traces $\obsT_1$ and $\obsT_2$ are {\em similar},
written \(\obsT_1 \eqsim \obsT_2\), if the sequence of non-silent events
is the same. That is, we compare up to deletion of \(\tau\) events.

\begin{minipage}{.4\columnwidth}
  \judgment{}{\(\obsT \eqsim \obsT\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\obs}{\obsT_1} \eqsim \notfinished{\obs}{\obsT_2}\)}
\end{minipage}

\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\tau}{\obsT_1} \eqsim \obsT_2\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\obsT_1 \eqsim \notfinished{\tau}{\obsT_2}\)}
\end{minipage}

%\begin{minipage}{.4\columnwidth}
%  \judgment{\(\obsT_1 \eqsim_\rho \obsT_2\)}
%           {\(\notfinished{(\rho',\obs)}{\obsT_1} \eqsim_\rho \obsT_2\)}
%\end{minipage}
%\begin{minipage}{.4\columnwidth}
%  \judgment{\(\obsT_1 \eqsim_\rho \obsT_2\)}
%           {\(\obsT_1 \eqsim_\rho \notfinished{(\rho',\obs)}{\obsT_2}\)}
%\end{minipage}

\section{Stack Safety With Calls and Returns}

In this section we will present the context steps for calls and returns,
and show how they translate into properties. They are given formally in
Figure \ref{fig:callcontexts}.

For calls, we define a function, {\it update view}, that defines the view
of a caller in terms of that of the callee.
First, all stack locations below the stack pointer
are \(\unsealed\) -- fair game for the callee to allocate or write to, and
to read after writing. All \(\unsealed\) locations above the stack pointer
become \(\sealed\) -- their contents are both secret to and protected
from the callee. Argument and system registers are automatically marked
\(\mathit{public}\). All other locations above the stack pointer
retain their prior status (these will only be \(\sealed\) for now,
until we introduce shareable allocations shortly.)

To update the context for a call, we pair the updated view with the return target of the
call and push it to the stack. The return target will tell us whether a future
return is to the proper location with the stack pointer restored.
The view tells us how to treat the security of the callee's state, and as
it becomes more complicated, will benefit from the history that we maintain.

On a return, we pop the topmost pair from the context that has
a \(\mathit{return}\), along with any other pairs (catch points,
for instance) that we pass.

\begin{figure*}
\[\begin{split}
& \mathit{update\_view} ~ V ~ a_{sp} ~ \overline{r_{args}} \triangleq
\lambda \component .
\begin{cases}
  \public & \textnormal{else if } \component \in \REGS \textnormal{ and }
  \component \in \overline{r_{args}} \textnormal{ or } \component \in \mathit{PUBLIC} \\
  \unsealed & \textnormal{else if } \component \in \WORDS \textnormal{ and } \component \leq a_{sp} \\
  \unsealed & \textnormal{else if } \component \in \REGS \textnormal{ and } \component \in \mathit{CLR\_SV} \\
  \sealed & \textnormal{else if } \component \in \WORDS \textnormal{ and } a_{sp} < \component \textnormal { and } V ~ \component = \unsealed \\
  \sealed & \textnormal{else if } \component \in \REGS  \\
  V ~ \component & \textnormal{otherwise} \\
\end{cases} \\
\end{split}\]

\judgmenttwobrlong[CallC]
                  {\(\psi = \mathbf{call} ~ r_{target} ~ \overline{r_{args}}\)}
                  {\(T' = \mathit{Return} ~ (m[pc] + 4) ~ m[sp]\)}
                  {\(V' = \mathit{update\_view} ~ V ~ m[sp] ~ \overline{r_{args}}\)}
                  {\(\mach, (T,V)::\context \constep{\psi} (T',V')::\context\)}

\judgment[ReturnCRet]
         {\(\psi = \mathbf{return}\)}
         {\(\mach, (\mathit{return} ~ a_{pc} ~ a_{sp}, V)::\context \constep{\psi} \context\)}

\judgment[ReturnCDone]
         {\(\psi = \mathbf{return}\)}
         {\(m, [\mathit{Done},V] \constep{\psi} [\mathit{Done},V]\)}

\judgmenttwo[ReturnCSkip]
            {\(\psi = \mathbf{return}\)}
            {\(\mach, \context \constep{\psi} \context'\)}
            {\(\mach, (\_::\context) \constep{\psi} \context'\)}
         
\caption{Call and return context updates}
\label{fig:callcontexts}
\end{figure*}

Now we can give our definition of stack safety in terms of the context at the point of a call.

\subsection{Facts Abouts Calls and Returns}

Here we define some logical operations to reason about the behavior of the
system over time. These have a temporal-logic flavor, as they reflect
the expected behavior of the system in the future, after a possible return.

\paragraph*{On-return}

The intuition behind {\it return-time integrity} (below) is that a caller may expect its
sealed data to be unchanged when control returns to it. In fact, the callee
may overwrite such data -- when the data are found in callee-saved registers
this is perfectly legal -- as long as it either restores it, or has some guarantee
that its changes will impact the caller.

We start by defining a second-order logical operator
\(\context_{ret} \uparrow P\), read ``\(P\) holds on return to \(\context_{ret}\),''
where \(P\) is a predicate on machine states. This is a coinductive relation
similar to ``weak until'' in temporal logic -- it holds if the condition
is never reached.

\judgmenttwo[Returned]
            {\(P ~ (\mach,\context)\)}
            {\(|\context| \leq |\context_{ret}|\)}
            {\((\context_{ret} \uparrow P) ~ (\mach, \context)\)}

\judgmenttwobrlong[Step]
                  {\(|\context| > |\context_{ret}|\)}
                  {\((\mach, \context) \stepstounder{\psi?} (\mach', \context')\)}
                  {\((\context_{ret} \uparrow P) ~ (\mach', \context')\)}
                  {\((\context_{ret} \uparrow P) ~ (\mach, \context)\)}

Similarly, in {\it caller confidentiality}, we will want to compare future states,
so we give a binary equivalent, \(\context \Uparrow R\), so that
\((\mach,\context) ~ (\context'' \Uparrow R) ~ (\mach',\context')\) holds if \(R\) holds on the
first return states after \((\mach,\context)\) and \((\mach',\context')\).

\judgmentthree[Returned]
              {\((\mach,\context) ~ R ~ (\mach',\context')\)}
              {\(|\context| \leq |\context_{ret}|\)}
              {\(|\context'| \leq |\context_{ret}|\)}
              {\((\mach,\context) ~ (\context_{ret} \Uparrow R) ~ (\mach',\context')\)}

\judgmenttwobr[Left]
              {\(\context_1 > \context_{ret}\)}
              {\((\mach_1,\context_1) \stepstounder{\psi?} (\mach_1',\context_1')\)}
              {\(\context_2 > \context_{ret}\)}
              {\((\mach_1',\context_1') ~ (\context_{ret} \Uparrow R) ~ (\mach_2,\context_2)\)}
              {\((\mach_1,\context_1) ~ (\context_{ret} \Uparrow R) ~ (\mach_2,\context_2)\)}

\judgmenttwobr[Right]
              {\(\context_1 > \context_{ret}\)}
              {\((\mach_2,\context_2) \stepstounder{\psi?} (\mach_2',\context_2')\)}
              {\(\context_2 > \context_{ret}\)}
              {\((\mach_1,\context_1) ~ (\context_{ret} \Uparrow R) ~ (\mach_2',\context_2')\)}
              {\((\mach_1,\context_1) ~ (\context_{ret} \Uparrow R) ~ (\mach_2,\context_2)\)}

\paragraph*{Variants and Vestigial Elements}

One or more elements of a given state are {\it vestigial} if their values
in that state have no observable influence on future execution. We define this
formally as a sort of non-interference: for a state \((\mach,\context)\) and
a set of elements \(\components\), \((\mach,\context) \parallel \components\)
holds if we can replace the contents of \(\components\) with arbitrary values
and have the resulting state produce an equivalent trace. The state created
by modifying \(\components\) in this way is termed a variant.

\definition Machine states \(\mach\) and \(\nach\) are {\em \(\components\)-variants},
written \(\mach \approx_\components \nach\), if, for
all \(\component \not \in \components\), \(\mach[\component] = \nach[\component]\).

\definition An element set \(\components\) is vestigial in state \((\mach,\context)\),
written \((\mach,\context) \parallel \components\), if for all
\(\nach\) such that \(\mach \approx_{\components'} \mach'\), if 
\((\mach,\context) \hookrightarrow \obsT\) and
\((\nach,\context) \hookrightarrow \obsT'\), then
\(\obsT \eqsim \obsT'\).

\paragraph*{Property Definitions}

And with the preliminary definitions out the way, we can define integrity.

\definition Let \(\Delta(\mach,\mach')\) be the set of elements \(\component\)
such that \(\mach[\component] \not = \mach'[\component]\).

\definition Let \((\mach,(T,V)::\context)\) be a state and
\(\components = \{\component | V ~ \component = \sealed\}\).
Let \(P\) be a predicate that holds on a state \((\mach',\context')\) if
\(\mach' ~ \parallel ~ \Delta(\mach,\mach') \cap \components\).
Then \(\mach\) enjoys {\it return-time integrity} if \(\context \downarrow P\) holds.

\definition A system enjoys {\it universal stack integrity} if, for all reachable states
\((\mach,\context)\) such that
\((\mach,\context) \stepstounder{\psi} (\mach',\context')\) with \(\psi = \mathbf{Call} ~ \_ ~ \_\),
\((\mach',\context')\) enjoys return-time integrity.

\paragraph*{Caller Confidentiality}

Confidentiality properties are also modeled as non-interference, but with a twist:
the caller's confidential data should be kept secret from the callee, but after return,
will naturally be accessible to the caller once again. So, we must model confidentiality
in terms of events inside the callee. But confidentiality violations might not become
visible during the callee's lifetime -- the callee might read a secret and stash it somewhere
that it will be accessed later. So we must also consider the machine state at the end
of the call.

We could define a natural, strict form of confidentiality that requires that the final
states be identical. However, as with integrity, this is stricter than we need -- there
may be some conditions in which a secret is copied, but never used again. So, we once
again wish for our final condition to allow values to be vestigial. Which values?

\definition Let \(\mach,\mach'\) and \(\nach,\nach'\)
be pairs of machine states. Their {\em corrupted set}, written
\(\bar{\Diamond}(\mach,\mach',\nach,\nach')\), is the set of all elements
\(\component \in \Delta(\mach,\mach') \cup \Delta(\nach,\nach')\) such that
\(\mach'[\component] \not = \nach'[\component]\).

\definition Let \((\mach,(T,V)::\context)\) be a state and
\(\components = \{\component | V ~ \component \in \{\sealed, \unsealed\}\}\).

Then \((\mach,\context)\) enjoys {\it caller confidentiality} with respect to
some \(\context_{ret}\) if, for any \(\nach\)
that is a \(\components\)-variant of \(\mach\), we can take
\(\context_{ret} \uparrow (\mach,\context) \hookrightarrow \obsT\) and
\(\context_{ret} \uparrow (\nach,\context) \hookrightarrow \obsT'\) and have that
\(\obsT \simeq \obsT'\);
and additionally if \((\mach,\context) ~ (\context_{ret} \Uparrow R) ~ (\nach,\context)\),
where \((\mach_1,\context_1) ~ R ~ (\nach_2,\context_2)\) if
\((\mach_1 \parallel \bar{\Diamond}(\mach,\mach_1,\nach,\nach_2)\).

\definition A system enjoys {\it universal caller confidentiality} if, for all reachable states
\((\mach,\context)\) such that \((\mach,\context) \stepstounder{\psi} (\mach',\context')\)
with \(\psi = \mathbf{Call} ~ \_ ~ \_\),
\((\mach',\context')\) enjoys caller confidentiality with respect to \(\context\).

\section{Allocating Memory}

We now introduce the context step for the \(\mathbf{alloc} ~ \mathit{size}\)
macro-instruction. Without \(\mathbf{alloc}\), our system already allowed a function
to allocate as much private memory as it liked by moving the stack pointer. With
\(\mathbf{alloc}\) it can now also allocate public objects that can be accessed
freely by its callees. Later we will refine this system to restrict public objects
to be accessed only via capabilities.

\judgmentbr[AllocC]
           {\(\psi = \mathbf{alloc} ~ size\)}
           {\(V' = V\llbracket m[sp]+i \mapsto \public | 0 < i \leq size \rrbracket\)}
           {\((\mach, (T,V)::\context) \constep{\psi} (T,V')::\context\)}

The remainder of our property definitions are unchanged. The \(\mathit{update\_view}\)
function preserves the public status of allocated objects, and they are exempt from
integrity and confidentiality properties.

\section{Exceptions}

We implement exceptions via another pair of macro-instructions:
\(\mathbf{setex} ~ a_{buf}\), akin to \(\mathit{setjmp}\), with the
jump buffer stored at \(a_{buf}\), and \(\mathbf{throwex} ~ a_{buf}\),
akin to \(\mathit{longjmp}\). The context updates for exceptions are given
in Figure \ref{fig:excontexts}. The update for \(\mathbf{setex}\) pushes
a \(\mathit{Catch}\) target onto the stack, identified by \(\addr_{buf}\),
with the same view as the current function. For \(\mathbf{throwex}\),
we pop the stack until we find a \(\mathit{Catch} ~ a_{buf} ~ \_ ~ \_\),
popping it as well. Rules apply in order.

\begin{figure*}

\judgmenttwo[SetExC]
            {\(\psi = \mathbf{setex} ~ \addr_{buf}\)}
            {\(T' = \mathit{Catch} ~ \addr_{buf} ~ (\mach[pc] + 4) ~ \mach[sp]\)}
            {\(\mach, (T,V)::\context \constep{\psi} (T',V)::(T,V)::\context\)}

\judgment[ThrowExCCatch]
         {\(\psi = \mathbf{throwex} ~ \addr_{buf}\)}
         {\(\mach, (\mathit{Catch} \addr_{buf} ~ a_{pc} ~ a_{sp}, V)::\context \constep{\psi} \context\)}

\judgment[ThrowExCDone]
         {\(\psi = \mathbf{throwex} ~ \addr_{buf}\)}
         {\(m, [\mathit{Done},V] \constep{\psi} [\mathit{Done},V]\)}

\judgmenttwo[ThrowExCSkip]
         {\(\psi = \mathbf{throwex} ~ \addr_{buf}\)}
         {\(\mach, \context \constep{\psi} \context'\)}
         {\(\mach, (\_::\context) \constep{\psi} \context'\)}
         
\caption{Exception context updates}
\label{fig:excontexts}
\end{figure*}

\section{Tail Call Elimination}

I submit that tail calls will work perfectly fine with all of our definitions
using the context update in Figure \ref{fig:tailcallcontexts}. All of the
``until return'' stuff works fine, because all the calls return at once.
We need to define callee confidentiality still.

\begin{figure*}

\judgmenttwo[TailCallC]
            {\(\psi = \mathbf{tailcall} ~ r_{target} ~ \overline{r_{args}}\)}
            {\(V' = \mathit{update\_view} ~ V ~ m[sp] ~ \overline{r_{args}}\)}
            {\(\mach, (T,V)::\context \constep{\psi} (T,V')::\context\)}

\caption{Tailcall context updates}
\label{fig:tailcallcontexts}
\end{figure*}

\section{Provenance, Capabilities, and Protecting Objects}

So far, we have given functions the ability to allocate completely unprotected
objects. What if we want to express a finer-grained notion of safety, in which
such objects are protected unless the function that owns them intentionally
passes a pointer to them?

In order to express such a property, we need our machine to carry some notion
of {\it pointer provenance} -- a distinction between a pointer that is intended to
point to a given object, and non-pointer integers as well as pointers to other objects.

\section{Simple Concurrency}

\bibliographystyle{IEEEtran}
\bibliography{bcp.bib,local.bib}

\end{document}
