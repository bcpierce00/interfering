%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[10pt,conference]{ieeetran}%\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{amsmath,amsthm,amssymb}

\usepackage{xcolor,listings}

\usepackage{multirow}

\usepackage{stmaryrd}

\usepackage[noadjust]{cite}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\input{macros}

\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\begin{document}

%% Title information
\title{Formalizing Stack Safety as a Security Property}

\author{
  \IEEEauthorblockN{
    Sean Noble Anderson
  }
  \IEEEauthorblockA{
    Portland State University\\
    ander28@pdx.edu\\
  }
  \and
  \IEEEauthorblockN{
    Leonidas Lampropoulos
  }
  \IEEEauthorblockA{
    University of Maryland, College Park\\
    leonidas@umd.edu\\
  }
  \and
  \IEEEauthorblockN{
    Roberto Blanco
  }
  \IEEEauthorblockA{
    Max Planck Institute for Security and Privacy\\
    roberto.blanco@mpi-sp.org\\
  }
  \linebreakand
  \IEEEauthorblockN{
    Benjamin C. Pierce,
  }
  \IEEEauthorblockA{
    University of Pennsylvania\\
    bcpierce@cis.upenn.edu\\
  }
  \and
  \IEEEauthorblockN{
    Andrew Tolmach
  }
  \IEEEauthorblockA{
    Portland State University\\
    tolmach@pdx.edu\\
  }
}



%% Keywords
%% comma separated list
\ifcameraready
\keywords{Stack Safety, Micro-Policies}  %% \keywords are mandatory in final camera-ready submission
\fi

\maketitle

\section{Threat Model, Machines, and Enforcement }

Before introducing our formal model of stack safety, we describe
our machine exemplar, enforcement mechanism, and threat model.

We begin with a RISC-V-like machine enhanced with PIPE, a tag-based reference
monitory. We extend this machine with a {\it security overlay semantics}:
a semantics in which calls, returns, and other operations of interest are condensed
into atomic {\it macro-instructions}, which update an additional security context.
As opposed to a fully-abstract overlay semantics, in which the semantics is safe
by construction and compilation to an enforcement mechanism must be proved fully abstract,
our machine's semantics are not safe unless the tag policy is correctly
instantiated, but the security context informs trace properties that
must hold under a policy for that policy to be considered valid.

The underlying machine is a standard RISC-V ISA as modeled in [MIT-RISCV].
Our overlay semantics provide macro-instructions for the following code features:
\begin{itemize}
\item Function calls and returns, with caller- and callee-saved registers according
  to the RISC-V ABI
\item Arguments passed by reference
\item Exceptions
\item Coroutines and cooperative threading
\item Tail-call Elimination
\end{itemize}

\paragraph*{What is a ``call''?} Some ISAs have a single ``call''
instruction that does all the required manipulation of the program counter
(\(\PCname\)) and stack pointer; others perform a series of instructions
whose constituent opcodes may be used in some places for other purposes.
Our RISC-V machine is the latter, so calls must be explicitly designated
as such by the compiler, by identifying them as macro-instructions.
The same goes for other operations, such as exceptions and coroutine yields.
Macro-instructions connect the enforcement mechanism to the property: we don't
expect the enforcement mechanism to provide any guarantees for code sequences
that resemble calls or returns, but which are not macro-instructions.

Because macro-instructions must be generated by the compiler, they only
carry data that can be known by the compiler at compile-time. For example,
the \(\mathbf{call}\) macro-instruction identifies the register \(r\) containing
the address of the function to be called, as well as a {\it type record} identifying
the registers and addresses in which the callee expects to find arguments,
and a {\it public set}.
Let \(tr \in TR\) be a type record; then \(tr.args\) is a set of those registers
that will be used for arguments, and \(tr.stack\_args\) defines a set of
offsets from the stack pointer that are expected to contain additional
arguments.The public set \(pubs\) defines a similar set of offsets in
the caller that are declared public and not to be protected.

%\paragraph*{Enforcement Model and Properties}

%A machine state consists of the standard addresses and registers, as well as
%additional policy state used by the enforcement mechanism. Our properties
%refer only to addresses and registers; they do not constrain the behavior
%of policy state. We model an execution step as a partial function on states:
%when the machine does not step from a given state, this
%is a {\em failstop}, halting the program before it can perform an
%action that would violate the security property.
%our properties are therefore naturally \emph{termination insensitive.}

\paragraph*{Threat Model}

We trust the compiler has correctly placed macro-instructions according to
the semantics of the source language, but we do not assume that the code
is otherwise reasonable. In particular, while we are agnostic as to the source
language, C is very plausible, and so any source function might contain undefined
behavior resulting in its compilation to arbitrary machine code.

In general, it is impossible to distinguish buggy source code from an attacker;
we assume nothing about the intent of the source code, except that it makes calls
and returns, and guarantee that the caller and callee are protected from one
another.

This is a strong threat model, but hardware and timing attacks are out of scope,
and our properties are termination insensitive as a result of the enforcement mechanism
(below).

\paragraph*{Limitations}

We do not support dynamic code generation or concurrency---we can handle a
limited form of coroutines, but not full-blown preemptive concurrency.
[Say something about Heap Safety]

\subsection{The Machine in Detail}
\label{sec:prelim}

The building blocks of the machine are {\em words} and {\em registers}.
Words are 64-bit integers ranged over by \(w\) and, when used as addresses,
\(a\). There are 32 registers, ranged over in general by \(r\),
plus a program counter (\(\PCname\)). The following table divides
the registers into metavariables, some belonging to caller- or callee- sets:

\vspace{\abovedisplayskip}
\begin{tabular}{| l | l | l |}
  \hline
  Set & Names & Purpose \\
  \hline
  CLR\_SV & \(rt_0 - rt_6\) & Caller-saved temps \\
  & \(ra_0 - ra_1\) & Caller-saved args / return vals \\
  & \(ra_2 - ra_7\) & Caller-saved args \\
  \hline
  CLE\_SV & \(rs_0 - rs_7\) & Callee-saved \\
  \hline
  PUBLIC & \(rra\) & Return Address \\
  & \(rsp\) & Stack Pointer \\
  & \(pc\) & Program Counter \\
  \hline
\end{tabular}
\vspace{\abovedisplayskip}

Collectively addresses and registers are {\em state elements} \(\component\)
in the set \(\COMPONENTS ::= \WORDS + \REGS\).
%
A {\em machine state} \(\mach \in \MACHS ::= \COMPONENTS \rightarrow \WORDS\)
is a mapping from state elements to values. For convenience, we abbreviate
multiple updates \(m[\component_0 \mapsto \word_0][\component_1 \mapsto \word_1]\dots\)
as \(m \llbracket A \mapsto B | C \rrbracket\), where \(A\) and \(B\)
are fomulae with free variables bound to sets in \(C\).

The machine is equipped with additional state representing the tag-based hardware.
We represent this as a policy state, \(\pol \in \POLS ::= \COMPONENTS \rightarrow \mathcal{T}\),
where \(\mathcal{T}\) is the set of tags, discussed [in the section on security.]
We represent a {\it policy} via the step relation
\(\cdot, \cdot \rightharpoonup_P \cdot \subseteq \MACHS \times \POLS \times \POLS\).
Steps are deterministic and  undefined represents a {\it failstop}.

Separate from the machine state, we keep track of additional security context
information over the course of the run. This data is not relevant to execution,
it is only used to define the stack safety property. We define a set of
{\it security classes}:
\[sc \in SEC ::= \sealed | \passed | \mathit{public} | \unsealed\]
And of {\it targets}, which identify the addresses of the program counter or
stack pointer at a return or catch point:
\[\begin{split}
tar \in TAR ::= & \mathit{Return} ~ a_{pc} ~ a_{sp} \\
| & \mathit{Catch} ~ a_{pc} ~ a_{sp} \\
\end{split}\]
A {\it security view} \(V \in \mathit{VIEW} ::= \COMPONENTS \rightarrow SEC\) divides the machine
elements in terms of their purpose relative to the active function.
And a security context is a stack of pairs of targets and views:
\[\context \in \CONTEXTS ::= \mathit{list} ~ (\mathit{TAR} \times \mathit{VIEW})\]

The set of instructions, \(I\), contains the RISC-V ISA. We further introduce a set
a set \(J\) of {\it overlay sequences}: sequences of instructions that operate as if
they were single, atomic pseudoinstructions. Overlay sequences are {\it calls},
{\it returns}, {\it tailcalls}, exception {\it catches} and {\it throws},
and object {\it allocs}, and each carries a sequence of instructions
that implements the operation. When 



\begin{figure}
  \begin{tabular}{| l | l l |}
    \hline
    Macro & \multicolumn{2}{|l|}{Parameters} \\
    \hline
    \multirow{3}{*}{\(\mathbf{call}\)}
    & \(\reg\) & Register containing destination \\
    & \(tr\) & Type record \\
    \hline
    \multirow{3}{*}{\(\mathbf{tailcall}\)}
    & \(\reg\) & Register containing destination \\
    & \(tr\) & Type record \\
    \hline
    \multirow{2}{*}{\(\mathbf{enter}\)}
    & \(tr\) & Type record \\
    \hline
    \(\mathbf{return}\)
    & \(pubs\) & Public set \\
    \hline
    \(\mathbf{yield}\) & & \\
    \(\mathbf{setex}\) & & \\
    \(\mathbf{throwex}\) & & \\
    \hline
  \end{tabular}
  \caption{Macro-instructions}
  \label{fig:macros}
\end{figure}

Each of these types of state is combined in to a triple called an
MPC-state, \(\mpcstatename \in \MPCS ::= \MACHS \times \POLS \times \CONTEXTS\).
Execution is modeled by a partial step function between MPC-states,
written \(\mach, \pol, \context \harpoonunder{} \mach', \pol', \context'\),
optionally annotated with a macro-instruction \(\harpoonunder{j}\).
If \(\mach[\PCname]\) decodes to an instruction, then execution follows
the RISC-V semantics and the policy, without touching the security context.

\judgmentthree[]
              {\(\mathit{decode} ~ \mach ~ \mach[\PCname] \in I\)}
              {\(\mach \stepstounderfull \mach'\)}
              {\(\mach,\pol \rightharpoonup_P \pol'\)}
              {\(\mach,\pol,\context \harpoonunder{} \mach',\pol',\context\)}

If, for some \(j\), \(\mach[\PCname + i]\) decodes to \(j_i\) for all \(i\) between 0 and
\(\mathit{size}(j)\), written \(\mathit{decode*} = j\), then the step is via a special
multi-step. We present these steps as separate step relations:
\(\cdot \harpoonunder{\cdot}_M \cdot \in \MACHS \times J \times \MACHS\) to step
the machine state,
\(\cdot, \cdot \harpoonunder{\cdot}_P \cdot \in \MACHS \times \POLS \times J \times \POLS\)
for the policy state, and
 \(\cdot, \cdot \stepstounder{j}_C \cdot \in \MACHS \times \CONTEXTS \times J \times \CONTEXTS\)
for the security context. We then combine them:

\judgmenttwobr[]
               {\(\mathit{decode*} = j\)}
               {\(\mach \harpoonunder{j}_M \mach'\)}
               {\(\mach,\pol \rightharpoonup_P \pol'\)}
               {\(\mach',\context \stepstounder{j}_C \context'\)}
               {\(\mach,\pol,\context \harpoonunder{j} \mach',\pol',\context'\)}

In this section we will define \(\harpoonunder{j}_M\) for our machine; \(\harpoonunder{j}_P\)
for the relevant policies will be discussed in [enforcement section], and \(\stepstounder{j}_C\)
in Section \ref{sec:properties}.

\paragraph*{Macro-step machine steps}

Here we give the semantics of the machine side of the macro step for calls and returns.
The machine multi-step for a call (\ref{fig:callmacro}) updates the stack pointer
and program counter, and zeros non-argument, caller-save registers. (This means that
the caller should have saved them before initiating the call.)

\vspace{\abovedisplayskip}
\judgmentbrbr[CallM]
             {\(j = \mathit{decode}^* ~ m ~ m[pc] = \mathbf{call} ~ r ~ tr ~ pubs\)}
             {\(m' = m[rra \mapsto m[pc] + 4]\)}
             {\(m'' = m' \llbracket r \mapsto 0 | r \in CLR\_SV - tr.args \rrbracket\)}
             {\(m \harpoonunder{j}_M m''[pc \mapsto m[r]]\)}
\vspace{\belowdisplayskip}

Then, on enter, the callee stores the stack pointer and callee-save registers,
and allocates new stack space.

\vspace{\abovedisplayskip}
\judgmentbrbrbr[EnterM]
               {\(j = \mathit{decode}^* ~ m ~ m[pc] = \mathit{enter} ~ tr\)}
               {\(m' = m[m[sp] \mapsto m[rra]]\)}
               {\(m'' = m\llbracket m[m[sp]+i+1 \mapsto m[rs_i] | 0 \leq i < 8 \rrbracket\)}
               {\(m''' = m''[sp \mapsto m[sp]+n+9]]\)}
               {\(m \harpoonunder{j}_M m'''[pc \mapsto m[pc]+4*\mathit{size}(j)]\)}
\vspace{\belowdisplayskip}

Finally, on return, the program counter and register contents are restored from the stack,
and the callee's frame is deallocated.

\vspace{\abovedisplayskip}
\judgmentbrbr[ReturnM]
             {\(j = \mathit{decode}^* ~ m ~ m[pc] = \mathit{return} ~ n\)}
             {\(m' = m[sp \mapsto m[sp]-n-9]\)}
             {\(m'' = m\llbracket m[rs_i] \mapsto m[m[sp]+i+1 | 0 \leq i < 8 \rrbracket\)}
             {\(m \harpoonunder{j}_M m''[pc \mapsto m''[sp]]\)}
\vspace{\belowdisplayskip}

%For the context step, the macro-instruction additionally identifies which objects
%(contiguous regions defined relative to the stack pointer) have been placed there
%as: arguments that overflowed to the stack (\(sargs\)), which are existing objects
%passed by reference (\(pbrs\)), and which are marked public (\(pubs\)). We use this
%information to construct the callee's security view.
%\[obj \in OBJ ::= \mathbb{Z} \times \mathbb{Z}\]
%\[in\_obj ~ a_{sp} ~ (lo, hi) ~ a \triangleq a_{sp} - lo \leq a < a_{sp} - hi\]
           
%\judgmenttwobrlong[Return]
%                    {\(m' = m[sp \mapsto m[sp] - \mathit{size}(frsize)]\)}
%                    {\(m'' = m \llbracket r \mapsto 0 | r \not \in args \land r \in caller \rrbracket\)}
%                    {\(\mathit{decode}^* ~ m ~ pc = \mathit{return} ~ frsize\)}
%                    {\(m \stepsto_M m'[pc \mapsto f]\)}

%If \(\mathit{decode}\) is undefined on that value, \(\mach \stepsto \mach\). The
%only times \(\stepsto\) is undefined is when there is a policy fault,
%(and the machine ``failstops'') or when it attempts to begin executing a
%macro-instruction out of order. The latter represents a failstop in a lower-level
%policy in the underlying ISA, which guarantees that the macro-instruction
%executes in order.

\paragraph*{Compiling Macro-instructions}

Every macro-instruction is associated with a sequence of normal RISC-V instructions
of the appropriate length, so compiling from the macro-instruction machine to normal
RISC-V is as simple as replacing \(j_i\) with its corresponding instruction, tagged
as a ``blessed sequence'' -- a standard tag-based enforcement mechanism that guarantees
that instructions may {\it only} step in the appropriate order.

\paragraph*{Machine and Observation Traces}
\label{sec:traces}

A {\em machine trace} is a nonempty, finite or infinite sequence
of states, ranged over by \(\MPCT\) and \(\NPCT\).
We use ``\(\notfinished{}{}\)'' to represent ``cons'' for traces, reserving ``::''
for list-cons. An {\em event trace} \(\obsT\) is a similar sequence of
events \(\obs \in \OBSS\), which are defined as follows:

\[\begin{split}
\obs \in \OBSS ::= & ~ \mathbf{callE} ~ a_{dst} ~ \overline{w_{args}} \\
| & ~ \tau \\
\end{split}\]

%This system of observations resembles that used by CompCert [cite], in that
%the observable behaviors of the system are calls and returns (in our case, not
%distinguishing between internal and external, and including exceptions), as well
%as a special output akin to storing to volatile memory. We add the silent observation
%\(\tau\).

We convert macro-instructions into events via the \(\mathit{observe}\)
function, observing the values of relevant registers, defined in Figure \ref{fig:observe}.

\begin{figure*}
\[\mathit{observe} ~ j ~ m =
\begin{cases}
  \mathbf{callE} ~ m[r] ~ m \llbracket k | k \in tr.args \lor m[rsp] - k \in tr.sargs \rrbracket
  & \textnormal{when } ~ j = \mathbf{call} ~ r ~ tr ~ pubs \\
  \tau & \textnormal{otherwise} \\
\end{cases}\]
\label{fig:observe}
\end{figure*}

The ``trace-of'' operator, written \(\mpcstatename \hookrightarrow \MPCT \),
coinductively relates an initial state with the trace of states
produced by repeated application of \(\rightharpoonup\):

\judgmenttwo{\(\mpcstatename \rightharpoonup \mpcstatename'\)}
            {\(\mpcstatename' \hookrightarrow \MPCT \)}
            {\(\mpcstatename \hookrightarrow \notfinished{\mpcstatename'}{\MPCT} \)}%
\judgment%[Default]
         {\(\not\exists \mpcstatename'. \mpcstatename \stepstocon \mpcstatename'\)}
         {\(\mpcstatename \hookrightarrow \mpcstatename\)}

We project out the machine state of an MC-state with \(\pi_\mach\)
and the context with \(\pi_\context\).
We extract the first entry from a trace with \(\head(\MPCT)\), which is a total
function since traces are non-empty, and the final entry (if one exists) with
\(\last(\MPCT)\), which is partial, since traces may be infinite.

\paragraph*{Observations-Of}

This operator, written \(\obsof\), takes a machine trace and
gives the trace of events of each step in
the trace. It uses a coinductive helper \(\mathit{obsfor}\) that relates an
initial event, a machine-trace, and an event trace; the helper is
then invoked with an initial \(\tau\).

\judgmenttwobrlong{\(\mpcstatename \harpoonunder{j} \mpcstatename'\)}
                  {\(\mpcstatename' \hookrightarrow \MPCT\)}
                  {\(\mathit{obsfor} ~ (\mathit{observe} ~ \pi_m(\mpcstatename) ~ j) ~ \MPCT = \obsT\)}
                  {\(\mathit{obsfor} ~ \obs ~ \notfinished{\mpcstatename}{\MPCT} = \notfinished{\obs}{\obsT}\)}

\begin{minipage}[b]{.4\columnwidth}
  \judgment{}
           {\(\mathit{obsfor} ~ \obs ~ \mpcstatename = \obs\)}
\end{minipage}
\begin{minipage}[b]{.4\columnwidth}
\judgment{\(\mathit{obsfor} ~ \tau ~ \MPCT = \obsT\)}
         {\(\obsof(\MPCT) = \obsT\)}
\end{minipage}

\paragraph*{Observational Similarity}

We say that two event traces $\obsT_1$ and $\obsT_2$ are {\em similar}
from the perspective of an external observer, written \(\obsT_1 \eqsim
\obsT_2\), if the sequence of non-silent events is the same. That is, we
compare up to deletion of \(\tau\) events, coinductively:

\begin{minipage}{.4\columnwidth}
  \judgment{}{\(\obsT \eqsim \obsT\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\tau}{\obsT_1} \eqsim \obsT_2\)}
\end{minipage}

\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\obsT_1 \eqsim \notfinished{\tau}{\obsT_2}\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\obs}{\obsT_1} \eqsim \notfinished{\obs}{\obsT_2}\)}
\end{minipage}

Note that an infinite silent trace is a
prefix of (and similar to) any other trace. While this might seem
surprising at first, it makes sense in a timing-insensitive context:
an external observer looking at two machine runs cannot (computably)
distinguish between a machine that steps forever and a machine that
steps for a long time before producing some output.

\paragraph*{Reachability}

We often want to quantify over all traces from any initial state so that our
properties apply to the system as a whole. We say that a state \(\mpcstatename'\)
is {\em reachable} if, for some initial state \(\mpcstatename = \mach,\pol,[]\)
where \(\mach\) is well-formed, \(\mpcstatename \hookrightarrow \MPCT\)
and \(\MPCT\) contains \(\mpcstatename'\).

\section{Stack Safety, Formally}
\label{sec:properties}

Now we can give our definition of stack safety. Each macro-instruction defines a
context step; in turn, the context at the point of a call or return defines a trace
property each for integrity, confidentiality, and well-bracketed control flow.
The context updates involved in calls and returns are given in Figure \ref{fig:callcontexts}.
First, we define a function, {\it update view}, that defines the view of a callee.
Addresses that, offset from stack pointer, are in public regions are marked
\(\mathit{public}\). Those that are being passed on the stack are marked
\(\mathit{passed}\). [When I add pass-by-reference arguments, we will use
the recursive \(V\)]

To update the context, we pair the updated view with the return target of the
call: the return target tells us whether a return is to the proper location
which the stack pointer restored, and the view tells us how to treat the
security of the callee's state.

\begin{figure*}
\[\begin{split}
& \mathit{update\_view} ~ V ~ a_{sp} ~ tr ~ pubs \triangleq
 \lambda \component .
\begin{cases}
  \mathit{public} & \textnormal{if } \component \in \WORDS \textnormal{ and }
  (a_{sp} - \component) \in pubs \\
%  \passed & \textnormal{else if } \component \in \WORDS \textnormal{ and }
%  in\_obj ~ a_{sp} ~ pbr ~ \component \textnormal{ for some } pbr \textnormal{ in } pbrs \\
  \passed & \textnormal{else if } \component \in \WORDS \textnormal{ and }
  (a_{sp} - \component) \in tr.sargs \\
  \sealed & \textnormal{else if } \component \in \WORDS \textnormal{ and } \component < a_{sp} \\
  \mathit{public} & \textnormal{else if } \component \in \REGS \textnormal{ and }
  \component \in tr.args \textnormal{ or } \component \in \mathit{PUBLIC} \\
  \unsealed & \textnormal{otherwise} \\
\end{cases} \\
\end{split}\]

\judgmenttwobrlong[CallCCons]
           {\(V' = \mathit{update\_view} ~ V ~ m[sp] ~ tr ~ pubs\)}
           {\(j = \mathbf{call} ~ r ~ tr\)}
           {\(\context' = (\mathit{Return} ~ (m[pc] + 4) ~ m[sp], V')::(tar,V)::\context\)}
           {\(m, (tar,V)::\context \stepstounder{j}_C \context'\)}

\judgmenttwobrlong[CallCNil]
           {\(V' = \mathit{update\_view} ~ (\lambda \component . \unsealed) ~ m[sp] ~ tr ~ pubs\)}
           {\(j = \mathbf{call} ~ r ~ tr ~ pubs\)}
           {\(\context' = (\mathit{Return} ~ (m[pc] + 4) ~ m[sp], V')::[]\)}
           {\(m, [] \stepstounder{j}_C \context'\)}
                             
\judgment[EnterC]
         {\(j = \mathbf{enter} ~ tr ~ n\)}
         {\(m,c \stepstounder{j}_M c\)}

\judgmentthree[ReturnCValid]
              {\(m[pc] = a_{pc}\)}
              {\(m[rsp] = a_{sp}\)}
              {\(j = \mathbf{return} ~ pubs\)}
              {\(m, (\mathit{return} ~ a_{pc} ~ a_{sp}, V)::\context \stepstounder{j}_C \context\)}

\judgmenttwobrlong[ReturnCInvalid]
                  {\(m[pc] \not = a_{pc} \lor m[rsp] \not = a_{sp}\)}
                  {\(j = \mathbf{return} ~ pubs\)}
                  {\(V' = V \llbracket r \mapsto \unsealed | r \in \{pc, rsp\} \rrbracket\)}
                  {\(m, (\mathit{return} ~ a_{pc} ~ a_{sp}, V)::\context \stepstounder{j}_C (\mathit{return} ~ a_{pc} ~ a_{sp}, V')::\context\)}

\judgmenttwo[ReturnCNil]
            {\(V' = \lambda \component . \unsealed\)}
            {\(j = \mathbf{return} ~ pubs\)}
            {\(m, [] \stepstounder{j}_C []\)}
           
\caption{Call, enter, and return macro-instructions}
\label{fig:callcontexts}
\end{figure*}

\paragraph*{Eventual Integrity}

The intuition behind eventual integrity is that, when control is passed from the
caller to the callee, the caller doesn't necessarily need its data to remain intact --
as long as they are restored by the time control returns to it. We define this as a more
general notion of {\it eventual integrity.}

Let \(R \subseteq \CONTEXTS\) be a predicate on contexts, representing the condition at
which integrity must be restored, and \(I\) be a predicate on states defining what integrity
means. Then we find the first state on which \(R\) holds on the context and assert that
\(I\) also holds on the machine state, with the \(\mathit{when}\) relation.

\judgmenttwo{\(R ~ \context\)}
            {\(I ~ \mach\)}
            {\(\mathit{when} ~ R ~ I ~ (\mach,\pol,\context)\)}

\judgmentthree{\(\neg R ~ \context\)}
              {\((\mach,\pol,\context) \rightharpoonup \mpcstatename\)}
              {\(\mathit{when} ~ R ~ I ~ \mpcstatename\)}
              {\(\mathit{when} ~ R ~ I ~ \mpcstatename\)}

\definition Let \(\components\) be a set of elements and \((\mach,\pol,\context)\)
be the first state of a new call. We define \(R\) to hold on those states
\((\mach',\pol',\context')\) where \(|\context'| < |\context|\). And we define
\(I\) to hold when \(\mach[\component] = \mach'[\component]\) for all elements
\(\component \in \COMPONENTS\). Then \((\mach,\pol,\context)\) enjoys eventual
integrity of \(\components\) if \(\mathit{when} ~ R ~ I ~ (\mach,\pol,\context)\).

Howver, eventual integrity is not sufficient to express the integrity protected by
Lazy Tagging, because it is possible that values in memory are overwritten -- but
are also guaranteed never to be accessible. We need to define a slightly weaker property.

\paragraph*{Variants and Transient Elements}

One or more elements of a given state are {\it transient} if their values
in that state have no observable influence on future execution. We define this
formally as a sort of non-interference: for a state \(\mpcstatename\) and
a set of elements \(\components\), \(\mathit{transient} ~ \mpcstatename ~ \components\)
holds if we can replace the contents of \(\components\) with arbitrary values
and have the resulting state produce an equivalent trace. The state created
by modifying \(\components\) in this way is termed a variant.

\definition Machine states \(\mach\) and \(\nach\) are {\em \(\components\)-variants},
written \(\mach \approx_\components \nach\), if, for
all \(\component \not \in \components\), \(\mach[\component] = \nach[\component]\).

\definition An elements set \(\components\) is transient in state \((\mach,\pol,\context)\),
written \(\mathit{transient} ~ (\mach,\pol,\context) ~ \components\), if for all
\(\nach\) such that \(\mach \approx_{\components'} \nach\), if 
\((\mach,\pol,\context) \hookrightarrow \MPCT\) and
\((\nach,\pol,\context) \hookrightarrow \NPCT\), then
\(\obsof(\MPCT) \eqsim \obsof(\NPCT)\).

\definition Let \(\Delta(\mach,\mach')\) be the set of elements \(\component\)
such that \(\mach[\component] \not = \mach'[\component]\).

\definition Let \(\components\) be a set of elements and \((\mach,\pol,\context)\)
be the first state of a new call. We define \(R\) to hold on those states
\((\mach',\pol',\context')\) where \(|\context'| < |\context|\). And we define
\(I\) to hold on \(\mach'\) when \(\Delta(\mach,\mach') \cap \components\) is transient
with respect to \(\mach'\). Then \((\mach,\pol,\context)\) enjoys
{\it eventual intransient integrity} of \(\components\) if
\(\mathit{when} ~ R ~ I ~ (\mach,\pol,\context)\).

\definition A system enjoys {\it observational stack integrity} if, for all
reachable states \(\mpcstatename\) such that
\(\mpcstatename \harpoonunder{\mathbf{Call}\dots} (\mach,\pol,(tar, V)::\context)\),
\((\mach, \pol, (tar, V)::\context)\) enjoys eventual intransient integrity with
respect to the set of components that \(V\) maps to \(\sealed\).

\paragraph*{Temporary Confidentiality}

Confidentiality properties are also modeled as non-interference, but with a twist:
the caller's confidential data should be kept secret from the callee, but after return,
will naturally be accessible to the caller once again. So, we must model confidentiality
in terms of events inside the callee. But confidentiality violations might not become
visible during the callee's lifetime -- the callee might read a secret and stash it somewhere
that it will be accessed later. So we must also consider the machine state at the end
of the call. First we'll define a useful general property that implements this structure,
similar to \(\mathit{when}\), called \(\mathit{during\_both}\).

\(\mathit{during\_both}\) relates two initial states in their traces up until they
both reach an end condition, again defines by a predicate \(R\). Instead of \(I\)
we have an event-trace relation \(E\) that must relate the event traces up through
\(R\), and a final relation \(F\) that must relate the final states.

\definition Let \(\mpcstatename\) and \(\npcstatename\) be initial states
and \(R\) be a predicate on states such that
\(\mpcstatename \hookrightarrow \MPCT | R\) and
\(\npcstatename \hookrightarrow \NPCT | R\).
Let \(E\) be a relation on event traces, and \(F\) be a relation on machine states.
Then \(\mathit{during\_both} ~ \mpcstatename ~ \npcstatename ~ R ~ E ~ F\) holds if both:
\begin{itemize}
\item \(E ~ (\obsof \MPCT) ~ (\obsof \NPCT)\) holds
\item And, if \(\last ~ \MPCT = (\mach,\_,\_)\) and \(\last ~ \NPCT = (\nach,\_,\_)\),
  then \(F ~ \mach ~ \nach\) holds.
\end{itemize}

We could define a natural, strict form of confidentiality that requires that the final
states be identical. However, as with integrity, this is stricter than we need -- there
may be some conditions in which a secret is copied, but never used again. So, we once
again wish for our final condition to make the values {\it transient}. Which values?

\definition Let \(\mach,\mach'\) and \(\nach,\nach'\)
be pairs of states. Their {\em unsafe set}, written
\(\bar{\Diamond}(\mach,\mach',\nach,\nach')\), is the set of all elements
\(\component \in \Delta(\mach,\mach') \cup \Delta(\nach,\nach')\) such that
\(\mach'[\component] \not = \nach'[\component]\).

\definition Let \((\mach,\pol,\context)\) be a state and \(\components\) be a set of
elements. Let \(R\) hold on contexts \(\context'\) such that \(|\context'| < |\context|\).
Let \(E \triangleq ~ \simeq\).
Let \(F ~ \mpcstatename ~ \npcstatename \triangleq
\mathit{transient} ~ \mpcstatename ~
\bar{\Diamond}(\mach,\pi_m(\mpcstatename),\nach,\pi_m(\npcstatename))\).

\((\mach,\pol,\context)\) enjoys {\it temporary confidentiality} of \(\components\)
if, for all \(\nach\) such that \(\mach \approx_{\components} \nach\),
\(\mathit{during\_both} ~ R ~ E ~ F\).

\definition A system enjoys {\it observational caller confidentiality} if, for all
reachable states \(\mpcstatename\) such that
\(\mpcstatename \harpoonunder{\mathbf{Call}\dots} (\mach,\pol,(tar, V)::\context)\),
\((\mach, \pol, (tar, V)::\context)\) enjoys temporary confidentiality with
respect to the set of components that \(V\) maps to \(\unsealed\) or \(\sealed\).

\bibliographystyle{IEEEtran}
\bibliography{bcp.bib,local.bib}

\end{document}
