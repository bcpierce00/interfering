%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[10pt,conference]{ieeetran}%\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{amsmath,amsthm,amssymb}

\usepackage{xcolor,listings}

\usepackage{multirow}

\usepackage{stmaryrd}

\usepackage[noadjust]{cite}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\input{macros}

\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\begin{document}

%% Title information
\title{Formalizing Stack Safety as a Security Property}

\author{
  \IEEEauthorblockN{
    Sean Noble Anderson
  }
  \IEEEauthorblockA{
    Portland State University\\
    ander28@pdx.edu\\
  }
  \and
  \IEEEauthorblockN{
    Leonidas Lampropoulos
  }
  \IEEEauthorblockA{
    University of Maryland, College Park\\
    leonidas@umd.edu\\
  }
  \and
  \IEEEauthorblockN{
    Roberto Blanco
  }
  \IEEEauthorblockA{
    Max Planck Institute for Security and Privacy\\
    roberto.blanco@mpi-sp.org\\
  }
  \linebreakand
  \IEEEauthorblockN{
    Benjamin C. Pierce,
  }
  \IEEEauthorblockA{
    University of Pennsylvania\\
    bcpierce@cis.upenn.edu\\
  }
  \and
  \IEEEauthorblockN{
    Andrew Tolmach
  }
  \IEEEauthorblockA{
    Portland State University\\
    tolmach@pdx.edu\\
  }
}



%% Keywords
%% comma separated list
\ifcameraready
\keywords{Stack Safety, Micro-Policies}  %% \keywords are mandatory in final camera-ready submission
\fi

\maketitle

\section{Threat Model, Machines, and Enforcement }

Before introducing our formal model of stack safety, we describe
our machine exemplar, enforcement mechanism, and threat model.

We begin with a RISC-V-like machine enhanced with PIPE, a tag-based reference
monitor. We extend this machine with a {\it security overlay semantics},
which divides a program into dynamic {\it principals} that ought to be
protected from one another, and specifies that protection over a set
of abstract {\it overlay operations}. Specifications may take the form of
predicates on future states: statements of the form,
``When control returns to me...'', or of relations on traces of future execution
(hyper-properties.)

As opposed to a fully-abstract overlay semantics, in which overlay operations
are given safe-by-construction semantics then proven fully abstract,
our machine is not safe unless the monitor is correctly instantiated;
the overlay gives us the means to distinguish a monitor that implements
stack safety from one that does not.

The underlying machine is a standard RISC-V ISA as modeled in [MIT-RISCV].
Our overlay semantics provide overlay operations for the following code features:
\begin{itemize}
\item Function calls and returns, with caller- and callee-saved registers according
  to the RISC-V ABI
\item Arguments passed by reference
\item Exceptions
\item Tail-call Elimination
\end{itemize}

\paragraph*{Threat Model}

We trust the compiler has correctly placed macro-instructions according to
the semantics of the source language, but we do not assume that the code
is otherwise reasonable. In particular, while we are agnostic as to the source
language, C is very plausible, and so any source function might contain undefined
behavior resulting in its compilation to arbitrary machine code.

In general, it is impossible to distinguish buggy source code from an attacker;
we assume nothing about the intent of the source code, except that it makes calls
and returns, and we must guarantee that the caller and callee are protected from one
another.

This is a strong threat model, but hardware and timing attacks are out of scope,
and our properties are termination insensitive as a result of the enforcement mechanism
(below).

\paragraph*{Limitations}

We do not support dynamic code generation, and our concurrency model is fairly
simplistic, assuming a fixed number of threads each with its own dedicated processor.
We model memory safe stack objects, but not a heap. Regions outside of
stacks can be used however the compiler likes, including as a heap, but no protection is
built in and our properties assume that if a pointer to a stack object is stored there,
it is permanently compromised.

\subsection{Security Overlay Semantics}

A security overlay semantics divides a program's execution into principals,
in this case function activations, and identifies which principal is active
in a given state. Overlay operations can generate new principals, transition
which principal is active, and allocate stack objects belonging to the active
principal. From this information, we derive the specifications that make up
stack safety. Specifications may take the form of predicates on
future states: statements of the form, ``When control returns to me...'',
or of relations on traces of future execution (hyper-properties.)

What this means in practice is that the compiler that generates a piece of
code must identify some instructions as implementing the overlay operations.
In the likely event that the operation requires multiple instructions,
typically the {\it last} instruction will be labeled.

Let \(\Psi\) be the set of overlay operations ranged over by \(\psi\).
We begin with the base machine, whose states are drawn from a set \(\mathcal{M}\),
and which transitions via partial step function \(\rightharpoonup\).
We define the operation \(m[k]\) as accessing the word in register
or at address \(k\) in state \(m\). The compiler provides a partial map
\(\mathit{over} \in \mathcal{W} \rightharpoonup \Psi\).
We lift \(\rightharpoonup\) into a labeled transition
\(\harpoonunder{\psi?} \in \mathcal{M} \rightharpoonup
\mathcal{M} \times (\Psi + \bot)\) by labeling each
transition \(\mach \harpoonunder{\psi?} \mach'\) where
\(\psi = \mathit{over} ~ \mach[\PCname]\) if it is defined and \(\bot\) if not.

\paragraph{Starting Overlay Operations in the Middle}

The concrete implementation of an overlay operation might contain multiple instructions,
and its security guarantees may not hold if they are executed out of order.
In fact, they almost certainly will not! But only one instruction is labeled.
It is the responsibility of the monitor to guarantee that this instruction is
executed at the appropriate place in its sequence.

\paragraph{The Compiler's Responsibility}

The code that is acted on by a security overlay semantics is precisely that code
that the compiler provides, down to any instruction tags that are needed to enforce
the associated micro-policy. The compiler is also responsible for labeling overlay
operations as such. This puts the burden on the compiler to be aware
of the available overlay operations and use them intentionally. We give a
concrete example of one such labeling scheme in [Testing Section.]

\subsection{The Basic Machine}

The building blocks of the machine are {\em words} and {\em registers}.
Words (\(\WORDS\)) are 64-bit integers ranged over by \(\word\) and, when used as addresses,
\(\addr\). The processor has 32 registers, ranged over in general by \(\reg \in \REGS\),
plus a program counter (\(\PCname\)). The following table divides
the registers into metavariables, some belonging to caller- or callee- sets:

\vspace{\abovedisplayskip}
\begin{tabular}{| l | l | l |}
  \hline
  Set & Names & Purpose \\
  \hline
  CLR\_SV & \(rt_0 - rt_6\) & Caller-saved temps \\
  & \(ra_0 - ra_1\) & Caller-saved args / return vals \\
  & \(ra_2 - ra_7\) & Caller-saved args \\
  \hline
  CLE\_SV & \(rs_0 - rs_7\) & Callee-saved \\
  \hline
  PUBLIC & \(rra\) & Return Address \\
  & \(rsp\) & Stack Pointer \\
  & \(pc\) & Program Counter \\
  \hline
\end{tabular}
\vspace{\abovedisplayskip}

Collectively addresses and registers are {\em state elements} \(\component\)
in the set \(\COMPONENTS ::= \WORDS + \REGS\).
%
A {\em machine state} \(\mach \in \MACHS\) is a type that exposes a mapping
\(\mach[\component]\) from state elements to values, and may also contain additional
security state. For convenience, we abbreviate
multiple updates \(m[\component_0 \mapsto \word_0][\component_1 \mapsto \word_1]\dots\)
as \(m \llbracket A \mapsto B | C \rrbracket\), where \(A\) and \(B\)
are fomulae with free variables bound to sets in \(C\).
The base machine step function
\(\mach \stepstounder{\psi?} \mach' \in \MACHS \rightharpoonup \MACHS\) is partial to
represent the capacity of the machine to failstop, and may be labeled with an overlay
operation.
In order to accommodate failstop behavior, our properties will be {\it termination insensitive}.

\subsection{Overlay Operations, Principals, and Overlay State}

Overlay operations are drawn from a set \(\Psi\), as follows:

\begin{align*}
\psi \in \Psi ::= & \mathbf{call} ~ \reg_{target} ~ \overline{\reg_{args}} & \\
| & \mathbf{tailcall} ~ \reg_{target} ~ \overline{\reg_{args}} & \\
| & \mathbf{return} & \\
| & \mathbf{setex} ~ \addr_{buf} \\
| & \mathbf{throwex} ~ \addr_{buf} \\
| & \mathbf{alloc} ~ sizes & sizes \in \mathit{list} ~ \mathbb{N} \\
\end{align*}

Calls and tailcalls identify the target of the call, and the argument registers.
[Still a todo: stack arguments.] Return needs no further information. The operations
that setup and then throw to an exception handler take the address at which it is
stored. Alloc takes a list of sizes of objects to be allocated, because if allocating
objects means simply moving the function pointer, multiple
objects may be allocated at once.

Principals are function activations \(\alpha \in A\), with an operation
\(\mathit{fresh}\) that always generates a unique \(\alpha\).
Overlay state consists of a context stack, which contains the security-relevant
information associated with the active principal, and with inactive principals
waiting for control to return to them.

We define a set of {\it security classes}:
\[sc \in SEC ::= \public | \sealed | \unsealed | \mathit{object}\]

These indicate, from the perspective of the active principal, whether an element is
always accessible (\(\public\)), claimed by an inactive principal (\(\sealed\)),
available to be allocated and later sealed (\(\unsealed\)), or allocated by
the active principal (\(\mathit{object}\)).

A {\it security view} \(V \in \mathit{VIEW} ::= \COMPONENTS \rightarrow SEC\)
assigns each element a security class.

The {\it initial view} \(V_0\) maps all stack locations and non-public registers
to \(\unsealed\) and all other locations and public registers to \(\public\).

We additionally define a set of {\it targets}, which identify how a
principal expects to have control returned to it. This could be via a normal
return to the correct instruction \(\addr_{pc}\), or by catching the exception
whose state is saved at \(\addr_{buf}\). The \(\mathit{Active}\) target indicates
the active principal.

\[\begin{split}
tar \in TAR ::= & \mathit{Return} ~ a_{pc} \\
| & \mathit{Catch} ~ a_{buf} ~ a_{pc} \\
| & \mathit{Active} \\
\end{split}\]

Finally, a {\it context stack} is a non-empty stack of triples of an activation,
a target, and a view. The initial context stack \(\context_0 = (\mathit{fresh},\mathit{Active},V_0)\),
and the top target on the stack will always be \(\mathit{Active}\).
\[\context \in \CONTEXTS ::= \mathit{list} ~ (A \times \mathit{TAR} \times \mathit{VIEW})\]

We define an update function for context stacks indexed by an overlay operation.
This will be defined for each operation as we introduce them in detail.
\[\constep{\psi} \in \MACHS \times \CONTEXTS \times \Psi \rightarrow \CONTEXTS\]

From a machine state and a context stack, we create a {\it combined state} \((\mach,\context)\)
and a transition that steps the context according to the label on the transition,
if there is one, and otherwise maintains it.

\judgmenttwo[Overlay]
            {\(\mach \harpoonunder{\psi} \mach'\)}
            {\(\mach',\context \constep{\psi} \context'\)}
            {\((\mach,\context) \stepstounder{\psi} (\mach',\context')\)}

\judgment[Default]
         {\(\mach \harpoonunder{\bot} \mach'\)}
         {\((\mach,\context) \stepstounder{} (\mach',\context)\)}

\section{Context Updates With Calls, Returns, and Private Allocations}

In this section we will present the overlay steps for calls and returns.
They are given formally in Figure \ref{fig:callcontexts}.

In order to understand the motivation behind the call rule, though, we must first
describe how a function allocates objects. An allocation operation is parameterized
by a list of sizes; for each entry in the list, it marks an appropriate range
(based on offset from the stack pointer) as \(\mathit{object}\). This has no
direct bearing on the active principal, which may continue using the memory,
initialize it or not, and so on.

For calls, we define a function, {\it update view}, that defines the view
of a caller in terms of that of the callee. All argument registers are marked
\(\public\), along with all actual public registers. Callee-save registers,
including the stack pointer, are \(\sealed\); the callee is obligated to restore
them to their original value. The remaining caller-save registers are \(\unsealed\).

Then, all private objects are \(\sealed\), while the remainder of the stack retains
its old security context.

The formerly active principal is given a \(\mathit{Return}\) target, and on top of
it in the context stack we push a principal with a fresh identifier, the \(\mathit{Active}\)
target, and the updated view. On return, we search the stack for the first
\(\mathit{Return}\) target, and restore that principal to active status with its
original view. The rules given in Figure \ref{fig:callcontexts} take precedence
in order.

\begin{figure*}
  \judgment[AllocCNil]
           {\(\psi = \mathbf{alloc} ~ [ ~ ]\)}
           {\(\mach, \context \constep{\psi} \context\)}
  
  \judgmentthreebrtwo[AllocCCons]
                     {\(\psi = \mathbf{alloc} ~ s::sizes\)}
                     {\(\mach, (\alpha,T,V')::\context \constep{\psi'} \context'\)}
                     {\(b = \mach[sp] + sum(sizes)\)}
                     {\(\psi' = \mathbf{alloc} ~ sizes\)}
                     {\(V' = V\llbracket \addr \mapsto \mathit{object} | b \leq \addr < b+s \land V ~ \addr = \unsealed \rrbracket\)}
                     {\(\mach, (\alpha,T,V)::\context \constep{\psi} \context'\)}

  \[\mathit{reg\_view} ~ \overline{r_{args}} \triangleq \lambda \reg .
  \begin{cases}
    \public & \textnormal{if } \reg \in \overline{r_{args}} \textnormal{ or } \reg \in \mathit{PUBLIC} \\
    \unsealed & \textnormal{else if } \reg \in \mathit{CLR\_SV} \\
    \sealed & \textnormal{else} \\
  \end{cases}\]

  \[\mathit{update\_view} ~ V ~ \overline{r_{args}} \triangleq \lambda \component
  \begin{cases}
    \mathit{reg\_view} ~ \overline{r_{args}} ~ \component & \textnormal{if } \component \in \REGS \\
    \sealed & \textnormal{else if } V ~ \component = \mathit{object} \\
    
      V ~ \component & \textnormal{otherwise} \\
  \end{cases}\]

  \judgmenttwobr[CallC]
              {\(\psi = \mathbf{call} ~ r_{target} ~ \overline{\reg_{args}}\)}
              {\(T = \mathit{Return} ~ (\mach[pc] + 4)\)}
              {\(V' = \mathit{update\_view} ~ V ~ \overline{\reg_{args}}\)}
              {\(\alpha' = \mathit{fresh}\)}
              {\(\mach, (\alpha,\mathit{Active},V)::\context \constep{\psi}
                (\alpha',\mathit{Active},V')::(\alpha,T,V)::\context\)}

  \judgmenttwo[ReturnCRet]
              {\(\psi = \mathbf{return}\)}
              {\(T = \mathit{Return} ~ \_\)}
              {\(\mach, (\_, \mathit{Active}, \_)::(\alpha, T, V)::\context
                \constep{\psi} (\alpha, \mathit{Active}, V)::\context\)}

  \judgmenttwo[ReturnCSkip]
              {\(\psi = \mathbf{return}\)}
              {\(\mach, \context \constep{\psi} \context'\)}
              {\(\mach, (\alpha, \mathit{Active}, V)::\_::\context
                \constep{\psi} (\alpha, \mathit{Active}, V)::\context\)}

  \judgment[ReturnCNoRet]
           {\(\psi = \mathbf{return}\)}
           {\(\mach, [(\alpha,\mathit{Active},V)] \constep{\psi}
             [(\alpha,\mathit{Active},V)]\)}

\caption{Call and return context updates}
\label{fig:callcontexts}
\end{figure*}

\section{Events and Traces}

Some macro-instructions may be interpreted as {\it events} that can be observed
from outside the system. For now we define events \(\obs \in \OBSS\) as calls, labeled
with the target address and the values of the arguments, or else as the silent
event \(\tau\):
\[\begin{split}
\obs \in \OBSS ::= & ~ \mathbf{callE} ~ a_{target} ~ \overline{w_{args}} \\
| & ~ \tau \\
\end{split}\]

We convert macro-instructions into events via the \(\mathit{observe}\)
function, observing the values of relevant registers, defined in Figure \ref{fig:observe}.

A {\em trace} is a nonempty, finite or infinite sequence
of events, ranged over by \(\obsT\).
We use ``\(\notfinished{}{}\)'' to represent ``cons'' for traces, reserving ``::''
for list-cons.

\begin{figure*}
\[\mathit{observe} ~ \psi? ~ m =
\begin{cases}
  \mathbf{callE} ~ m[\PCname] ~ m \llbracket r | r \in \overline{r_{args}} \rrbracket
  & \textnormal{when } ~ \psi = \mathbf{call} ~ r_{target} ~ \overline{r_{args}} \\
  \mathbf{callE} ~ m[\PCname] ~ m \llbracket r | r \in \overline{r_{args}} \rrbracket
  & \textnormal{when } ~ \psi = \mathbf{tailcall} ~ r_{target} ~ \overline{r_{args}} \\
%  (\rho, \mathbf{returnE} ~ m[\PCname] & \textnormal{when } \psi = \mathbf{return} \\
  \tau & \textnormal{otherwise} \\
\end{cases}\]
\caption{Converting overlay steps to events}
\label{fig:observe}
\end{figure*}

We write that execution from a state produces an observation trace \(\mach,\context \hookrightarrow \obsT\)
as follows, coinductively:

\judgment{\(\not \exists \mach' ~ \context'. (\mach,\context) \stepstounder{\psi?} (\mach',\context')\)}
         {\((\mach,\context) \hookrightarrow \tau\)}

\judgmenttwo{\((\mach,\context) \stepstounder{\psi?} (\mach',\context')\)}
            {\((\mach',\context') \hookrightarrow \obsT\)}
            {\((\mach,\context) \hookrightarrow \notfinished{\mathit{observe} ~ \psi? ~ \mach}{\obsT}\)}

Naturally, most states will admit many possible traces, depending on the order in which
processors step.

We define another relation that takes a trace until we have returned to a particular
activation, or past it (as might occur when we add exceptions.)
We write this \(\context' \downarrow (\mach,\context) \hookrightarrow \obsT\), where \(\context'\)
is the context of the caller.

\judgment{\(|\context| \leq |\context'|\)}
         {\(\context' \downarrow (\mach,\context) \hookrightarrow \tau\)}

\judgmenttwobrlong{\((\mach,\context) \stepstounder{\psi?} (\mach',\context')\)}
                  {\(|\context'| > |\context''|\)}
                  {\(\context'' \downarrow (\mach',\context') \hookrightarrow \obsT\)}
                  {\(\context'' \downarrow (\mach,\context) \hookrightarrow \notfinished{\mathit{observe} ~ \psi? ~ \mach}{\obsT}\)}

\paragraph*{Observational Similarity}

We say that two event traces $\obsT_1$ and $\obsT_2$ are {\em similar},
written \(\obsT_1 \eqsim \obsT_2\), if the sequence of non-silent events
is the same. That is, we compare up to deletion of \(\tau\) events.

\begin{minipage}{.4\columnwidth}
  \judgment{}{\(\obsT \eqsim \obsT\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\obs}{\obsT_1} \eqsim \notfinished{\obs}{\obsT_2}\)}
\end{minipage}

\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\tau}{\obsT_1} \eqsim \obsT_2\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\obsT_1 \eqsim \notfinished{\tau}{\obsT_2}\)}
\end{minipage}

\section{Facts Abouts Calls and Returns}

Here we define some logical operations to reason about the behavior of the
system over time. These have a temporal-logic flavor, as they reflect
the expected behavior of the system in the future, after a possible return.

\paragraph*{On-return}

The intuition behind {\it return-time integrity} (below) is that a caller may expect its
sealed data to be unchanged when control returns to it. In fact, the callee
may overwrite such data -- when the data are found in callee-saved registers
this is perfectly legal -- as long as it either restores it, or has some guarantee
that its changes will impact the caller.

We start by defining a second-order logical operator
\(\context \uparrow P\), read ``\(P\) holds on return to \(\context\),''
where \(P\) is a predicate on machine states. This is a coinductive relation
similar to ``weak until'' in temporal logic -- it holds if the condition
is never reached.

\judgmenttwo[Returned]
            {\(|\context| \leq |\context_{ret}| }
            {\(P ~ (\mach,\context)\)}
            {\((\context_{ret} \uparrow P) ~ (\mach, \context)\)}

\judgmenttwobrlong[Step]
                  {\(|\context| \leq |\context_{tar}|\)}
                  {\((\context_{ret} \uparrow P) ~ (\mach', \context')\)}
                  {\((\mach, \context) \stepstounder{\psi?} (\mach', \context')\)}
                  {\((\context_{ret} \uparrow P) ~ (\mach, \context)\)}

Similarly, in {\it caller confidentiality}, we will want to compare future states,
so we give a binary equivalent, \(\context \Uparrow R\), so that
\((\mach,\context) ~ (\context_{ret} \Uparrow R) ~ (\mach',\context')\) holds if \(R\) holds on the
first return states after \((\mach,\context)\) and \((\mach',\context')\).

\judgmenttwobrlong[Returned]
            {\(|\context| \leq |\context_{ret}|\)}
            {\(|\context'| \leq |\context_{ret}|\)}
            {\((\mach,\context) ~ R ~ (\mach',\context')\)}
            {\((\mach,\context) ~ (\context_{ret} \Uparrow R) ~ (\mach',\context')\)}

\judgmenttwobrlong[Left]
              {\(|\context_1| \leq |\context_{ret}|\)}
              {\((\mach_1,\context_1) \stepstounder{\psi?} (\mach_1',\context_1')\)}
              {\((\mach_1',\context_1') ~ (\context_{ret} \Uparrow R) ~ (\mach_2,\context_2)\)}
              {\((\mach_1,\context_1) ~ (\context_{ret} \Uparrow R) ~ (\mach_2,\context_2)\)}

\judgmenttwobrlong[Right]
              {\(|\context_2| \leq |\context_{ret}|\)}
              {\((\mach_2,\context_2) \stepstounder{\psi?} (\mach_2',\context_2')\)}
              {\((\mach_1,\context_1) ~ (\context_{ret} \Uparrow R) ~ (\mach_2',\context_2')\)}
              {\((\mach_1,\context_1) ~ (\context_{ret} \Uparrow R) ~ (\mach_2,\context_2)\)}

\section{Properties}

We now finally have everything we need to offer our definitions for stack safety.
We need one preliminary definition first.
One or more elements of a given state are {\it vestigial} if their values
in that state have no observable influence on future execution. We define this
formally as a sort of non-interference: for a state \((\mach,\context)\) and
a set of elements \(\components\), \((\mach,\context) \parallel \components\)
holds if we can replace the contents of \(\components\) with arbitrary values
and have the resulting state produce an equivalent trace. The state created
by modifying \(\components\) in this way is termed a variant.

\definition Machine states \(\mach\) and \(\nach\) are {\em \(\components\)-variants},
written \(\mach \approx_\components \nach\), if, for
all \(\component \not \in \components\), \(\mach[\component] = \nach[\component]\).

\definition An element set \(\components\) is vestigial in state \((\mach,\context)\),
written \((\mach,\context) \parallel \components\), if for all
\(\nach\) such that \(\mach \approx_{\components} \mach'\), if 
\((\mach,\context) \hookrightarrow \obsT\) and
\((\nach,\context) \hookrightarrow \obsT'\), then
\(\obsT \eqsim \obsT'\).

\subsection{Integrity}

And with the preliminary definitions out the way, we can define integrity.

\definition Let \(\Delta(\mach,\mach')\) be the set of elements \(\component\)
such that \(\mach[\component] \not = \mach'[\component]\).

\definition Let \((\mach,(\alpha,T,V)::\context)\) be a state and
\(\components = \{\component | V ~ \component = \sealed\}\).
Let \(P\) be a predicate that holds on a state \((\mach',\context')\) if
\(\mach' ~ \parallel ~ \Delta(\mach,\mach') \cap \components\).
Then \(\mach\) enjoys {\it return-time integrity} if \(\context \downarrow P\) holds.

\definition A system enjoys {\it stack integrity} if, for all reachable states
\((\mach,\context)\) such that
\((\mach,\context) \stepstounder{\psi} (\mach',\context')\) with \(\psi = \mathbf{Call} ~ \_ ~ \_\),
\((\mach',\context')\) enjoys return-time integrity.

\subsection{Caller Confidentiality}

Confidentiality properties are also modeled as non-interference, but with a twist:
the caller's confidential data should be kept secret from the callee, but after return,
will naturally be accessible to the caller once again. So, we must model confidentiality
in terms of events inside the callee. But confidentiality violations might not become
visible during the callee's lifetime -- the callee might read a secret and stash it somewhere
that it will be accessed later. So we must also consider the machine state at the end
of the call.

We could define a natural, strict form of confidentiality that requires that the final
states be identical. However, as with integrity, this is stricter than we need -- there
may be some conditions in which a secret is copied, but never used again. So, we once
again wish for our final condition to allow values to be vestigial. Which values?

\definition Let \(\mach,\mach'\) and \(\nach,\nach'\)
be pairs of machine states. Their {\em corrupted set}, written
\(\bar{\Diamond}(\mach,\mach',\nach,\nach')\), is the set of all elements
\(\component \in \Delta(\mach,\mach') \cup \Delta(\nach,\nach')\) such that
\(\mach'[\component] \not = \nach'[\component]\).

\definition Let \((\mach,(\alpha,T,V)::\context)\) be a state and
\(\components = \{\component | V ~ \component \in \{\sealed, \unsealed\}\}\).

Then \((\mach,\context)\) enjoys {\it internal confidentiality} with respect to
some \(\context_{ret}\) if, for any \(\nach\)
that is a \(\components\)-variant of \(\mach\), we can take
\(\context_{ret} \uparrow (\mach,\context) \hookrightarrow \obsT\) and
\(\context_{ret} \uparrow (\nach,\context) \hookrightarrow \obsT'\) and have that
\(\obsT \simeq \obsT'\).

\definition Let \((\mach,(\alpha,T,V)::\context)\) be a state and
\(\components = \{\component | V ~ \component \in \{\sealed, \unsealed\}\}\).

Then \((\mach,\context)\) enjoys {\it return-time confidentiality} with respect to
some \(\context_{ret}\) if \((\mach,\context) ~ (\context_{ret} \Uparrow R) ~ (\nach,\context)\),
where \((\mach_1,\context_1) ~ R ~ (\nach_2,\context_2)\) if
\((\mach_1 \parallel \bar{\Diamond}(\mach,\mach_1,\nach,\nach_2)\).

\definition A system enjoys {\it caller confidentiality} if, for all reachable states
\((\mach,\context)\) such that \((\mach,\context) \stepstounder{\psi} (\mach',\context')\)
with \(\psi = \mathbf{Call} ~ \_ ~ \_\),
\((\mach',\context')\) enjoys both internal and return-time confidentiality
with respect to \(\context\).

\subsection{Callee Confidentiality}

Callees can have secrets too. The question is, what do we consider a callee's secrets?
Anything in its frame? Anything that {\it could} be in its frame (i.e. above the stack pointer)?
These are plausible options, but they will also capture data that has been written to those
locations before the call. To get a narrower property specific to the data that is actually
derived from the callee, we focus instead on those values that the callee has written.

\definition Let \((\mach,(\alpha,T,V)::\context)\) be a state and
\(\components = \{\component | V ~ \component \in \{\sealed,\unsealed\}\}\).
Let \(P\) be a predicate that holds on a state \((\mach',\context')\) if
\(\mach' ~ \parallel ~ \Delta(\mach,\mach') \cap \components\).
Then \(\mach\) enjoys {\it post-return confidentiality} if \(\context \downarrow P\) holds.

\definition A system enjoys {\it callee confidentiality} if, for all reachable states
\((\mach,\context)\) such that \((\mach,\context) \stepstounder{\psi} (\mach',\context')\)
with \(\psi = \mathbf{Call} ~ \_ ~ \_\),
\((\mach',\context')\) enjoys post-return confidentiality
with respect to \(\context\).

Interestingly, callee confidentiality subsumes caller integrity. This makes sense:
one way for the callee's secrets to leak is by overwriting the caller's sealed data
with them.

\section{Public Memory}

We can extend our basic machine to support public memory allocations that can
be accessed by anyone until they are deallocated on their owner's return.
We replace \(\mathbf{alloc} ~ \mathit{sizes}\) with \(\mathbf{alloc} ~ \mathit{objs}\),
where \(\mathit{objs}\) is a list of pairs of sizes and booleans, representing whether
the object in question should be public. The \(\mathit{update\_view}\)
function only seals private objects, and the remained maintain their \(\mathit{object}\)
class, making them exempt from both integrity and confidentiality properties.

\section{Exceptions}

We implement exceptions via another pair of macro-instructions:
\(\mathbf{setex} ~ a_{buf}\), akin to \(\mathit{setjmp}\), with the
jump buffer stored at \(a_{buf}\), and \(\mathbf{throwex} ~ a_{buf}\),
akin to \(\mathit{longjmp}\). The context updates for exceptions are given
in Figure \ref{fig:excontexts}. The update for \(\mathbf{setex}\) pushes
a \(\mathit{Catch}\) target onto the stack, identified by \(\addr_{buf}\),
with the same view as the current function. For \(\mathbf{throwex}\),
we pop the stack until we find a \(\mathit{Catch} ~ a_{buf} ~ \_ ~ \_\),
popping it as well. Rules apply in order.
[TODO: update these for the new \(\alpha\) stuff.]

\begin{figure*}

\judgmenttwo[SetExC]
            {\(\psi = \mathbf{setex} ~ \addr_{buf}\)}
            {\(T' = \mathit{Catch} ~ \addr_{buf} ~ (\mach[pc] + 4) ~ \mach[sp]\)}
            {\(\mach, (T,V)::\context \constep{\psi} (T',V)::(T,V)::\context\)}

\judgment[ThrowExCCatch]
         {\(\psi = \mathbf{throwex} ~ \addr_{buf}\)}
         {\(\mach, (\mathit{Catch} \addr_{buf} ~ a_{pc} ~ a_{sp}, V)::\context \constep{\psi} \context\)}

\judgment[ThrowExCDone]
         {\(\psi = \mathbf{throwex} ~ \addr_{buf}\)}
         {\(m, [\mathit{Done},V] \constep{\psi} [\mathit{Done},V]\)}

\judgmenttwo[ThrowExCSkip]
         {\(\psi = \mathbf{throwex} ~ \addr_{buf}\)}
         {\(\mach, \context \constep{\psi} \context'\)}
         {\(\mach, (\_::\context) \constep{\psi} \context'\)}
         
\caption{Exception context updates}
\label{fig:excontexts}
\end{figure*}

\section{Tail Call Elimination}

I submit that tail calls will work perfectly fine with all of our definitions
using the context update in Figure \ref{fig:tailcallcontexts}. All of the
``until return'' stuff works fine, because all the calls return at once.
We need to define callee confidentiality still.

\begin{figure*}

\judgmenttwo[TailCallC]
            {\(\psi = \mathbf{tailcall} ~ r_{target} ~ \overline{r_{args}}\)}
            {\(V' = \mathit{update\_view} ~ V ~ \overline{r_{args}}\)}
            {\(\mach, (\alpha,\mathit{Active},V)::\context \constep{\psi} (\alpha,\mathit{Active},V')::\context\)}

\caption{Tailcall context updates}
\label{fig:tailcallcontexts}
\end{figure*}

\section{Provenance, Capabilities, and Protecting Objects}

So far, we have given functions the ability to allocate completely unprotected
objects. What if we want to express a finer-grained notion of safety, in which
such objects are protected unless the function that owns them intentionally
passes a pointer to them?

In order to express such a property, we need our machine to carry some notion
of {\it pointer provenance} -- a distinction between a pointer that is intended to
point to a given object, and non-pointer integers as well as pointers to other objects.
Then, in \(\mathit{update\_view}\), we recursively identify all public objects that
are reachable transitively from capabilities in registers; these keep their
\(\mathit{object}\) status, while those that are not reachable become \(\sealed\).

\section{Simple Concurrency}

\bibliographystyle{IEEEtran}
\bibliography{bcp.bib,local.bib}

\end{document}
