%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[10pt,conference]{ieeetran}%\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{amsmath,amsthm,amssymb}

\usepackage{xcolor,listings}

\usepackage{multirow}

\usepackage{stmaryrd}

\usepackage[noadjust]{cite}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\input{macros}

\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\begin{document}

%% Title information
\title{Formalizing Stack Safety as a Security Property}

\author{
  \IEEEauthorblockN{
    Sean Noble Anderson
  }
  \IEEEauthorblockA{
    Portland State University\\
    ander28@pdx.edu\\
  }
  \and
  \IEEEauthorblockN{
    Leonidas Lampropoulos
  }
  \IEEEauthorblockA{
    University of Maryland, College Park\\
    leonidas@umd.edu\\
  }
  \and
  \IEEEauthorblockN{
    Roberto Blanco
  }
  \IEEEauthorblockA{
    Max Planck Institute for Security and Privacy\\
    roberto.blanco@mpi-sp.org\\
  }
  \linebreakand
  \IEEEauthorblockN{
    Benjamin C. Pierce,
  }
  \IEEEauthorblockA{
    University of Pennsylvania\\
    bcpierce@cis.upenn.edu\\
  }
  \and
  \IEEEauthorblockN{
    Andrew Tolmach
  }
  \IEEEauthorblockA{
    Portland State University\\
    tolmach@pdx.edu\\
  }
}



%% Keywords
%% comma separated list
\ifcameraready
\keywords{Stack Safety, Micro-Policies}  %% \keywords are mandatory in final camera-ready submission
\fi

\maketitle

\section{Threat Model, Machines, and Enforcement }

Before introducing our formal model of stack safety, we describe
our machine exemplar, enforcement mechanism, and threat model.

We begin with a RISC-V-like machine enhanced with PIPE, a tag-based reference
monitor. We extend this machine with a {\it security semantics},
which divides a program into dynamic {\it principals} that ought to be
protected from one another, and specifies that protection over a set
of abstract {\it security operations}. Specifications may take the form of
predicates on future states: statements of the form,
``When control returns to me...'', or of relations on traces of future execution
(hyper-properties.)

As opposed to a fully-abstract overlay semantics, in which overlay operations
are given safe-by-construction semantics then proven fully abstract,
our machine is not safe unless the monitor is correctly instantiated;
the security semantics gives us the means to distinguish a monitor that implements
stack safety from one that does not.

The underlying machine is a standard RISC-V ISA as modeled in [MIT-RISCV].
Our overlay semantics provide overlay operations for the following code features:
\begin{itemize}
\item Function calls and returns, with caller- and callee-saved registers according
  to the RISC-V ABI
\item Arguments passed by reference
\item Exceptions
\item Tail-call Elimination
\end{itemize}

\paragraph*{Threat Model}

We trust the compiler has correctly placed macro-instructions according to
the semantics of the source language, but we do not assume that the code
is otherwise reasonable. In particular, while we are agnostic as to the source
language, C is very plausible, and so any source function might contain undefined
behavior resulting in its compilation to arbitrary machine code.

In general, it is impossible to distinguish buggy source code from an attacker;
we assume nothing about the intent of the source code, except that it makes calls
and returns, and we must guarantee that the caller and callee are protected from one
another.

This is a strong threat model, but hardware and timing attacks are out of scope,
and our properties are termination insensitive as a result of the enforcement mechanism
(below).

\paragraph*{Limitations}

We do not support dynamic code generation, and our concurrency model is fairly
simplistic, assuming a fixed number of threads each with its own dedicated processor.
We model memory safe stack objects, but not a heap. Regions outside of
stacks can be used however the compiler likes, including as a heap, but no protection is
built in and our properties assume that if a pointer to a stack object is stored there,
it is permanently compromised.

\subsection{Security Semantics}

We begin with a machine that supports a number of security operations,
defined above. For purposes of specifying security, we do not need to
know the semantics of these operations; we only need the machine to
distinguish them from normal execution. We model the machine as
a transition system in which some transitions are marked with
security operations. We then define a security semantics for stack safety
in terms of those steps.

The security semantics divides a program's execution into principals,
namely function activations, and identifies which principal is active
in a given state. Security operations can generate new principals, transition
which principal is active, and allocate stack objects belonging to the active
principal. From this information, we derive the specifications that make up
stack safety. Specifications may take the form of predicates on
future states: statements of the form, ``When control returns to me...'',
or of relations on traces of future execution (hyper-properties.)

\subsection{The Basic Machine}

The building blocks of the machine are {\em words} and {\em registers}.
Words (\(\WORDS\)) are 64-bit integers ranged over by \(\word\) and, when used as addresses,
\(\addr\). The processor has 32 registers, ranged over in general by \(\reg \in \REGS\),
plus a program counter (\(\PCname\)). The following table divides
the registers into metavariables, some belonging to caller- or callee- sets:

\vspace{\abovedisplayskip}
\begin{tabular}{| l | l | l |}
  \hline
  Set & Names & Purpose \\
  \hline
  CLR\_SV & \(rt_0 - rt_6\) & Caller-saved temps \\
  & \(ra_0 - ra_1\) & Caller-saved args / return vals \\
  & \(ra_2 - ra_7\) & Caller-saved args \\
  \hline
  CLE\_SV & \(rs_0 - rs_7\) & Callee-saved \\
  & \(rra\) & Return Address \\
  & \(rsp\) & Stack Pointer \\  
  \hline
  PUBLIC & \(pc\) & Program Counter \\
  \hline
\end{tabular}
\vspace{\abovedisplayskip}

Collectively addresses and registers are {\em state elements} \(\component\)
in the set \(\COMPONENTS ::= \WORDS + \REGS\).
%
{\em Machine states} are drawn from a set \(\MACHS\) ranged over by \(\mach\)
that defines a mapping \(\mach[\component]\) from state elements to values.
The machine step function
\(\mach \xrightarrow{\psi} \mach' \in \MACHS \rightarrow \MACHS \times \Psi\)
may be labeled by a security operation, defined below.
While the tag-based enforcement mechanism may cause the machine to
failstop, we model this as the machine silently diverging by returning to the
same state. Since failstops are not distinguished from normal execution,
our properties will necessarily be {\it termination insensitive}.

For convenience, we will abbreviate multiple updates of a mapping
\(\mach[\component_0 \mapsto \word_0][\component_1 \mapsto \word_1]\dots\)
as \(\mach \llbracket A \mapsto B | C \rrbracket\), where \(A\) and \(B\)
are fomulae with free variables bound to sets in \(C\).

\subsection{Security Operations, Principals, and Security State}

Security operations are split into two categories: {\it privilege operations}
and {\it control operations}. Privilege operations are those that adjust the
privileges of future callees by allocating private or public data and by saving
catch points for possible exceptions. Allocations specify the offset from
the stack pointer and size of the object. Exceptions are tied to the address
of the buffer that will contain saved state.
%
\begin{align*}
  \phi \in \Phi ::= & \mathbf{alloc} ~ \mathit{off ~ sz} & \mathit{off, sz} \in \mathbb{N} \\
  | & \mathbf{alloc\_pub} ~ \mathit{off ~ sz} & \mathit{off, sz} \in \mathbb{N} \\
\end{align*}

Control operations are those that exchange
control between principals: calls (including tailcalls), returns, and thrown
exceptions. Calls and tailcalls identify the target of the call, and the argument registers.
[Still a todo: stack arguments.] Return needs no further information. Throwing
an exception specifies the address of the saved buffer.
%
\begin{align*}
  \chi \in \mathcal{X} ::= & \mathbf{call} ~ \reg_{target} ~ \overline{\reg_{args}} & \\
  | & \mathbf{tailcall} ~ \reg_{target} ~ \overline{\reg_{args}} & \\
  | & \mathbf{return} & \\
\end{align*}
%
A security operation may consist of any number of privilege operations and at most
one control operation.
%
\[\psi \in \Psi ::= \mathit{list ~ \Phi} | (\mathcal{X} \times \mathit{list ~ \Phi})\]

Security principals are function activations: at any given time, the current
activation, and some number of pending ones. Each activation will have a {\it view}
of the system that maps each element to one of a set of {\it security classes}:
\[sc \in SEC ::= \sealed | \unsealed | \public\]
\[V \in \mathit{VIEW} ::= \COMPONENTS \rightarrow SEC\]

These indicate, from the perspective of a given principal, whether an element is
private to an inactive principal (\(\sealed\)),
%in an allocated object that is accessible to the current principal (\(\mathit{object}\)),
available to be allocated (\(\unsealed\)), or
always accessible (\(\public\)).
The {\it initial view} \(V_0\) maps all stack locations and non-public registers
to \(\unsealed\) and all other locations and public registers to \(\public\).

A pending activation additional carries the addresses at which the program counter
and stack pointer should point in the event of a return.
We represent a {\it call stack} as a pair of the current activation's view
and a list of pending ones.
The initial call stack is \(\context_0 = (V_0, [ ~ ])\).
\[(V, \addr_{ret}, \addr_{sp}) \in \mathit{PEND} ::= \mathit{VIEW \times \WORDS \times \WORDS}\]
\[\context \in \CONTEXTS ::= \mathit{VIEW \times list ~ PEND}\]

Every security operation manipulates the call stack: privilege operations act on
the active principal, and control operations push or pop the active principal.
We define the security effects of each operation as a function \(Pop\) or \(Cop\),
from an operation, a machine state, and a call stack to a new call stack.
As we introduce more complex operations, we will separately define
the curried functions \(Pop ~ \phi\) or \(Cop ~ \chi\) for each operation.
They are combined in \(Op\), which acts on full operations as follows.
\[Pop \in \Phi \rightarrow \CONTEXTS \rightarrow \MACHS \rightarrow \CONTEXTS\]
\[Cop \in X \rightarrow \CONTEXTS \rightarrow \MACHS \rightarrow \CONTEXTS\]
\[Op ~ \psi =
\begin{cases}
  \lambda \context ~ \mach . \context & \textnormal{when } \psi = [~] \\
  Pop ~ \phi \circ Op ~ \overline{\phi} & \textnormal{when } \psi = \phi::\overline{\phi} \\
  Cop ~ \chi \circ Op ~ \overline{\phi} & \textnormal{when } \psi = (\chi,\overline{\phi}) \\
\end{cases}\]

A control operation may additionally produce an observable event, drawn
from a set \(\mathit{EVENTS}\) and ranged over by \(e\).
A function \(Ev\) maps operations and machine states to events. The
silent event \(\tau\) is relevant to our definitions here, and the
remainder will be described in Section \ref{sec:events}. 
%
\[Ev \in X \rightarrow \MACHS \rightarrow \mathit{EVENTS}\]
%
From a machine state and a context stack, we create a {\it combined state}
\((\mach,\context)\) and a transition \(\stepstounder{}\) on combined states,
labeled with an event. If the underlying machine transition is labeled by
some operation \(\psi\), the combined step applies \(Op\) to the contents
of \(\psi\) to determine the new call stack; otherwise the call stack is
unchanged. If there is a control operation,
the transition is labeled with its event, otherwise it is silent.
Rules apply in order.

\judgmentthree[Control]
              {\(\mach \xrightarrow{\psi} \mach'\)}
              {\(\psi = (\chi, \overline{\phi})\)}
              {\(e = Ev ~ \chi ~ \mach\)}
              {\((\mach,\context) \stepstounder{e} (\mach',Op ~ \psi ~ \context ~ \mach)\)}

\judgment[NonControl]
         {\(\mach \xrightarrow{\psi} \mach'\)}
         {\((\mach,\context) \stepstounder{\tau} (\mach',Op ~ \psi ~ \context ~ \mach)\)}

\section{Calls, Returns, and Private Allocations}

In this section we consider a simple setting with calls, returns, and private
allocations. Assume that \(\MACHS\) describe a RISC-V machine, where a transition
\(\mach \xrightarrow{\Psi?} \mach'\) is labeled as follows.
If \(\mach[\PCname]\) points to {\tt addi sp,sp,N}, \(\Psi? = \mathbf{alloc} ~ (0,N)\);
since we are not yet allocating public objects,
we don't need to distinguish objects from one another if they are allocated
simultaneously. Similarly, if \(\mach[\PCname]\) points to {\tt jal off ra}
and \(\mach'[\PCname] = a_f\) where \(a_f\) is the entry of a function
\(f\) that uses argument registers \(\overline{r}\), 
\(\Psi? = \mathbf{call} ~ f ~ \overline{r}\). And a step via the
instruction {\tt jalr ra} is labeled \(\mathbf{return}\).
This simplistic system serves to demonstrate our core properties.

Figure \ref{fig:example} gives a running example
of a function {\tt main} that takes a secret in its arguments and allocates
an array of potentially sensitive data. It then calls another function {\tt f},
and afterward may decide to {\tt publish} its secret based on the contents of
its sensitive data.

\begin{figure*}
  \begin{subfigure}[t]{.5\textwidth}
    {\tt
      void main(int argc, char*argv) \{
      
      ~ ~ int secret = argv[1];

      ~ ~ int sensitive[4] = \{0\};

      ~ ~ f();

      ~ ~ if (sensitive == 42) \{

      ~ ~ ~ ~ publish(secret);
      
      ~ ~ \}

      \}
    }
  \end{subfigure}
  \begin{subfigure}[t]{.5\textwidth}
    {\tt
      0: addi sp,sp,-20

      4: sw a1,16(sp)

      8: sd zero,8(sp)

      12: sd zero,0(sp)

      16: jal 84 ra

      20: lw a4,12(sp)

      24: li a5,42

      28: bne a4,a5,L

      32: ld a0,16(sp)

      36: jal 164 ra

      L(40): nop

      44: addi sp,sp,20

      48: return

    }
  \end{subfigure}

  \caption{Example: Main}
  \label{fig:example}
\end{figure*}

At the start of execution (PC 0) the initial call stack is \((V_0, [~])\).
Instruction 0 allocates 20 bytes starting at the stack pointer. This will have the
effect of marking those twenty bytes \(\sealed\), assuming they were previously
\(\unsealed\):

\judgmentbr{\(b = \mach[\SP] - \mathit{off}\)}
           {\(V' = V \llbracket \addr \mapsto \sealed |
             b \leq a < b+\mathit{sz} \land V ~ \addr = \unsealed \rrbracket\)}
           {\(Pop ~ (\mathbf{alloc} ~ \mathit{off, sz}) ~ (V,\sigma) ~ \mach \triangleq
             (V',\sigma)\)}

This memory being \(\sealed\) has no effect on the current activation --
the security guarantees apply at the start of the call. Our next security operation
occurs when we step from the call at instruction 16.

On a call, the formerly active principal's record is pushed onto the inactive list,
and replaced by a new record for the callee. Its return target is the instruction
immediately following that of the program counter before the call.
The callee's view is updated from the caller's such that the argument
registers are \(\public\) and any non-argument, caller-saved registers
are \(\unsealed\). All callee-save registers are always \(\sealed\), and
the program counter is always public, but this is already the case.

\[\begin{split}
\mathit{reg\_view} ~ V ~ \overline{r_{args}} \triangleq
V & \llbracket \reg \mapsto \unsealed | \reg \in \mathit{CLR\_SV} \rrbracket \\
& \llbracket \reg \mapsto \public | \reg \in \overline{r_{args}} \rrbracket
\end{split}\]

\judgmenttwo{\(\chi = \mathbf{call} ~ \addr_{target} ~ \overline{\reg_{args}}\)}
            {\(V' = \mathit{reg\_view} ~ V ~ \overline{\reg_{args}}\)}
            {\(Cop ~ \chi ~ (V,\sigma) ~ \mach \triangleq
              (V',(V, \mach[\PCname]+4, \mach[\SP])::\sigma)\)}

            
After the call step, we have a new activation, and {\tt main} is now pending.
{\tt main}'s pending record tracks its return address.
Everything that {\tt main} allocated, both {\tt secret} and {\tt sensitive},
{\tt f} views as \(\sealed\), along with its callee-saved registers.
Informally, the meaning of \(\sealed\) is: ``when control returns to
{\tt main}, this elements value should be the same as it is now.''
This is termed {\it return-time integrity}, and is defined below.
The remainder of the stack, and the caller-save registers, are \(\unsealed\).
The informal meaning of \(\unsealed\) is: ``{\tt f}'s behavior should not
depend on this element's value, but {\tt f} is free to overwrite it.''
This becomes relevant in out {\it confidentiality} properties.
Finally, \(\public\) elements are those that {\tt f} is allowed to
depend on, and may also overwrite.

On return, we restore the topmost inactive principal, if there is one.
Else, we default to retaining the current principal, as we do not model
the main function returning.

\judgmenttwo[Ret]
            {\(\chi = \mathbf{return}\)}
            {\(\sigma = (V,\addr_{ret},\addr_{sp})::\sigma'\)}
            {\(Cop ~ \chi ~ (\_, \sigma) ~ \mach \triangleq
              (V, \sigma)\)}

\judgment[RetDef]
         {\(\chi = \mathbf{return}\)}
         {\(Cop ~ \chi ~ (V, [~]) ~ \mach \triangleq
           (V, [~])\)}

We are ready to define our first stack safety property for this system:
{\it well-bracketed control flow}.

\definition A system enjoys well-bracketed control flow if, for all states
\((\mach,(\_,(\_,\addr_{ret},\addr_{sp})) \stepstounder{\mathbf{return}} (\mach',\context)\),
\(\mach'[\PCname] = \addr_{ret}\) and \(\mach'[\SP] = \addr_{sp}\).

\section{Events and Traces}

Some macro-instructions may be interpreted as {\it events} that can be observed
from outside the system. For now we define events \(\obs \in \OBSS\) as calls, labeled
with the target address and the values of the arguments, or else as the silent
event \(\tau\):
\[\begin{split}
\obs \in \OBSS ::= & ~ \mathbf{callE} ~ a_{target} ~ \overline{w_{args}} \\
| & ~ \tau \\
\end{split}\]

We convert control operations into events via the \(Ev\)
function, observing the values of relevant registers, defined in Figure \ref{fig:observe}.

A {\em trace} is a nonempty, finite or infinite sequence
of events, ranged over by \(\obsT\).
We use ``\(\notfinished{}{}\)'' to represent ``cons'' for traces, reserving ``::''
for list-cons.

\begin{figure*}
\[\mathit{Ev} ~ \chi ~ m =
\begin{cases}
  \mathbf{callE} ~ (m[\PCname]+m[\reg_{target}]) ~ m \llbracket r | r \in \overline{r_{args}} \rrbracket
  & \textnormal{when } ~ \chi = \mathbf{call} ~ r_{target} ~ \overline{r_{args}} \\
  \mathbf{callE} ~ (m[\PCname]+m[\reg_{target}]) ~ m \llbracket r | r \in \overline{r_{args}} \rrbracket
  & \textnormal{when } ~ \chi = \mathbf{tailcall} ~ r_{target} ~ \overline{r_{args}} \\
  \tau & \textnormal{otherwise} \\
\end{cases}\]
\caption{Converting overlay steps to events}
\label{fig:observe}
\end{figure*}

We write that execution from a state produces an observation trace
\(\mach,\context \hookrightarrow \obsT\) as follows, coinductively:

\judgmenttwo{\((\mach,\context) \stepstounder{e} (\mach',\context')\)}
            {\((\mach',\context') \hookrightarrow \obsT\)}
            {\((\mach,\context) \hookrightarrow \notfinished{e}{\obsT}\)}

We define another relation that takes a trace until we have returned from the
active principal.
We write this \(d \downarrow (\mach,\context) \hookrightarrow \obsT\), where
\(d\) is the depth of the current call.

\judgment{\(|\sigma| < d\)}
         {\(d \downarrow (\mach,(V,\sigma)) \hookrightarrow \tau\)}

\judgmenttwobrlong{\((\mach,(V,\sigma)) \stepstounder{e} (\mach',\context')\)}
                  {\(|\sigma| \geq d\)}
                  {\(d \downarrow (\mach',\context') \hookrightarrow \obsT\)}
                  {\(d \downarrow (\mach,(V,\sigma)) \hookrightarrow \notfinished{e}{\obsT}\)}

\paragraph*{Observational Similarity}

We say that two event traces $\obsT_1$ and $\obsT_2$ are {\em similar},
written \(\obsT_1 \eqsim \obsT_2\), if the sequence of non-silent events
is the same. That is, we compare up to deletion of \(\tau\) events.

\begin{minipage}{.4\columnwidth}
  \judgment{}{\(\obsT \eqsim \obsT\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\obs}{\obsT_1} \eqsim \notfinished{\obs}{\obsT_2}\)}
\end{minipage}

\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\notfinished{\tau}{\obsT_1} \eqsim \obsT_2\)}
\end{minipage}
\begin{minipage}{.4\columnwidth}
  \judgment{\(\obsT_1 \eqsim \obsT_2\)}
           {\(\obsT_1 \eqsim \notfinished{\tau}{\obsT_2}\)}
\end{minipage}

\section{Facts Abouts Calls and Returns}

Here we define some logical operations to reason about the behavior of the
system over time. These have a temporal-logic flavor, as they reflect
the expected behavior of the system in the future, after a possible return.

\paragraph*{On-return}

The intuition behind {\it return-time integrity} (below) is that a caller may expect its
sealed data to be unchanged when control returns to it. In fact, the callee
may overwrite such data -- when the data are found in callee-saved registers
this is perfectly legal -- as long as it either restores it, or has some guarantee
that its changes will impact the caller.

We start by defining a second-order logical operator
\(d \uparrow P\), read ``\(P\) holds on return from depth \(d\),''
where \(P\) is a predicate on machine states. This is a coinductive relation
similar to ``weak until'' in temporal logic -- it holds if the program never
returns from depth \(d\).

\judgmenttwo[Returned]
            {\(|\sigma| < d\)}
            {\(P ~ (\mach,(V,\sigma))\)}
            {\((d \uparrow P) ~ (\mach, (V,\sigma))\)}

\judgmenttwobrlong[Step]
                  {\(|\sigma| \geq d\)}
                  {\((d \uparrow P) ~ (\mach', \context')\)}
                  {\((\mach, (V,\sigma)) \stepstounder{e} (\mach', \context')\)}
                  {\((d \uparrow P) ~ (\mach, (V,\sigma))\)}

Similarly, in {\it caller confidentiality}, we will want to compare future states,
so we give a binary equivalent, \(d \Uparrow R\), so that
\((\mach,\context) ~ (d \Uparrow R) ~ (\mach',\context')\) holds if \(R\) holds on the
first states that return from depth \(d\) after \((\mach,\context)\) and \((\mach',\context')\).

\judgmenttwobrlong[Returned]
            {\(|\sigma_1| < d\)}
            {\(|\sigma_2| < d\)}
            {\((\mach_1,(V_1,\sigma_1)) ~ R ~ (\mach_2,(V_2,\sigma_2))\)}
            {\((\mach_1,(V_1,\sigma_1)) ~ (d \Uparrow R) ~ (\mach_2,(V_2,\sigma_2))\)}

\judgmenttwobrlong[Left]
              {\(|\sigma_1| \geq d\)}
              {\((\mach_1,(V_1,\sigma_1)) \stepstounder{e} (\mach_1',\context_1')\)}
              {\((\mach_1',\context_1') ~ (d \Uparrow R) ~ (\mach_2,(V_2,\sigma_2))\)}
              {\((\mach_1,(V_1,\sigma_1)) ~ (d \Uparrow R) ~ (\mach_2,(V_2,\sigma_2))\)}

\judgmenttwobrlong[Right]
              {\(|\sigma_2| \geq d\)}
              {\((\mach_2,(V_2,\sigma_2)) \stepstounder{e} (\mach_2',\context_2')\)}
              {\((\mach_1,(V_1,\sigma_1)) ~ (d \Uparrow R) ~ (\mach_2,\context_2')\)}
              {\((\mach_1,(V_1,\sigma_1)) ~ (d \Uparrow R) ~ (\mach_2,(V_2,\sigma_2))\)}

\section{Properties}

We now finally have everything we need to offer our definitions for stack safety.
We need one preliminary definition first.
One or more elements of a given state are {\it vestigial} if their values
in that state have no observable influence on future execution. We define this
formally as a sort of non-interference: for a state \((\mach,\context)\) and
a set of elements \(\components\), \((\mach,\context) \parallel \components\)
holds if we can replace the contents of \(\components\) with arbitrary values
and have the resulting state produce an equivalent trace. The state created
by modifying \(\components\) in this way is termed a variant.

\definition Machine states \(\mach\) and \(\nach\) are {\em \(\components\)-variants},
written \(\mach \approx_\components \nach\), if, for
all \(\component \not \in \components\), \(\mach[\component] = \nach[\component]\).

\definition An element set \(\components\) is vestigial in state \((\mach,\context)\),
written \((\mach,\context) \parallel \components\), if for all
\(\nach\) such that \(\mach \approx_{\components} \mach'\), if 
\((\mach,\context) \hookrightarrow \obsT\) and
\((\nach,\context) \hookrightarrow \obsT'\), then
\(\obsT \eqsim \obsT'\).

\subsection{Integrity}

And with the preliminary definitions out the way, we can define integrity.

\definition Let \(\Delta(\mach,\mach')\) be the set of elements \(\component\)
such that \(\mach[\component] \not = \mach'[\component]\).

\definition Let \((\mach,\context)\) be a combined state with
\(\context = (V,\sigma)\), and
\(\components = \{\component | V ~ \component = \sealed\}\).
Let \(P\) be a predicate that holds on a state \((\mach',\context')\) if
\(\mach' ~ \parallel ~ \Delta(\mach,\mach') \cap \components\).
Then \(\mach\) enjoys {\it return-time integrity} if \(|\sigma| \downarrow P\) holds
on \((\mach,\context)\).

\definition A system enjoys {\it stack integrity} if, for all reachable states
\((\mach,\context)\) such that
\((\mach,\context) \stepstounder{e} (\mach',\context')\) with
\(e = \mathbf{callE} ~ \addr ~ \overline{\word}\),
\((\mach',\context')\) enjoys return-time integrity.

\subsection{Caller Confidentiality}

Confidentiality properties are also modeled as non-interference, but with a twist:
the caller's confidential data should be kept secret from the callee, but after return,
will naturally be accessible to the caller once again. So, we must model confidentiality
in terms of events inside the callee. But confidentiality violations might not become
visible during the callee's lifetime -- the callee might read a secret and stash it somewhere
that it will be accessed later. So we must also consider the machine state at the end
of the call.

We could define a natural, strict form of confidentiality that requires that the final
states be identical. However, as with integrity, this is stricter than we need -- there
may be some conditions in which a secret is copied, but never used again. So, we once
again wish for our final condition to allow values to be vestigial. Which values?

\definition Let \(\mach,\mach'\) and \(\nach,\nach'\)
be pairs of machine states. Their {\em corrupted set}, written
\(\bar{\Diamond}(\mach,\mach',\nach,\nach')\), is the set of all elements
\(\component \in \Delta(\mach,\mach') \cup \Delta(\nach,\nach')\) such that
\(\mach'[\component] \not = \nach'[\component]\).

\definition Let \((\mach,\context)\) be a state with \(\context = (V,\sigma)\), and
\(\components = \{\component | V ~ \component \in \{\sealed, \unsealed\}\}\).

Then \((\mach,\context)\) enjoys {\it internal confidentiality} with respect to
if, for any \(\nach\) that is a \(\components\)-variant of \(\mach\), we can take
\(|\sigma| \uparrow (\mach,\context) \hookrightarrow \obsT\) and
\(|\sigma| \uparrow (\nach,\context) \hookrightarrow \obsT'\) and have that
\(\obsT \simeq \obsT'\).

\definition Let \((\mach,\context)\) be a state with \(\context = (V,\sigma)\),
and \(\components = \{\component | V ~ \component \in \{\sealed, \unsealed\}\}\).
Then \((\mach,\context)\) enjoys {\it return-time confidentiality}
if, for any \(\nach\) that is a \(\components\)-variant of \(\mach\),
\((\mach,\context) ~ (|\sigma| \Uparrow R) ~ (\nach,\context)\),
where \((\mach_1,\context_1) ~ R ~ (\nach_2,\context_2)\) if
\((\mach_1,\context_1) \parallel \bar{\Diamond}(\mach,\mach_1,\nach,\nach_2)\).

\definition A system enjoys {\it caller confidentiality} if, for all reachable states
\((\mach,\context)\) such that \((\mach,\context) \stepstounder{e} (\mach',\context')\)
with \(e = \mathbf{callE} ~ \addr ~ \overline{\word}\),
\((\mach',\context')\) enjoys both internal and return-time confidentiality.

\subsection{Callee Confidentiality}

Callees can have secrets too. The question is, what do we consider a callee's secrets?
Anything in its frame? Anything that {\it could} be in its frame (i.e. above the stack pointer)?
These are plausible options, but they will also capture data that has been written to those
locations before the call. To get a narrower property specific to the data that is actually
derived from the callee, we focus instead on those values that the callee has written.

\definition Let \((\mach,\context)\) be a state with \(\context = (V,\sigma)\), and
\(\components = \{\component | V ~ \component \in \{\sealed,\unsealed\}\}\).
Let \(P\) be a predicate that holds on a state \((\mach',\context')\) if
\(\mach' ~ \parallel ~ \Delta(\mach,\mach') \cap \components\).
Then \(\mach\) enjoys {\it post-return confidentiality} if \(|\sigma| \downarrow P\) holds.

\definition A system enjoys {\it callee confidentiality} if, for all reachable states
\((\mach,\context)\) such that \((\mach,\context) \stepstounder{e} (\mach',\context')\)
with \(\psi = \mathbf{callE} ~ \addr ~ \overline{\word}\),
\((\mach',\context')\) enjoys post-return confidentiality
with respect to \(\context\).

Interestingly, callee confidentiality subsumes caller integrity. This makes sense:
one way for the callee's secrets to leak is by overwriting the caller's sealed data
with them.

\section{Public Memory}

We can extend our basic machine to support public memory allocations that can
be accessed by anyone until they are deallocated on their owner's return,
using the \(\mathbf{alloc\_pub}\) operation. This behaves identically to
\(\mathbf{alloc}\) except that it marks the locations \(\public\).
We should give an example of this, as it may also require us to use multiple
allocations simultaneously to interleave public and private allocations with a
single increase of the stack pointer.

\section{Tail Call Elimination}

I submit that tail calls will work perfectly fine with all of our definitions
using the context update in Figure \ref{fig:tailcallcontexts}. All of the
``until return'' stuff works fine, because all the calls return at once.
We need to define callee confidentiality still.

\begin{figure*}

\judgmenttwo[TailCallC]
            {\(\chi = \mathbf{tailcall} ~ r_{target} ~ \overline{r_{args}}\)}
            {\(V' = \mathit{update\_view} ~ V ~ \overline{r_{args}}\)}
            {\(Cop ~ \chi ~ (V,\sigma) ~ (V',\sigma)\)}

\caption{Tailcall context updates}
\label{fig:tailcallcontexts}
\end{figure*}

\section{Provenance, Capabilities, and Protecting Objects}

So far, we have given functions the ability to allocate completely unprotected
objects. What if we want to express a finer-grained notion of safety, in which
such objects are protected unless the function that owns them intentionally
passes a pointer to them?

In order to express such a property, we need our machine to carry some notion
of {\it pointer provenance} -- a distinction between a pointer that is intended to
point to a given object, and non-pointer integers as well as pointers to other objects.
Then, in \(\mathit{update\_view}\), we recursively identify all public objects that
are reachable transitively from capabilities in registers; these keep their
\(\mathit{object}\) status, while those that are not reachable become \(\sealed\).

\section{Simple Concurrency}

\bibliographystyle{IEEEtran}
\bibliography{bcp.bib,local.bib}

\end{document}
