
\newcommand*{\add}{\textsc{add}}
\newcommand*{\addi}{\textsc{addi}}
\newcommand*{\sw}{\textsc{sw}}
\newcommand*{\lw}{\textsc{lw}}
\newcommand*{\jal}{\textsc{jal}}
\newcommand*{\jalr}{\textsc{jalr}}
%\newcommand*{\rsp}{\textsc{sp}}
\newcommand*{\rra}{\textsc{ra}}
\newcommand*{\rout}{\textsc{out}}

\newcommand*{\tagInstr}{\textsc{instr}}
\newcommand*{\tagCall}{\textsc{call}}
\newcommand*{\tagHa}{\textsc{h1}}
\newcommand*{\tagHb}{\textsc{h2}}
\newcommand*{\tagRa}{\textsc{r1}}
\newcommand*{\tagRb}{\textsc{r2}}
\newcommand*{\tagRc}{\textsc{r3}}
\newcommand*{\tagNoDepth}{\textsc{unused}}
\newcommand*{\tagStackDepth}[1]{\textsc{stack} ~ #1}
\newcommand*{\tagPCDepth}[1]{\textsc{pc} ~ #1}
\newcommand*{\tagSP}{\textsc{sp}}

%\newcounter{pcctr}
%\setcounter{pcctr}{0}
%  \thepcctr & \stepcounter{pcctr} #1 & #2 & #3 & \text{#4}\\
%\newcommand*{\row}[4]{
%  \thepcctr & \stepcounter{pcctr} #2 & #3 & \text{#4}\\
%}
%\newcommand*{\tracerow}[5]{
%  #1 & #2 & #3 & #4 & \text{#5}\\
%}
%\newcommand*{\summary}[6]{
%\[
%\begin{array}{cccccc}
%  \PCname = #1 & r_0 = #2 & \rra = #3 & \rsp = #4 & r_4 = #5 & r_5 = #6
%\end{array}
%\]
%}
\newcommand{\negate}{\textrm{-}}

\colorlet{lgray}{gray!40}

\newcommand{\instrc}{lgray}
\newcommand{\mainsealc}{cyan}
\newcommand{\fsealc}{green}
\newcommand{\unsealc}{gray}
\newcommand{\emptyoutc}{white} % or gray for consistency with unusedc ?
\newcommand{\fulloutc}{white}

\begin{figure}

\begin{subfigure}{.4\textwidth}
\begin{verbatim}
int main() {
0:     int x = 42, y = 0;
1[C]:  y = f(10);
2:     print (x + y);
}

int f(int z) {
10:     print z;
11[R]:  return (z+z);
}
\end{verbatim}
\caption{A Simple Call}
\label{fig:simple-program}
\end{subfigure}
\begin{subfigure}{.4\textwidth}  
\begin{center}
\begin{tabular}{l l}
{\tt 0} &
\memoryaddrs{4em}
\memory{2}{\unsealc}[{\makebox[0pt]{Unsealed}}]
~$\cdots$
\\
{\tt 1} &
\memoryaddrs{12em}
\memory{3}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{42}
\MemoryLabel{-10em}{0.75em}{0}
\vspace{.5em}
\\
{\tt 10} &
\memoryaddrs{12em}
\memory{2}{\mainsealc}[{\makebox[0pt]{Sealed(0)}}]%
\memory{1}{\unsealc}
~$\cdots$
\\
{\tt 2} &
\memoryaddrs{12em}
\memory{3}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{42}
\MemoryLabel{-10em}{0.75em}{0}
\\
\end{tabular}
\end{center}

\vspace{\abovedisplayskip}

\caption{Trace of Stack Domains}

\label{fig:simple-trace}
\end{subfigure}
\end{figure}

This section will elucidate the intuition behind the properties through a series
of examples. Existing stack safety enforcement work mostly refers directly to examples
of bad behavior that it prevents; we will insert our model between the enforcement and
the examples, arguing that:

\begin{itemize}
\item Examples that appear to violate stack safety, violate at least one of our properties
\item We do not find desireable behaviors that appear stack-safe yet violate our properties
\item Our properties are testably implemented by stack safety micro-policies from the literature,
  and the micro-policies are not significantly more conservative (i.e., policy failstops tend to
  correspond to imminent property violations)
\end{itemize}

\Cref{fig:simple-program} shows a simple example, written in C-like pseudo-code.
It consists of a {\tt main} function that performs a call to a function {\tt f},
which prints its argument, performs arithmetic, and returns a result.
\Cref{fig:simple-trace} shows the stack as it is divided into domains throughout
the program execution. We use high-level code for compactness, but reason about
a standard compilation of each function. Line numbers correspond to the code
addresses just before the code that implements the line, and annotations
{\tt C} and {\tt R} indicate that an instruction is annotated as a call or
return, respectively.

We also assume that the machine is word- (not byte-) addressed and that the
machine communicates with the outside world through a single memory-mapped
output port whose address is elided (so a {\tt print} statement will be
compiled to a store to this location), and that the stack grows upwards.

In the initial memory layout the entire stack is currently {\em unsealed},
meaning that it is eligible to be written to. At the call from {\tt main} to
{\tt f}, {\tt main}'s locals (as designated by the stack pointer) are
{\em sealed} and labeled with the depth of their owner, in this case 0.
Sealing is the fundamental integrity contract between the caller and callee:
{\tt main} expects that {\tt x} and {\tt y} will be unchanged when it gets control back.
This gives us our simple, intuitive statement of {\em stepwise integrity}:
if a component is sealed before a step, it will be unchanged afterward. Stepwise
refers to the fact that the property must hold on every step. Later we will
loosen this condition in the interest of extensionality -- the caller only
cares about changes it can see after the return, not changes during execution.

Suppose we insert an instruction after line 10, that stores 5 to the stack pointer - 1.
Then we would be changing {\tt y}, which is sealed, in violation of stepwise integrity.

\begin{figure}

\begin{subfigure}{.35\textwidth}
\begin{verbatim}
int main() {
0:     int x = 42, y = 0;
1[C]:  y = f();
2:     print (x + y);
}

int f() {
10:     int z = *($SP-1);
11[R]:  return (z+z);
}
\end{verbatim}
\caption{A Confidentiality Violation}
\label{fig:conf1-program}
\end{subfigure}
\begin{subfigure}{.5\textwidth}  
\begin{center}
\begin{tabular}{l l l l}
{\tt 0} &
\memoryaddrs{4em}
\memory{3}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{a}
\MemoryLabel{-10em}{0.75em}{b}
\MemoryLabel{-7em}{0.75em}{c}
\vspace{.5em}
& &
\\
{\tt 1} &
\memoryaddrs{12em}
\memory{3}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{42}
\MemoryLabel{-10em}{0.75em}{0}
\MemoryLabel{-7em}{0.75em}{c}
\vspace{.5em} & &
\\
{\tt 10} &
\memoryaddrs{12em}
\memory{2}{\mainsealc}
\memory{1}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{42}
\MemoryLabel{-10em}{0.75em}{0}
\MemoryLabel{-7em}{0.75em}{c} &
\memoryaddrs{12em}
\memory{2}{\mainsealc}
\memory{1}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{a'}
\MemoryLabel{-10em}{0.75em}{b'}
\MemoryLabel{-7em}{0.75em}{c'}
\\
{\tt 11} &
\memoryaddrs{16em}
\memory{2}{\mainsealc}
\memory{1}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{42}
\MemoryLabel{-10em}{0.75em}{0}
\MemoryLabel{-7em}{0.75em}{0} &
\memoryaddrs{16em}
\memory{2}{\mainsealc}
\memory{1}{\unsealc}
~$\cdots$
\MemoryLabel{-14em}{0.75em}{a'}
\MemoryLabel{-10em}{0.75em}{b'}
\MemoryLabel{-7em}{0.75em}{b'}
\\
\end{tabular}
\end{center}

\vspace{\abovedisplayskip}

\caption{Trace of Stack Domains}

\label{fig:conf1-trace}
\end{subfigure}
\end{figure}

Meanwhile confidentiality intuitively states that the callee, {\tt f}, is unaware
of the context of its call (with the exception, of course, of its arguments).
We state this in a style similar to {\em noninterference}, a well-known concept in theoretical
security. Noninterference describes knowledge: it states that for some component(s)
that we do not know, we can substitute any values whatsoever without changing the results
of our computation. If there exists some value for which we see different results, then
in fact we can learn something about the components by observing those results, violating
confidentiality.

In example \ref{fig:conf1} we see that the callee, {\tt f}, violates confidentiality
by reading {\tt main}'s variable {\tt y}, which was not passed to it. The trace
in figure \ref{fig:conf1-trace} shows how noninterference works. First, let \(a\),
\(b\), and \(c\) be the unknown initial values at their locations. On entry to {\tt f}
we again have 42 and 0 in {\tt x} and {\tt y}, and {\tt z} contains \(c\). We consider a
{\em variant state} that replaces the values of components that should be secret with
arbitrary values \(a'\), \(b'\), and \(c'\). After a step, we've copied 0 and \(c'\),
respectively, into {\tt z}. Since {\tt z} changed value, for confidentiality to hold,
its value should be the same in all variant states. But when \(c' \not = 0\), the
states changes differently, which violates confidentiality. It would also be a violation
to print the secret value.

This form of confidentiality we will term {\em lockstep confidentiality}, defined informally
as: for any state at the entry to a function, for any variant over the values in the stack,
the primary state and its variant will step in lockstep until they return. Any components
whose values update and any printed values will be identical between the primary and variant
traces.

\begin{figure}

\begin{subfigure}{.35\textwidth}
\begin{verbatim}
int main() {
0[C]:  int t = f();
1[R]:  return;
}

int f() {
10:     int x, y = 5, z = 6;
11:     print y+z;
12:     $SP-=2;
13[C]:  x = g();
14[R]:  return x;
}

int g() {
20:     int z = *$SP;
21[R]:  return (z+z);
}
\end{verbatim}
\end{subfigure}
\begin{subfigure}{.5\textwidth}  
\begin{center}
\begin{tabular}{l l l l}
{\tt 13} &
\memoryaddrs{12em}
\memory{1}{\mainsealc}
\memory{3}{\unsealc}
~$\cdots$
\MemoryLabel{-18em}{0.75em}{a}
\MemoryLabel{-14em}{0.75em}{b}
\MemoryLabel{-10em}{0.75em}{5}
\MemoryLabel{-7em}{0.75em}{6}
\vspace{.5em}
& &
\\
{\tt 20} &
\memoryaddrs{12em}
\memory{1}{\mainsealc}
\memory{1}{\fsealc}
\memory{2}{\unsealc}
~$\cdots$
\MemoryLabel{-18em}{0.75em}{a}
\MemoryLabel{-14em}{0.75em}{b}
\MemoryLabel{-10em}{0.75em}{5}
\MemoryLabel{-7em}{0.75em}{6}
\vspace{.5em} &
\memoryaddrs{12em}
\memory{1}{\mainsealc}
\memory{1}{\fsealc}
\memory{2}{\unsealc}
~$\cdots$
\MemoryLabel{-18em}{0.75em}{a'}
\MemoryLabel{-14em}{0.75em}{b'}
\MemoryLabel{-10em}{0.75em}{c'}
\MemoryLabel{-7em}{0.75em}{d'}
\vspace{.5em}
&
\\
{\tt 21} &
\memoryaddrs{12em}
\memory{1}{\mainsealc}
\memory{1}{\fsealc}
\memory{2}{\unsealc}
~$\cdots$
\MemoryLabel{-18em}{0.75em}{a}
\MemoryLabel{-14em}{0.75em}{b}
\MemoryLabel{-10em}{0.75em}{5}
\MemoryLabel{-7em}{0.75em}{6}
\vspace{.5em} &
\memoryaddrs{12em}
\memory{1}{\mainsealc}
\memory{1}{\fsealc}
\memory{2}{\unsealc}
~$\cdots$
\MemoryLabel{-18em}{0.75em}{a'}
\MemoryLabel{-14em}{0.75em}{b'}
\MemoryLabel{-10em}{0.75em}{c'}
\MemoryLabel{-7em}{0.75em}{d'}
\vspace{.5em}
&
\\

\end{tabular}
\end{center}

\vspace{\abovedisplayskip}

\end{subfigure}

\caption{Another Confidentiality Violation}
\label{fig:conf2}
\end{figure}

Two important details of confidentiality are reflected in figure \ref{fig:conf2}.
