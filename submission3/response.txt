# Overview

We thank the reviewers for their comments.

The reviews identify some areas that the paper fails to explain
adequately -- in particular, "framing" questions: How does the work improve
on existing formalizations of stack safety? Do we have a plan to validate
the model further?  Can our work be extended to cover more complex uses of
the stack?

In the next section, we outline the changes we plan to make in the paper to
clarify these questions.  We discuss the issues in more detail in the third
section.

## Changes

1. We will give a more thorough discussion of validation, discuss the
   feasibility of proofs and of randomized testing of more complex
   properties, and detail our roadmap for further validation of different
   versions of the property. For details, see the comments responding
   to reviewer A.

  *Status* - not incorporated

2. We will give a more explicit and direct comparison to the work of
   Skorstengaard et. al. Currently we discuss it briefly in our related work
   section, but the novelty of our work does not come through clearly
   enough; we will explain the differences more thoroughly, all in one place.
   For details, see the comments responding to reviewer B.

  *Status* - incorporated, but needs example/more discussion

3. We will improve the presentation as suggested. In particular, we will
   gradually introduce the examples and associated intuitions (including our
   visual metaphors) as early as possible, starting in the introduction.

  *Status* - not incorporated

4. We will more clearly call out common language features, such as the heap,
   that are compatible with our treatment of stack safety. For details,
   see the comments responding to reviewer B.

  *Status* incorporated

5. We will add a discussion of how to extend the model to a callee-saves
   registers convention, which demonstrates a second concrete use for 
   the observational properties. Previously we were concerned about space
   and explanatory complexity, but in retrospect we see that discussing
   register protection would paint a more complete picture.
   For details, see the comments responding to reviewer A.

  *Status* incorporated

# Detailed Comments

## Reviewer A

We will extend the paper with a more detailed discussion of our roadmap for
verification and testing and the issues that we expect to arise. Here is a
rough outline of how it would cover the concerns raised in the review.

> ...discussion on whether it is feasible/desirable/in-progress/etc. to prove enforcement mechanisms correct.

Correctness of an enforcement mechanism with respect to our properties
is certainly amenable to formal proof. Such a proof would be
considerable work to carry out for a full ISA like RISC-V, but we see
no fundamental barriers.  We chose to concentrate on testing because
it is better aligned with our immediate goal of evaluating real
enforcement mechanisms for real machine architectures.

> * The testing for the lazy tagging/clearing found mistakes but the "potential fix [is] itself a prime candidate for future testing" [line 868]
>
> * Any validation for the lazier observability definition (this is listed as future work.)^M
>
> * Any validation for the coroutine work.


[ We have since tested lazy tagging/clearing and found it to pass the
  newly implemented observational integrity property as well as normal,
  stepwise confidentiality. But we did not have this ready before the
  deadline.
| We are working to implement testing of observational properties and to apply
  this to the putatively fixed version of the lazy tagging/clearing
  micro-policy. ]

Our other short-term plan is to implement testing of a second enforcement
mechanism -- a Cheri implementation of stack safety -- to demonstrate that
our properties are not strictly tied to tag-based enforcement. We are
currently working on QuickChick generators for Cheri programs, which
have a different calling convention (a more complicated one, which is easier
to get wrong!). This effort is beyond the scope of this paper, but we will
sketch it as future work. 

Validation of the argument-passing and coroutine models are longer-term
projects.  The argument-passing model has existing enforcement mechanisms and serves
an important role in common stack use cases. Coroutines will require the
development of an enforcement mechanism (e.g., one based on tags) to
validate.

> Another minor question: The difference between [nested] call-by-reference
> and passing address-of-local was interesting, but I'm not sure how much it
> makes sense to argue the latter is "beyond the scope of stack safety per
> se" [line 939] without arguing the same of the former.  Perhaps the
> argument can be made that address-of-local can be put in the heap while a
> by-reference parameter cannot and since you don't guarantee heap safety,
> you shouldn't try to do anything useful with address-of-local?

Yes, this was exactly our thinking.  We know what constitutes legal access
to stack-allocated arguments, but for explicit pointers this is much less
clear, and depends on the intent of the programmer. We believe an
address-of-local should be treated similarly to the address of a heap
object, but with a different lifetime. For instance, if a heap safety model
treats heap pointers like capabilities (possession implies access rights),
we would treat stack pointers the same.  Similarly, if the heap model
permits pointer forging (restricted to within compartments, say) we would
expect to be able to forge pointers to address-taken locals in the same
circumstances.

In the longer term we would like to extend our model with a heap, in
the style of Azevedo de Amorim et al. [1] which is phrased in similar
terms to our model and should be compatible. In this setting the
interplay between heap-derived and stack-derived pointers (with
similar behaviors but different lifespans) will be much more
interesting.

## Reviewer B

> Q3. Why don't you assume well-bracketed control flow like Skorstengaard et
> al (L289-291)? What are the implications of that?

Skorstengaard et al. don't directly assume well-bracketed control
flow, they enforce it. But the terms in which they define it differ
from ours. Their version assumes a code layout where each function has
an isolated footprint and they don't permit unrestricted jumps between
footprints.  Our definitions are sensible without that assumption.

## Reviewer C

> - It is a bit difficult to assess the merits of this work. Yes, the
>   stack safety property is important for security, but what new results
>   or new capabilities does the proposed definition bring in?

First, we contend that a formal definition of stack safety is valuable in
its own right, as a way of shifting the discussion away from specific
examples of bad behavior that must be prevented and toward general
mechanisms that ensure good behavior.  A formal definition gives us the
ability to reason clearly about what is gained from applying a given
enforcement mechanism to a system. Since many enforcement mechanisms are
quite costly in speed, dollars, and/or silicon, it is important to
understand precisely what they buy us.

More immediately, we can use a formal definition like this to test proposed
enforecement mechanisms for violations of the policy.  In our case study, we
identify a previously unknown bug in Roessler and Dehon's proposed "lazy
tagging" micro-policy, and we use randomized testing to increase confidence
that their "depth isolation" micro-policy correctly implements stack safety.

>   The paper does not talk about data flow
>   across heap and stack, which is an important element for many
>   real-world memory corruption attacks.

Agreed!  We plan to combine our stack model with a heap model in the style
of Azevedo de Amorim et al. [1] as future work.  Both models are phrased in the
conceptual terminology of language-based security, so we have reason to
believe that they will fit together cleanly.

----------------

[1] A. Azevedo de Amorim, C. Hritcu, and B. Pierce, "The Meaning of Memory Safety,"
Proc. Principles of Security and Trust, 2018. 
