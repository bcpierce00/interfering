%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmtog,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{OOPSLA} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmnumeric}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\input{macros}

\begin{document}

%% Title information
\title{Security Properties for Stack Safety}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
%\author{Sean Noble Anderson}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position1}
%  \department{Computer Science}              %% \department is recommended
%  \institution{Portland State University}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{Country1}                    %% \country is recommended
%}
%\email{ander28@pdx.edu}          %% \email is recommended

%\author{Leonidas Lampropoulos}
%\affiliation{
%  \institution{University of Maryland, College Park}
%}
%\email{leonidas@umd.edu}

%\author{Roberto Blanco}
%\affiliation{
%  \institution{Max Planck Institute for Security and Privacy}
%}
%\email{roberto.blanco@mpi-sp.org}

%\author{Benjamin C. Pierce}
%\affiliation{
%  \institution{University of Pennsylvania}
%}
%\email{bcpierce@cis.upenn.edu}

%\author{Andrew Tolmach}
%\affiliation{
%  \institution{Portland State University}
%}
%\email{tolmach@pdx.edu}

%
%%% Author with two affiliations and emails.
%\author{First2 Last2}
%\authornote{with author2 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position2a}
%  \department{Department2a}             %% \department is recommended
%  \institution{Institution2a}           %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
%  \country{Country2a}                   %% \country is recommended
%}
%\email{first2.last2@inst2a.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
%\begin{abstract}
%What exactly does ``stack safety'' mean? The phrase is associated with a
%variety of compiler,
%run-time, and hardware mechanisms for protecting stack
%memory.  But these mechanisms typically lack precise specifications,
%relying instead on informal descriptions and examples of bad
%behaviors that they prevent.

%We propose a formal characterization
%of stack safety, formulated with concepts from language-based security: a
%combination of an integrity property (``the private
%state in each caller's stack frame is held invariant by the callee''),
%a confidentiality property (``the callee's behavior is insensitive to the
%caller's private state''), and a well-bracketedness property (``each
%callee returns control to its immediate caller'').

%We use these properties to validate the stack-safety ``micro-policies''
%proposed by~\citet{DBLP:conf/sp/RoesslerD18}.  Specifically, we check (with
%property-based random testing) that Roessler and Dehon's ``eager''
%micro-policy, which catches violations as early as possible, enforces a
%simple ``stepwise'' variant of our properties and correctly detects several
%broken variants, and that (a repaired version of) their more performant
%``lazy'' micro-policy corresponds to a slightly weaker and more extensional
%``observational'' variant of our properties.

%\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\ifcameraready
\keywords{Stack Safety, Micro-Policies}  %% \keywords are mandatory in final camera-ready submission
\fi


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

%\section{Introduction}

The call stack is a perennial target for low-level attacks, leading to
consequences that range from leakage or corruption of private stack data to
control-flow hijacking. A profusion of
software and hardware protections have been proposed for detecting or
preventing such attacks,
%
including stack canaries~\citep{Cowan+98},
bounds checking~\citep{NagarakatteZMZ09,NagarakatteZMZ10,DeviettiBMZ08},
split stacks~\citep{Kuznetsov+14},
shadow stacks~\citep{Dang+15,Shanbhogue+19},
capabilities~\citep{Woodruff+14,Chisnall+15,SkorstengaardLocal,SkorstengaardSTK,Georges+21},
and hardware tagging~\citep{DBLP:conf/sp/RoesslerD18}.
%
The protections offered by such mechanisms are commonly described in terms
of concrete examples of attacks that they can prevent.
At best, stack safety is defined by reference to an idealized machine that
is arguably stack safe by construction \citep{SkorstengaardSTK}.
But these mechanisms can be intricate, and it would be useful to have a precise, generic, and formal
specification for stack safety, both to compare the security claims of different
enforcement techniques and to rigorously validate such claims.

We propose such a characterization
using the tools of language-based security. The informal claim that
``stack safety protects a caller from its callee'' amounts to saying
that it guarantees
the {\em integrity} and {\em confidentiality} of the caller's local state
until it regains control.
%
We formalize these integrity and confidentiality requirements as trace
(hyper-)properties, with two different
variants: {\em stepwise} variants, in which a caller's data must {\em never} be
read or modified during a call, and {\em observational} ones, in which
callees may read from and write to their caller's stack frame, as
long as these ``risky'' behaviors do not affect the system's observable
behavior. The observational properties are more extensional and thus
allow ``lazier'' protection mechanisms that permit risky reads or
writes as long as they do not affect visible outcomes.

Confidentiality is especially interesting.  It is based on a traditional
notion of noninterference, but whereas ordinary noninterference is
an end-to-end hyper-property on whole program runs, stack confidentiality is
a ``nested'' form of
noninterference applied to
subtraces of the whole program trace delimited by call instructions and
corresponding returns, requiring that the callee's behavior is invariant
under hypothetical scrambling of the caller's stack frame.
%behavior of the callee is
%independent of the caller's stack frame.
%, between each call
%instruction and the corresponding return, the
%caller's stack frame is protected from the callee.

Our threat model is very strong, allowing the attacker (i.e., the callee) to
execute arbitrary code, including code that might attempt to smash
the stack to disrupt the program's control flow.
Our stack safety properties demand that, even in the presence of such
attackers, confidentiality and integrity must
still apply to data in suspended stack frames.
% all of the data they would under more idealized conditions.
%This formulation not only captures the intuition
%that the callee cannot directly access the caller's state; it also gives a novel
%interpretation of integrity and confidentiality in the presence of control-flow
%attacks.
\bcp{I tried rewriting the first part of the paragraph, and I like it
  better, but now there's a big gap between that and what comes next.  I
  wonder whether we need to turn the next bit into a separate discussion of
  ``what it means to return''...  In any case, I felt like the previous
  version of the whole paragraph didn't quite nail what we needed to say
  about all this.}
The key is that every call has a corresponding predicate on states,
designated as the ``return target,''
which defines what it means for that call to truly return: the program counter
must be at the next instruction, and the stack pointer restored to its original
value. A callee may execute a return instruction,
but if it does not reach a return target we simply do not recognize it as a return.
So the callee can be ``active'', and the caller protected, even if the callee is
executing instructions outside of its normal footprint.
% that don't look like they belong to the caller.

%Our attacker model is strong, allowing the attacker to execute arbitrary code, so
%the callee has no reason to execute the caller's instructions -- any instruction it could
%jump to, it could already execute. The only reason to perform a ``fake'' return in this setting
%would be to access the caller's data, which our properties will correctly identify as a violation.

These properties can optionally be extended with a notion of {\em well-bracketed control flow}
as in \citet{SkorstengaardSTK}---a global requirement that callees
must always return
to their immediate caller, if they return at all. This property is orthogonal to our
data-protection properties. It remains meaningful in our strong attacker model, because
it supports reasoning about the ordering of valid returns.

To demonstrate the utility of our properties, we use them
to evaluate an existing mechanism, the
{\em stack-safety micro-policies} of~\citet{DBLP:conf/sp/RoesslerD18}, re-implemented
in the Coq proof assistant on top of a RISC-V ISA model. We
use QuickChick~\citep{Denes:VSL2014,Pierce:SF4}, a property-based testing
tool for Coq, to generate random programs and check
that Roessler and Dehon's micro-policies correctly abort programs that
would violate stack safety.
Our testing regime is also able to detect incorrect variants of the
enforcement mechanisms---both variants that we accidentally created
during our re-implementation of the micro-policy and ones that we
intentionally crafted to be broken in order to increase our confidence
in testing and the enforcement mechanism itself. For these broken
mechanisms, our tester
generates counterexamples that violate our properties but escape the
enforcement.  This increases our confidence in enforcement
mechanisms for which the tester is unable to find  counterexamples.

Our testing supports the stack-safety claim of Roessler and Dehon's {\em Depth
  Isolation} micro-policy, in
which memory cells within each stack frame are tagged with the depth of
the function activation that owns the frame and access to those locations is
then permitted only when that activation is currently executing.
On the other hand, we find that their \emph{Lazy Tagging and Clearing} policy
violates the temporal aspect of confidentiality in
corner cases where data can leak across repeated calls to the same callee,
and also violates integrity if the leak happens to use the caller's frame. We
propose a variant of {\em Lazy Tagging and Clearing} that
  we believe will enforce observational
integrity and confidentiality, albeit at some performance cost. (An obvious next step
is to expand testing to these properties and validate the variant, but
efficiently
testing observational properties is more challenging because a property
violation can be arbitrarily far removed from the initial ``risky'' read or
write.)

We demonstrate our model's flexibility by extending it to different settings.
First, we can support passing arguments on the stack, allowing some of the state of
the caller to be shared with the callee (and potentially with a sub-callee,
and so on.)  We can also describe a simple coroutine model, with one
statically bounded stack per coroutine, each protected from the others.

In ongoing work, we are investigating whether stack protection schemes
based on the Cheri capability system~\citep{Woodruff+14,Chisnall+15}
can enforce our properties.  In particular, we are adapting
the ``uninitialized capability model'' of \citet{Georges+21} to work with
our testing framework in order to validate it against our properties. Out of several Cheri-based
stack protection schemes, this one's treatment of unitialized frames seems most compatible
with our model of confidentiality, without the need for expensive stack clearing
between calls. We expect that Cheri-based techniques can support our properties if we
assume extra cooperation from callers, namely that they do not leak their capabilities
to the attacker. %There is no equivalent dynamic requirement in a tag-based system because
%the policy can dynamically enforce cooperation.

\bibliography{bcp.bib,local.bib}

%% Appendix
%\appendix
%\section{Appendix}
%Text of appendix \ldots

\end{document}
