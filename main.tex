\documentclass[conference]{IEEEtran}
\newif\ifdraft \drafttrue
\newif\iftext \textfalse

\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand{\bcp}[1]{\ifdraft\textcolor{violet}{{[BCP:~#1]}}\fi}


\begin{document}

\title{Interfering with Noninterference
\iftext\thanks{\bcp{Identify applicable funding agencies here (DARPA and NSF
    and...?)}}\fi
}

\iftext
\author{\IEEEauthorblockN{Roberto Blanco}
\IEEEauthorblockA{\textit{\bcp{affiliation?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
\and
\IEEEauthorblockN{Leonidas Lampropoulos}
\IEEEauthorblockA{\textit{University of Maryland \bcp{right?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\IEEEauthorblockN{Benjamin C. Pierce}
\IEEEauthorblockA{\textit{University of Pennsylvania}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\IEEEauthorblockN{Andrew Tolmach}
\IEEEauthorblockA{\textit{Portland State University}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
}
\fi

\maketitle

\iftext
\begin{abstract}
\end{abstract}

\begin{IEEEkeywords}
% component, formatting, style, styling, insert
\end{IEEEkeywords}
\fi

\section{Machine model}

(A sketch of) the RISC-V machine model and operational semantics.

Conventions:
%
\newcommand{\word}{W}
\newcommand{\addr}{A}
\newcommand{\WORDS}{{\mathcal W}}
\newcommand{\reg}{R}
\newcommand{\REGS}{{\mathcal R}}
\newcommand{\mach}{M}
\newcommand{\MACHS}{{\mathcal M}}
\newcommand{\PC}[1]{\mathit{PC}(#1)}
\newcommand{\pol}{P}
\newcommand{\POLS}{{\mathcal P}}
\newcommand{\trace}[1]{\overline{#1}}
\newcommand{\TRACES}{{\mathcal T}}
\newcommand{\stepsto}{\Rightarrow}
%
\begin{itemize}
\item Words / addresses: $\word,\addr \in \WORDS$
\item Registers: $\reg \in \REGS$
\item Machine states:
$\mach \in \MACHS = (\WORDS\rightarrow\WORDS,\, \REGS\rightarrow\WORDS,\,
\WORDS)$
\item Abbreviations:
\\ $\mach(\addr) = \mach.1(\addr)$
\\ $\mach(\reg) = \mach.2(\reg)$
\\ $\mach(\textsc{pc}) = \mach.3$
\item Step function\footnote{\bcp{I'm taking the step function to be total;
    we could make it partial if we want, but I'm not sure this refinement is
    important.}}: $\mathord{\stepsto} \in \MACHS \rightarrow \MACHS$
\end{itemize}

A {\em trace} $\trace{M} \in \TRACES$ is a nonempty, finite or infinite
sequence of machine states $\mach_0, \mach_1, \mach_2, ...$ such that
$\mach_{i-1} \stepsto \mach_i$, for each $i \geq 1$.

We use the word {\em policy} for any kind of dynamic enforcement
mechanism (e.g., a runtime taint tracker, heap coloring rules, capability
hardware, etc.). We use {\em property} for a mathematical predicate on
programs (or machine states) capturing some useful security goal, e.g. noninterference.

Formally, a {\em policy} $\pol \in \POLS$ is a prefix-closed set of traces.
I.e., it is a restriction of the set of all traces generated by the standard
step function, where some traces may be ``truncated early.''

\iftext \bcp{Not sure we need names for $|TRACES$ or $\POLS$.} \fi

\bcp{Now we need to define {\em property} formally.  But since we're talking
about hyperproperties, I'm not certain how to go about it.  The standard way
would be something like ``A policy $P$ has property $Q$ (i.e., $P$ is
noninterfering) if, for every pair of traces $\trace{M}$ and $\trace{M'}$
in $P \times P$, if the initial states $M_0$ and $M'_0$ differ only in
high parts then every pair ...'' (blah: I'm not sure whether to talk about
lockstep-corresponding states, which seems to restrictive, or final states,
which doesn't work if the traces are infinite!  do we really need some kind
of reactive noninterference here?? Urg.)}

\section{Noninterference}

\begin{itemize}
\item Reminder of the standard definition of NI.

\bcp{Write it!}

Designate sets of private, internal, and public addresses.

Begin by defining what it means for two traces to witness interference?

\item Fact: The standard RISC-V semantics does not guarantee NI.  (Give a
little example of a program that reads from a secret location and writes to
a public one, just to illustrate the definition of NI.)
\end{itemize}

\section{Tainting is noninterference$-$}

\begin{itemize}
\item First intuition: A program is taint-NI if every pair of runs that don’t
branch on high data are noninterfering in the standard sense.  (i.e., they
don't write secret data to public locations and vice versa)
\item Better alternative: … for every pair of runs that take the same control path (even if they branch on tainted data)...
\item \bcp{We could even go a step farther: {\em truncate} the runs at the
  first point where their PCs differ, then demand NI.  This is a less
  demanding property and probably a less desirable one, as it doesn't
  predict the behavior of actual taint policies.  Discuss.}
\item (Are there any other variations of tainting that we could present in
this framework?)
\end{itemize}

\section{Separation is noninterference$+$}

Presentation idea: Start here with a super-simple separation policy, which
just makes some part of the address space inaccessible, truncating any
traces that read or write it.  Formulate the property as a flavor of NI.
(The $+$ part in the title is a hint that one thing that gets added is that
the PCs of corresponding traces always stay in lock step.)

\section{Stack protection is noninterference$++$}

\begin{itemize}
\item
  Idea of accessibility: set of data memory addresses that can be read or written at a particular execution point.
  (Assume instruction memory is distinct.)
\item
  Stack protection intuition in a nutshell: caller's memory data is not accessible to callee, although callee's memory data is accessible to caller.
  This gives both an integrity property (callee cannot affect caller's memory) and a secrecy property
  (caller's memory cannot affect callee).
  Can generalize to other control situations, such as coroutines, threads, compartments,...
\item
  In NI terms, protected programs are oblivious to variations in memory outside of their accessible set.
  Unlike standard NI, the accessible set changes dynamically, so we cannot just frame the property in terms of
  variant start states. [Is this true? Is it a significant difference? Are there other significant differences?]
\item
  We start with a very simple (and unrealistic) set of assumptions/conventions for stack frames and procedure calls:
  \begin {itemize}
  \item All memory (except for instructions) forms a single contiguous stack, divided into frames, each associated with a procedure activation.
  \item Each frame consists of a saved return address and a single word of local data. These form the entirety of the procedure's memory data, and are the only thing we need to track when considering accessibility.
  \item Registers other than RA, SP are not affected by calls or returns and hence are the (only) way to pass values between caller and callee.
  \item Instructions serving as calls are statically marked as such in the code.
  \item The code for each procedure is bracketed by fixed entry and exit sequences (details to follow), which save/restore the RA and
    adjust the SP.
  \item During the body of the procedure, the single word of local data is accessed via SP, which does not change (except during a call, of course).  The stored RA in the frame never changes. [I'm confused about these. Are they assumptions, or do they have a different status?  We use tags to check them, but should we?]
  \end {itemize}
\item
  Describe conjecture 2 property in terms of this model: informally and formally.
\item
  Define abstract state descriptions.
\item
  Define step consistency.
\item
  Discuss relationship between state consistency and conjecture 2 property.  (Former is: presumably stronger; hopefully not
  too strong that it produces lots of undesired test failures; surely easier to test).

\end{itemize}







\iftext
\section{Stack + heap protection too}

POTENTIALLY: Memory safety (before stack) + Conjunction of memory + stack
safety (after).

(Memory safety by itself is just arthur’s paper, but it’s cool to see how
they are combined, especially what bits can be factored out as common
structure, e.g. the notion of accessibility)
\fi

\section{Implementation}

Sketch of the micropolicies that claim to implement these properties on
PIPE...

\subsection{A taint checking monitor}

\subsection{A stack safety monitor}

\section{Testing the implementations}

\begin{itemize}
\item Experimental results of testing
\end{itemize}

\section{Related work}

\begin{itemize}
\item Daniel's tainting paper (and some refs cited there)
\item Nick and Andre's papers (and other micropolicy papers)
\item StkTokens: Skorstengaard, Devriese, Birkedal
\begin{itemize}
\item {https://arxiv.org/pdf/1811.02787.pdf}
\item {https://arxiv.org/pdf/1902.05283.pdf}
\item {http://cs.au.dk/~lask/papers/esop2018.pdf}
\end{itemize}


\item Mechanized Reasoning about a Capability Machine: [Linn] Georges,
Trieu, Birkedal (PriSC 2020).
%
Described at the Iris Workshop as formalizing the security properties of
capabilities. This appears to involve a fairly complex and very large
mechanization in Iris (also in the eyes of the Iris people).
\end{itemize}

\iftext
\section{Future work}

\begin{itemize}
\item Variations / extensions (OS, multiple processes, coroutines, generalizing depths to stacks of static call points, etc.)
\item Extending the policy / property to more realistic ones
\begin{itemize}
\item Argument passing
\item Variable-size stack frames
\item Stack variables
\item Relation to Nick and Andre’s policy
\end{itemize}
\item Could we also implement all this using Cheri capabilities?
\end{itemize}

More:
\begin{itemize}
\item More realistic calling conventions.  (We need to eventually match this to the particular calling convention of whatever compiler we choose.)  E.g., the above will not quite work for passing arguments on the stack: callee won’t be able to read them…So perhaps need to support a special kind of write instruction that stores D.PCdepth+1 . [RB: Or implement this distinction through tags?]
\item Combination with heap policy (colors, etc.)
\item For coroutines:
\begin{itemize}
\item Generalize depth to depth + PID
\item Private stuff not having changed as an idea should still work
\item Maybe not so hard: The scheduler + other coroutines are just a sort of generalized “callee” as far as this process is concerned.  Just need to fiddle th step relation so that it recognizes which process is getting returned to and updates its description appropriately.
\end{itemize}
\item If we had a heap policy, maybe we could talk about dynamic code generation, loading, as allocating a heap region, storing instructions into it, and then calling into them.  For now, we just make all the instructions read only and assume they exist in the initial state.
\item Question: how efficiently can consistency be tested? How much scrambling is needed, and does it really need to occur before every instruction? How expensive is it to check for agreement between the (in)accessible parts of two memories?  Would spot checking for agreement be adequate?]
\item What are the effects of compartmentalization on the ability of each compartment to change its own code/stack?
\item Tail calls (maybe by not marking them as call sites?)
\end{itemize}

\section*{Acknowledgments}
\fi

\section*{References}
\bibliographystyle{IEEEtran}
% \bibliography{bcp,local}

\newpage

\section*{Things to think about}

\begin{itemize}
\item
How does Nick’s stack policy actually work these days?
\item Andrew remembers that Catalin looked at something like this a long time ago and they decided that they needed unique tags for each dynamic call, not just levels.  We should check.
\end{itemize}

\end{document}
