%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\input{macros}

\begin{document}

%% Title information
\title{Stack Safety as a Security Property}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
%\author{First1 Last1}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
%  \institution{Institution1}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{Country1}                    %% \country is recommended
%}
%\email{first1.last1@inst1.edu}          %% \email is recommended
%
%%% Author with two affiliations and emails.
%\author{First2 Last2}
%\authornote{with author2 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position2a}
%  \department{Department2a}             %% \department is recommended
%  \institution{Institution2a}           %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
%  \country{Country2a}                   %% \country is recommended
%}
%\email{first2.last2@inst2a.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Stack Safety, Micropolicy, Random Testing, RISC-V}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}

\newcommand*{\MemoryLabel}[3]{\raisebox{#2}{\makebox(0,0){\hspace{#1}#3}}}

\begin{figure}
  \begin{minipage}{\textwidth}
    \begin{center}
\MemoryLabel{10em}{1.5em}{40}
\MemoryLabel{16em}{1.5em}{60}
\MemoryLabel{22em}{1.5em}{80}
$\cdots$
\memory{4}{gray}%
\memory{5}{green}[{\makebox[0pt]{Caller}}]%
\memory{5}{yellow}[{\makebox[0pt]{Args}}]%
\memory{8}{red}[{\makebox[0pt]{Callee}}]%
\memory{4}{gray}%
~$\cdots$\\
  \end{center}
  \end{minipage}\\
~\\
~\\
  \begin{minipage}{0.45\textwidth}
    \begin{center}
\begin{verbatim}
jal ...
lw r1 r0 40
\end{verbatim}
    \end{center}
  \end{minipage}~
  \begin{minipage}{0.45\textwidth}
    \begin{center}
\begin{verbatim}
jal ...
sw r0 r0 40
\end{verbatim}
    \end{center}
  \end{minipage}
  \caption{Examples of Unsafe Programs}
  \label{fig:stackunsafety}
\end{figure}

\leo{I hate the writing here, but I wanted to make a start.}

The call stack is an increasingly popular target for attacks
exploiting memory safety vulnerabilities, with potential consequences
ranging from attackers reading or corrupting private stack data, to
highjacking a program's control flow. To prevent such attacks, many
techniques have been proposed in the literature\leo{cite, point out?
  stack canaries, cherry, nicks...} aiming to achieve {\em stack
  safety}.

But what {\em is} stack safety? A formal definition of stack safety is
lacking from the literature, with the notion only being defined
negatively: through examples of stack unsafety. Two classical examples
of stack unsafety appear in Figure~\ref{fig:stackunsafety}.
\leo{Goal: on the left, a bad read; on the right, a bad write.}
\leo{Do we also need an example of ROP/control flow for the new part?}

A common undertone in such examples is the intention to protect
callers from callees: a callee should be not be able to access or
overwrite a caller's private data. In this paper we turn this
intuition into a formal security property, with a confidentiality and
an integrity component.
%
Informally, {\em stack confidentiality} ensures that a callee's
observable behavior is not affected by memory outside its stack frame
(e.g. a caller's private data or uninitialized memory).  {\em Stack
  integrity} guarantees that if a function call returns, the caller's
stack data will be identical to what it was before the call.

While integrity and confidentiality are relatively standard security
properties, this setting provides an interesting additional challenge:
the notion of who the attacker shifts throught execution. Not only
does a caller need to be protected from its callee, but the callee
itself needs to be potentially proteced from {\em its} callees.  In
this paper we address this challenge by varying the observation power
of the attacker at call points, and demonstrate that our policy is
implementable by pre-existing monitoring mechanisms.

\leo{This will probably need to be fixed depending on what we end up
  doing}
%
A second common concern is to protect the call structure itself: a
callee should not be allowed to jump to the middle of an arbitrary
block of code either directly (via a jump instruction) or indirectly
(by corrupting stack data and returning). In this work we enforce
well-bracketed control flow by ensuring that code transitions are
valid based on a statically-known call graph of the
program. \leo{e.g. provided by the compiler?}

We begin by giving some background in Section~\ref{sec:prelim}.
Our contributions are:
\begin{itemize}
\item A formal property capturing the local state encaptulation
  notion of stack safety.
\item Evidence that this property is strong enough to capture the folk
intuition: we show that the stack
  unsafe examples from the literature also fail our property.
\item Evidence that the property is not too strong. It's realizible by
  a previously proposed  micropolicy enforcement mechanism \leo{And it
    says yes on a substantial body of code}
\item A (inductive? step-by-step/stepwise) variant of this property
  tuned for testing/verification together with a proof that it implies
  the original property.  We test the whole thing with a cool
  framework.
\item A lazy version of the property that allows for more efficient/dynamic enforcement.
  Maybe testing.
\item An extension to this formal property that enforces well-bracketed
  control flow and an accompanying policy.
\end{itemize}
Finally, in Section~\ref{sec:relwork} we discuss related work and
sketch directions for future work in Section~\ref{sec:future}.

\section{Background}
\label{sec:prelim}

We begin by describing our machine model. Concretely, we have in mind a
conventional machine architecture with a standard (RISC-V) processor
extended with some kind of (static or dynamic, software- or
hardware-enforced) security monitor, but we won't need to make any
specific choices about details until we get to \bcp{the policy one, probably}.
%In this section we will describe an abstract interface to our machine model.

Values and addresses are words drawn from some set of all words $\WORDS$. We will
denote words with $\word$.\leo{TODO: If we ever need ``A'' come back to this.}

Components are words (denoting addresses) and registers.
%
    \[\reg \in \REGS\]
    \[\component \in \COMPONENTS = \WORDS + \REGS \]
%
The registers must include two special purpose registers: the program
counter \PCname and the stack pointer \SP.

A machine state is just a map from components to values:
%
\[\mach \in \MACHS = \COMPONENTS \rightarrow \WORDS\]


Our stack safety property will be defined in terms of {\em observations}, which may be
silent (written $\tau$) or a word of data:
%
\[\obs \in \OBSS = \tau ~ | ~ \word \in \WORDS\]

These observations are a byproduct of the step function of the
machine, which takes a machine state and produces a pair of a
machine state and an observation.
%
\(\mach \stepstoobs{\obs} \mach' : \MACHS \rightarrow \MACHS \times \OBSS \).

\paragraph*{Policy}

A policy is a general model of an enforcement mechanism, consisting of
a set of policy states, \(\pol \in \POLS\) and a policy step function
\((\mach, \pol) \stepstopol \pol' : \MACHS \times \POLS
\rightharpoonup \POLS\).

%    The initializer and step function are both partial functions,
%    the former to reflect static guarantees (some initial states may not be valid at all) and
%    the latter to reflect dynamic fail-stop behavior. We then define machine-policy pairs and
%    a step function on them:

Let $\MPS$ be the set of all pairs of machine states and policy states.
%
\[\MPS = \MACHS \times \POLS\]
%
Then we can lift this policy step function to operate on such pairs,
by combining it with the regular step function for machine states.

%    \[\stepstoobs{}_P \subseteq \MPS \times \MPS\]

    \[\frac{\mach_1 \stepstoobs{\obs} \mach_2 \hspace{.5cm} (\mach_1, \pol_1) \stepstopol \pol_2}
           {\mpstate{\mach_1}{\pol_1} \stepstoobs{\obs}_P \mpstate{\mach_2}{\pol_2}}\]
\leo{Notation: Should $\stepstoobs{}$ be partial?}

\paragraph{Traces}

A trace over some type $A$ is a potentially infinite, nonempty
sequence of $A$s. We will mostly be concerned with sequences of
machines states, usually denoted $\machT$, and with sequences of
triples of (machine states, policy states, and observations), usually
denoted $\MPT$.

We define a few operations on traces generically.
The {\it split} operation \(\mathit{split}(f,T)\) takes a trace \(T\) and a predicate on elements \(f\) and
separates \(T\) into a prefix and suffix at the first element on which \(f\) holds:
  \[\frac{f\ t}
         {\mathit{split}(f,tT) = t, tT}\]
  \[\frac{\neg f\ t \hspace{.5cm} \mathit{split}(f,T) = T_1,T_2}
         {\mathit{split}(f,tT) = tT_1,T_2}\]

The {\it join} operation \(T_1 \cdot T_2\) takes two traces and links them by replacing the last element
of the first (if it has one) with the first of the second:
  \[\frac{}
         {T_1t \cdot T_2 = T_1 T_2}\]

We define the ``trace-of'' operator \(\hookrightarrow\) that coinductively
relates a machine state with the trace of machine states paired with
observations produced by repeated application of step:
\[\machT \in \mathit{MOTrace} = \mathit{Trace}\ (\MACHS \times \OBSS)\]
\[\hookrightarrow : \machT \rightarrow \mathit{MOTrace}\]
%
\[\frac{\mach_0 \stepstoobs{\obs} \mach_1 \hspace{.5cm} \mach_1 \hookrightarrow \machT}
       {\mach_0 \hookrightarrow (\mach_0,\obs) \machT}\]
%
Since the step function is total, if \(\mach \hookrightarrow \machT\),
then \(\machT\) must be infinite.

\sna{Lambdas in the split are a bit busy, not sure anything will look better.}
We will also wish to take a prefix of the trace from an initial state up through the first state where
some condition holds, using {\it split}. Let \(f\) be a predicate on machine states. Then we define
\(\mach \hookrightarrow \machT | f\) (read ``\(\machT'\) is the prefix of \(\machT\) up to \(f\)''):
  \[\frac{\mach \hookrightarrow \machT \hspace{.5cm} \mathit{split}(\lambda (\mach',\obs).f(\mach'),\machT)
            = \machT_1,\machT_2}
         {\mach \hookrightarrow \machT_1 | f}\]

Similarly, we define \(\hookrightarrow_P\) to relate a machine-policy
state pair to the trace of triples of machine states, policy states,
and observations induced by by \(\stepstoobs{}_P\):
%
\leo{I think this would read better as not exists. Thoughts?}
\sna{Looks good.}
  \[\MPT \in \mathit{MPOTrace} = \mathit{Trace}\ (\MACHS \times \POLS \times \OBSS)\]
  \[\hookrightarrow_P : \MACHS \times \POLS \rightarrow \mathit{MPOTrace}\]
  \[\frac{\neg \exists \pol_1 . \pol_0 \rightharpoonup \pol_1}
         {\mpstate{\mach_0}{\pol_0} \hookrightarrow \mpostate{\mach_0}{\pol_0}{\tau}}\]
  \[\frac{\mach_0 \stepstoobs{\obs} \mach_1 \hspace{.5cm} \pol_0 \rightharpoonup \pol_1 \hspace{.5cm}
            \mpstate{\mach_1}{\pol_1} \hookrightarrow \machT}
         {\mpstate{\mach_0}{\pol_0} \hookrightarrow_P \mpostate{\mach_0}{\pol_0}{\obs} \machT}\]

We also lift the prefix-up-to relation to such traces.
  \[\frac{\mpstatename \hookrightarrow \MPT \hspace{.5cm}
            \mathit{split}(\lambda \mpostate{\mach}{\pol}{\obs}.f(\mach),\MPT) = \MPT_1,\MPT_2}
         {\mpstatename \hookrightarrow \MPT_1 | f}\]

Finally, we will use \(\pi_m\) to project the trace of machine states
out of a trace, \(\pi_p\) to project the trace of policy states, and
\(\pi_o\) to project the observations.

%    \COQ{this operation steps until it reaches a state on which \(f\) holds,
%    and is infinite if it doesn't. It doesn't compute the observation of the step after the final,
%    which coq would. So coq may need a ``step until'' relation rather than ``prefix up to''.
%    Still thinking about this.}\leo{So this is strictly weaker than the one we have in Coq, right?
%      So its only the Eager implies Lazy direction that might need tweaking, but not the Test implies Eager one?}
%    \leo{Also, it steps until it reaches an f-state or if the policy raises a fault}

\paragraph*{Observations and Equivalence}

We say that a trace of observations $\obsT_1$ is a prefix of $\obsT_2$
\leo{Benjamin suggested ``as far as an attacker is conerned in an
  e-mail, but we haven't said anything about attackers yet.}, if the
sequence of word-observations of $\obsT_1$ is a prefix of those of
$\obsT_2$, that is we operate up to deletion of \(\tau\) observations, coinductively:

\[\frac{} {\obsT \lesssim \obsT}\]

\[\frac{} {\tau \lesssim \obsT}\]

\[\frac{\obsT_1 = \tau \obsT_1' \hspace{.5cm} \obsT_1' \lesssim \obsT_2}
       {\obsT_1 \lesssim \obsT_2}\]

\[\frac{\obsT_2 = \tau \obsT_2' \hspace{.5cm} \obsT_1 \lesssim \obsT_2'}
       {\obsT_1 \lesssim \obsT_2}\]

\[\frac{\obsT_1 = w \obsT_1' \hspace{.5cm} \obsT_2 = w \obsT_2' \hspace{.5cm} \obsT_1' \lesssim \obsT_2'}
       {\obsT_1 \lesssim \obsT_2}\]

% Fixed by Andrew:
%\COQ{This is the same as the coq version minus a redundant case.}

We then define equivalence of observation traces as traces prefixing each other:
\[O_1 \simeq O_2 \triangleq O_1 \lesssim O_2 \land O_2 \lesssim O_1\]

\leo{Should we point out here the edge cases of all-tau traces?}

% Fixed by Andrew:
%    \COQ{this should be equivalent to the coq version, and we should adopt it.}
%    \leo{We had this, but it was much harder to work with for my proofs. We should still
%      prove them equivalent if we want to present it this way (which is probably cleaner for
%      presentation purposes)}

Let the predicate \(\isinf(T)\) hold when the trace $T$ is infinite.
We then define {\em policy-sensitive observational equivalence}: an
{\it MPOTrace} \(\MPT\) is equivalent to an {\it MOTrace} trace \(\machT\) if \(\MPT\)
is infinite and the observations of \(\MPT\) and \(\machT\) coincide, or if the \(\MPT\)
is finite (due to a policy fault) and its observations are a prefix of those of M.

% Fixed by Sean
%\leo{Why $\mathit{Obs}$ and not $\pi_o$ defined earlier?}
\[\frac{\neg \isinf(\MPT) \hspace{.5cm} \pi_o(\MPT) \lesssim \pi_o(\machT)}
           {\MPT \sim_P \machT}\]

\[\frac{\isinf(\MPT) \hspace{.5cm} \pi_o(\MPT) \simeq \pi_o(\machT)}
           {\MPT \sim_P \machT}\]

\section{Stack Safety, Formally}

In this section we will describe stack safety as a formal
property.
\leo{Should call maps and returns go here or in preliminaries?}

\paragraph*{Program Structure}

  Our properties and policies are parameterized by several types of annotations
  describing features of a program. A {\em code map} identifies some addresses
  as code and assigns each to a function. A {\em call map} identifies addresses
  that complete a call sequence, abstracting away from any concrete calling
  convention. Likewise a {\em return map} identifies addresses that complete a
  return sequence. An {\em entry map} identifies valid entry points to a
  function.

  Formally a code map is a partial function from addresses to a function
  identifier drawn from the set \(\FUNIDS\).
  %
  \[\codemap \in \CODEMAPS = \WORDS \rightharpoonup \FUNIDS\]

  A call map is a partial function from addresses to a natural number,
  the number of arguments of the call.
  %
  \[\callmap \in \CALLMAPS = \WORDS \rightharpoonup \mathbb{N}\]

  For concreteness, in a typical calling convention, a call map may be
  considered to identify the state just before the \(\JAL\), in which
  space for arguments is already allocated, but the mechanism is more
  general. A state in which a call map is defined on the program counter is
  referred to as a {\it call state}.
  
  A return map is simply a predicate on addresses and may be considered to
  identify the final jump of the return sequence. An entry map is likewise a
  predicate on addresses.
  %
  \[\retmap \in \RETMAPS \subseteq \WORDS\]
  \[\entmap \in \ENTMAPS \subseteq \WORDS\]

\paragraph*{State Returns}

  We separately identify, for any call state, what is means for a state to
  have correctly returned from a call. We consider the call to have returned
  the first time control returns to the instruction following the \(\JAL\) with
  the stack restored. Formally this is a relation between the states:
    
  \[\begin{split}
    \ret{\mach_c}\ \mach_r \triangleq & \mach_r(\PCname) =
    \nextPC(\mach_c(\PCname)) \land \\
    & \mach_r(\SP) = \mach_c(\SP)
  \end{split}\]

\leo{How do we initialize the first policy state based on a call map? It's not
  part of the policy. Do we parameterize policies?}

\paragraph*{Stack safety}
  
  A stack safety property is a property of a transition system, a policy, a
  call map and a code map, that is decomposed into an integrity property and a
  confidentiality property.

    \[\begin{split}
      \textit{stack safety} \triangleq \textit{stack integrity} \land
      \textit{stack confidentiality} \\
    \end{split}\]

  \leo{TODO: Rephrase from introduction} Informally, {\it Stack
  integrity} states that if a function call returns, the caller's
  private stack data will be identical to what it was before the
  call. {\it Stack confidentiality} states that data outside a callee's
  stack frame is secret, and do not interfere with its observable
  behavior or with the machine state at return.

  As is standard with security properties, we associate with each
  component of the machine a {\em label}: a pair of security levels
  denoting high or low confidentiality and high or low integrity.
  %
  \[\mathit{label} ::= \{\HIGHSEC,\LOWSEC\} \times \{\HIGHINT,\LOWINT\}\]
  %
  Since we need to enforce integrity and confidentiality at {\em every}
  function call in a trace, we must treat the security level of data
  dynamically. To that end, we introduce the notion of a {\em contour},
  a map from components to labels:
  %
  \[\contour \in \CONTOURS ::= \COMPONENTS \rightarrow \mathit{label}\]

  \leo{What about instructions? Shouldn't they be LC/HI?}
  \sna{Now we are dealing with this!}

  When \(\mach_c\) is a call state \(\callmap(\mach(\PCname)) = n\) for some
  \(n\) and \(\mach_c \stepstoobs{\obs} \mach_e\), we can construct a contour
  based on the bounds of the callee's stack frame. Instructions are low
  confidentiality if they belong to the callee and high confidentiality
  otherwise; regardless they are always high integrity.
 
  The private state of the callee is the entire area of the memory from stack
  base to stack pointer, with the exception of the $n$ locations
  corresponding to the arguments of a call. Private components are marked
  high confidentiality and high integrity: the callee should be able to
  neither read, nor write them.
  
  Everything above the stack pointer at the point of the call is
  ``uninitialized'' memory that can be written into but should not be
  read. To protect the callee itself from such reads, these components
  are marked high confidentiality and low integrity.
 
  Registers and the frame of arguments to the callee are free for the
  callee to use, and are therefore tagged with low integrity and low
  confidentiality. 

 \[\mathit{Cof}(\mach,\funid,n)(\component) =
  \begin{cases}
    (\LOWSEC,\HIGHINT) & \text{if } \component \in \WORDS
                         \text{ and } \codemap(\component) = \codemap(\mach(\PCname)) \\
    (\HIGHSEC,\HIGHINT) & \text{if } \component \in \WORDS
                          \text{ and } \codemap(\component) = \funid \not = \codemap(\mach(\PCname)) \\
    (\HIGHSEC,\HIGHINT) & \text{if } \component \in \WORDS \text{ and } \codemap(\component) = \bot
                          \text{ and } \component \leq \mach(\SP) - n \\
    (\HIGHSEC,\LOWINT) & \text{if } \component \in \WORDS \text{ and } \codemap(\component) = \bot
                         \text{ and } \component \geq \mach(\SP) \\
    (\LOWSEC,\LOWINT) & \text{else} \\
  \end{cases}\]

\definition{Stack Integrity}

  A system satisfies eager stack integrity with respect to a call map
  \(\callmap\) and code map \(\codemap\) if for any initial mpstate
  \(\mpstatename = \mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\) and each
  adjacent pair of a call state \(\mach_c\) and state \(\mach_e\) with policy
  state \(\pol_e\) in the induced trace from \(\mpstatename\), where
  \(\callmap(\mach_c(\PCname)) = n\) and \(\codemap(\mach_e(\PCname)) =
  \funid\), if we take the prefix until a return
  \(\mpstate{\mach_e}{\pol_e} \hookrightarrow_P \MPT | \ret{\mach_c}\) and
  \(\MPT\) ends with some \(\mach_p\), \(\mach_p\) matches \(\mach_c\) on each
  component whose integrity in \(\mathit{Cof}(\mach_c,\funid,n)\) is
  \(\HIGHINT\).

\definition{Stack Confidentiality}

  Confidentiality is in the style of non-interference, comparing the behavior
  of a program with an arbitrary variant that preserves low confidentiality data
  but may have any configuration of high confidentiality data. We define two
  machine states as variants given a contour if they agree on low
  confidentiality data:
  \[\mach \approx_\contour \mach' \triangleq \forall \component .
    \contour(\component) = \LOWSEC \rightarrow \mach(\component) =
    \mach'(\component)\]

  A system satisfies eager stack confidentiality with respect to a call map
  \(\callmap\) and code map \(\codemap\) if for any initial mpstate
  \(\mpstatename = \mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\) and each
  adjacent pair of a call state \(\mach_c\) and state \(\mach_e\) with policy
  state \(\pol_e\) in the induced trace from \(\mpstatename\), where
  \(\callmap(\mach_c(\PCname)) = n\) and \(\codemap(\mach_e(\PCname)) =
  \funid\), one of two cases holds on the induced traces from
  \(\mpstate{\mach_e}{\pol_e}\) and any variation \(\mach_e'\) with respect
  to the contour \(\mathit{Cof}(\mach_c,\funid,n)\).

  If the trace from the call reaches a return -- \(\mpstate{\mach_e}{\pol_e}
  \hookrightarrow_P \MPT | \ret{\mach_c}\) -- then the trace from the variant
  \(\mach_e'\) reaches a return -- \(\mach_e' \hookrightarrow \machT |
  \ret{\mach_c}\). Let \(\mach_r\) and \(\mach_r'\) be the final states of
  \(\pi_m(\MPT)\) and \(\machT\), respectively. Until their final states,
  \(\MPT\) and \(\machT\) must be observationally equivalent, \(\pi_o(\MPT)
  \cdot \tau \eqsim \pi_o(\machT) \cdot \tau\). For any component
  \(\component\) where \(\mach_e(\component) \not = \mach_r(\component)\) or
  \(\mach_e'(\component) \not = \mach_r'(\component)\),
  \(\mach_r\) agrees with \(\mach_r'\) on \(\component\).

  If the trace from the call never reaches a return, neither does the
  trace from the variant. Then if \(\mpstate{\mach_c}{\pol_c} \hookrightarrow_P
  \MPT\) and \(\mach_c' \hookrightarrow \machT\), \(\MPT \sim_P \machT\).

  \leo{Think more about whether we vary mc or step mc}
  \sna{With code, it must be step mc}

\section{Discussion}

  \paragraph{Examples}

  \bcp{Illustrate the definition by using it to discuss a range of ``stack
    unsafety'' examples from the literature. }

  \paragraph{What about tail recursion and other non-stack-like control flow}

  \paragraph{Control Hijacking and Well-bracketed Control Flow}
  
    Some forms of security rely on protected control flow. In a classic
    example, a system call that launches a missile might be gated behind code
    that checks a password. A piece of malicious code might jump into the middle
    of the sequence and execute the system call without the appropriate password,
    and still obey integrity if the malicious code never returns to its caller.
    Integrity here protects data, not privileges. But such a jump does violate
    eager stack confidentiality if the attacker jumps beyond its own function's
    instructions without performing a designated call or returning to an
    appropriate site.

    A jump to a function's own code does not violate either, even if done using
    nefarious means such as return-oriented programming (ROP). Our model would
    permit such a jump within the function, so privilege is not elevated by
    permitting ROP in this case.

    But, our policies do enforce orthogonal control flow properties that
    protect from calls that enter outside of valid entry points and from all
    invalid returns, even if they would not escalate privilege. Most notably
    {\em well-bracketed control flow}, below.

  \paragraph{Adding Heap Safety}

    Discuss how we would do it, referring to Arthur's paper.  Probably not very long or formal?

\section{Lazy Stack Safety}

    \definition{Observable Integrity}

      Observable integrity weakens eager integrity by allowing a returned state
      to differ from its call state at high integrity components, provided the
      observable behavior of the induced trace from the return matches that of
      an idealized state whose high integrity components do match the call
      state.

      Given a contour, a call state, and a returned state, we define a
      ``rollback'' function \(\mathit{roll} : \CONTOURS \times \MACHS \times
      \MACHS \rightarrow \MACHS\). The rollback returns a state that matches
      the call state on those components that are high integrity in its
      contour, and matches the return state on low integrity components:
      \[\mathit{roll}(\contour,\mach_c,\mach_r)(\component) =
      \begin{cases}
        \mach_c(\component) & \contour(\component) = (\HIGHINT,\_) \\
        \mach_r(\component) & \contour(\component) = (\LOWINT,\_) \\
      \end{cases}\]

      Intuitively, the result of a rollback is an idealized state that
      reflects changes to accessible components, but ignores the callee's
      interference with the caller's data. Then the observable behavior of the
      resulting trace is the standard to which we expect the real trace to
      conform.

      A system enjoys observable integrity with regard to \(\callmap\) and 
      \(\codemap\) if for any initial state \(\mach_0\) and each adjacent pair
      of a call state \(\mach_c\) and a state \(\mach_e\) with policy state
      \(\pol_e\) in the trace induced by
      \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\) where
      \(\callmap(\mach_c) = n\) and \(\codemap(\mach_e) = \funid\),
      if \(\mpstate{\mach_e}{\pol_e} \hookrightarrow \MPT | \ret{\mach_c}\)
      with the return state \(\mach_r\) at the end of \(\MPT\), then the
      following holds.

      Let \(\contour = \mathit{Cof}(\mach_c,\funid,n)\) describe the security
      levels of the call and
      \(\mach_r' = \mathit{roll}(\contour,\mach_e,\mach_r)\). The induced
      traces \(\mpstate{\mach_r}{\pol_r} \hookrightarrow \MPT\) and
      \(\mach_r' \hookrightarrow \machT'\) must be equivalent up to
      possible policy failure: \(\MPT \sim_P \machT'\).

    \definition{Observable Confidentiality}

      Observable confidentiality is concerned with whether high confidentiality
      data influences observable both behavior during and after a call. As with
      eager confidentiality, we will compare the behavior of the trace induced
      by a state to another induced by its variant. But if the original returns,
      before continuing, we must reset the variant to conform with the original
      state.

      The \(\mathit{restore}\) function takes a contour and four states: the
      original call state, a variant call state, and corresponding return
      states, and returns another state. The resulting state restores those
      components that are high confidentiality to match the original call,
      unless they were changed during execution:
      \[\mathit{restore}(\contour,\mach_c,\mach_c',\mach_r,\mach_r')(\component) =
        \begin{cases}
          \mach_c(\component) & \text{if } \contour(\component) = (\HIGHSEC,\_) \text{ and } \\
                  & \mach_c(\component) = \mach_r(\component) \text{ and }
                    \mach_c'(\component) = \mach_r'(\component) \\
          \mach_r'(\component) & \text{else} \\
        \end{cases}\]

      A system enjoys observable confidentiality with respect to \(\callmap\)
      and \(\codemap\) if for any initial state \(\mach_0\), each adjacent pair
      of a call state \(\mach_c\) and a state \(\mach_e\) with policy state
      \(\pol_e\) in the inducted trace from
      \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\), and each variant
      \(\mach_e' \approx_\contour \mach_e'\) where
      \(\contour = \mathit{Cof}(\mach_c, \funid, n)\), one of two cases holds
      on the induced traces from \(\mach_e\) and \(\mach_e'\).

      If \(\mpstate{\mach_e}{\pol_e} \hookrightarrow_P \MPT_1 | \ret{\mach_c}\)
      with \(\MPT_1\) the trace within the callee ending with the machine state
      \(\mach_r\), the first state to return to the caller, and policy state
      \(\pol_r\), then the there is a return state \(\mach_r'\) reached by the
      trace from the variant, \(\mach_c' \hookrightarrow \machT_1 |
      \ret{\mach_c}\). Let \(\mach_r'' = \mathit{restore}(\contour,\mach_e,
      \mach_e',\mach_r,\mach_r')\), and let the induced traces from the
      returned states be \(\mpstate{\mach_r}{\pol_r} \hookrightarrow_P \MPT_2\)
      and \(\mach_r'' \hookrightarrow \machT_2\). With the callee and caller
      traces joined, the traces are observationally equivalent up to policy
      failures: \(\MPT_1 \cdot \MPT_2 \sim_P \machT_1 \cdot \machT_2\).

      The case in which the induced trace does not return is the same as in the
      eager property: the variant trace also does not return, and the induced
      traces are observationally equivalent up to policy failure.

    \definition{Observable Stack Safety}

      A system enjoys {\em observable stack safety} with regard to a call map
      and a code map if it enjoys both observable integrity and observable
      confidentiality with regard to them.

\section{Well-bracketed Control Flow}

  Our integrity and confidentiality properties concern themselves with data,
  and may hold on a wide range of programs that violate expected control flow.
  But well-bracketed control flow prevents this style of attack by guaranteeing
  that every jump between functions is either a call or a return, and each
  return jumps to the instruction after a corresponding call.

  \definition{Control Separation}

    A system enjoys {\em control separation} with regard to a code map
    \(\codemap\), a call map \(\callmap\), and a return map \(\retmap\)
    if for any initial state \(\mach_0\) and any adjacent pair of states
    \(\mach_1\) and \(\mach_2\) in the induced trace from
    \(\mpstate{\mach_0}{\pinit(\mach_0)}\), if \(\codemap(\mach_1(\PCname))
    \not = \codemap(\mach_2)\), then either \(\callmap(\mach_1(\PCname)) = n\)
    for some \(n\), or \(\retmap(\mach_1)\).

  \definition{Entry Integrity}

    A system enjoys {\em entry integrity} with regard to a call map
    \(\callmap\) and entry map \(\entmap\) if for any initial state
    \(\mach_0\) and any adjacent pair of states \(\mach_c\) and \(\mach_e\)
    in the induced trace from \(\mpstate{\mach_0}{\pinit(\mach_0)}\), if
    \(\callmap(\mach_c(\PCname)) = n\) then \(\entmap(\mach_e)\).

  \definition{Well-bracketed Control Flow}

    Well-bracketed control flow captures the expected behavior of marked
    returns with regard to their call points. The coinductive {\em bracketing}
    predicate, \(\mathit{BR}(\machT)\), is parameterized by a call map
    \(\callmap\) and a return map \(\retmap\):

    \[\frac{\mathit{BR}(\machT) \hspace{.5cm} \callmap(\mach_c(\PCname)) = n
              \hspace{.5cm} \retmap(\mach_c(\PCname))}
           {\mathit{BR}(\mach_c \machT \mach_r)}\]
    
    \[\frac{\mathit{BR}(\machT) \hspace{.5cm} \callmap(\mach(\PCname)) = \bot}
           {\mathit{BR}(\mach \machT)}\]

    A system enjoys {\em well-bracketed control flow} with regard to a call map
    \(\callmap\) and return map \(\retmap\) if for any initial state
    \(\mach_0\) and any call state and policy state \(\mach_c\) and \(\pol_c\)
    in the induced trace from \(\mpstate{\mach_0}{\pinit(\mach_0)}\), if
    \(\mpstate{\mach_c}{\pol_c} \hookrightarrow_P \MPT \mpostate{\mach'}
    {\pol'}{\obs'} ...\) and \(\MPT\) is bracketed with regard to \(\callmap\)
    and \(\retmap\), then \(\ret{\mach_c,\mach'}\).

  \definition{Standard Stack Control Flow}

    The above properties are somewhat orthogonal, but together they capture a
    standard notion of control flow for a stack: functions keep their code
    separate outside of calls and returns, calls respect explicit entry points,
    and returns respect implicit entry points corresponding to their call.
    A system that enjoys them with regard to a code, a call, a return, and an
    entry map is said to enjoy {\em standard stack control flow} with regard to
    those maps.

\section{Related Work}
\label{sec:relwork}

\section{Future Work}
\label{sec:future}

We've assumed that callees always have less access than their callers, but
in real systems things are more complicated (because of objects, static
variables in C, software compartmentalization, coroutines, ...).  What we've
defined is a very ``pure'' variant of stack safety.  In future work, we
should go further. :-)


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
%\bibliography{bibfile}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
