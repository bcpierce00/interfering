\documentclass[conference]{IEEEtran}
\input{macros}

\begin{document}

\title{Interfering with Noninterference
\iftext\thanks{\bcp{Identify applicable funding agencies here (DARPA and NSF
    and...?)}}\fi
}

% I get a weird error, so I commented this out for now
%\iftext
%\IEEEauthorblockN{Leonidas Lampropoulos}
%\IEEEauthorblockA{\textit{University of Maryland}}
%% \textit{name of organization (of Aff.)}\\
%% City, Country \\
%% email address or ORCID
%\and
%\author{\IEEEauthorblockN{Roberto Blanco}
%\IEEEauthorblockA{\textit{\bcp{affiliation?}}
%% \textit{name of organization (of Aff.)}\\
%% City, Country \\
%% email address or ORCID
%}
%\and
%\IEEEauthorblockN{Benjamin C. Pierce}
%\IEEEauthorblockA{\textit{University of Pennsylvania}
%% \textit{name of organization (of Aff.)}\\
%% City, Country \\
%% email address or ORCID
%  }
%\and
%\IEEEauthorblockN{Andrew Tolmach}
%\IEEEauthorblockA{\textit{Portland State University}
%% \textit{name of organization (of Aff.)}\\
%% City, Country \\
%% email address or ORCID
%}
%}
%\fi

\maketitle

\iftext
\begin{abstract}
\end{abstract}

\begin{IEEEkeywords}
% component, formatting, style, styling, insert
\end{IEEEkeywords}
\fi

\iftext
\section{Introduction}

\begin{itemize}
\item \leo{Not even sure this is true anymore}
\item Noninterference is a security property combining {\em
  confidentiality} and {\em integrity}: secret data should influence
  public outputs and low integrity data should \leo{finish in a pretty
    way}.
\item In this paper we present a stack safety property as a variation
  of noninterference.
\end{itemize}

{\em Hyperproperties}, i.e. properties of pairs\leo{sets?} of
execution traces\footnote{\bcp{I'm not certain we're using the word
    correctly.  E.g., ``A hyperproperty is a set of properties [Clarkson and
    Schneider 2008, 2010]''} \bcp{After more reading, I am still wondering
    if we're using the word the right way.  I think we mean something much
    less general---just a relation on traces.  So I think we should just say
    ``contoured relation'' (and maybe ``lockstep relation'').}}, are the
standard way of expressing security
properties\cn. In particular, {\em noninterference} is commonly
phrased as such a property: given two system states that seem
identical to an observer with low clearance, their execution traces
should also be indistinguishable\cn.

In this paper we focus on a well-behaved closed\bcp{???} subset of
hyperproperties, where the execution traces remain in {\em lockstep}:
the traces execute identical sequences of instructions.
%
This allows us to give a clean extensional characterization of taint
tracking as a noninterference property: intuitively, taint tracking is
a weak lockstep-hyperproperty that guarantees noninterference as long
as the execution traces remain in sync, but then allows for arbitrary
behavior after branching on a secret.
%
We also describe a strong version of lockstep hyperproperties, where
the security policy enforces the lockstepness. \leo{Something about
  full separation}
%
Finally, we generalize strong lockstep hyperproperties to allow for
\leo{what's the correct adjective here? principled? nested?
  restricted?}  changes to the observer clearance, and use this
generalization to characterize a novel stack safety property as
a variation of noninterference.

As it happens, lockstep hyperproperties are also significantly more
amenable to testing compared to traditional hyperproperties. Since
executions remain in lockstep, there is no possibility of \leo{missing
  bugs by never coming back down or a need to find an invariant strong
  enough to prove things}. We have implemented enforcement mechanisms
for all three policies for RISC-V and tested them.

Our contributions are:
\begin{itemize}
\item We present a mathematical abstraction of a class of properties
  called {\em lockstep hyperproperties}, that allow for intuitive
  characterizations of interesting security policies.
\item We give a novel {\em extensional} characterization of taint tracking
  as a form of lockstep-noninterference.
\item We introduce a novel stack safety property that allows for
  the notion of observability to change dynamically throughout
  execution.
\item We develop a testing framework for testing such
  lockstep-hyperproperties, implemented as a parametric co-processor
  for RISC-V.
\end{itemize}

\fi

\section{Preliminaries}

\subsection{Machine model}

Concretely, we have in mind a conventional machine architecture with a
standard (RISC-V) processor extended with some kind of (static or dynamic,
software- or hardware-enforced) security monitor, but we won't need to make
any specific choices about details until we get to \bcp{the implementation
  section}.
% \cref{impl}.

Conventions:
%
\begin{itemize}
\item Words / addresses: $\word,\addr \in \WORDS$
\item Registers: $\reg \in \REGS$
\item Machine components: $\component \in \WORDS \cup \REGS \cup \{
\textsc{pc} \}$
\item Machine states: $\mach \in \MACHS = \COMPONENTS\rightarrow\WORDS$
\end{itemize}

% \bcp{Now we need to define {\em property} formally.  But since we're talking
% about hyperproperties, I'm not certain how to go about it.  The standard way
% would be something like ``A policy $P$ has property $Q$ (i.e., $P$ is
% noninterfering) if, for every pair of traces $\trace{M}$ and $\trace{M'}$
% in $P \times P$, if the initial states $M_0$ and $M'_0$ differ only in
% high parts then every pair ...'' (blah: I'm not sure whether to talk about
% lockstep-corresponding states, which seems too restrictive, or final states,
% which doesn't work if the traces are infinite!  do we really need some kind
% of reactive noninterference here?? Urg.)  (Well, no, we can just do
% a flavor of termination-insensitive NI, which says that all infinite traces
% are indistinguishable from anything...?)}

% \bcp{Should we start from a notion of ``variant traces'' and then talk about
% pairs of variant traces being ``distinguishable'' and then go to the full
% thing?}

The {\em underlying} step function, $\mathord{\stepstounderfull} \in
\MACHS \rightarrow \MACHS$, embodies the standard RISC-V ISA
semantics.
%\bcp{It's probably clearer not to put RISCV in the
%  notation---for most of the paper, the fact that it's a RISCV really
%  doesn't matter.  Moreover, I think we want to make it a partial
%  function, for simplicity of definitions in this part, and if we
%  insist on RISCV here this will confuse people that know it doesn't
%  have a HALT instruction.}

A {\em trace} is a finite or infinite sequence of machine states,
$\seq{\mach} = \mach_0,\, \mach_1,\ldots$, in which adjacent machine
states are related by $\stepstounderfull$---i.e., in which
$\mach_{i-1} \stepstounderfull \mach_i$ for each $i > 0$ in the
sequence. We write $\seq{\mach}^i_j$ for the subtrace between $i$ and
$j$.

\subsection{Calling Convention}

\leo{Mainly @Andrew, check if this makes sense for the eager setting.}

We adopt the following calling convention:
\begin{itemize}
\item First the caller increases the stack pointer to allocate stack space
  for arguments and result and zeroes out anything not written.
\item Then a $\JAL$ happens.
\item Then the entry sequence of the callee follows which increases
  the stack pointer again to allocate as much local space as needed
  (e.g. for the return address), and it is all zeroed out if not
  explicitly written. \leo{This can be lifted by dealing with
    stack allocation in the contours}
\end{itemize}  

A {\em call map} is a map from a sequence of instructions (read: {\em
  a call sequence}) to a natural number (the number of arguments and
results of the call plus the size of the local state of the callee,
which corresponds to stack locations that will be made available to
the callee).

\subsection{Contours}

A {\em contour} $\contour \in \CONTOURS = \COMPONENTS \rightarrow
\{\HIGHSEC, \LOWSEC\} \times \{\HIGHINT, \LOWINT\}$ is a map from
machine components to a pair of confidentiality and integrity labels.
$\LOWSEC$ marks locations whose contents represent data observable
{\em by the current process}; $\HIGHSEC$ corresponds to non-observable
data (e.g. local state of the process caller). $\HIGHINT$ marks
locations that the current process does not have write access to;
$\LOWINT$ is writeable. As examples of different
combinations consider the following:
\begin{itemize}
\item Locations that belong to the current process such as
  available registers, local stack, memory accessible through
  available pointers will be tagged $\LOWSEC \times \LOWINT$:
  they can be both read and written.
\item The local state of the caller that needs to be protected from a
  potentially untrusted callee will be marked $\HIGHSEC \times
  \HIGHINT$. The callee should be able to neither read nor write
  these locations.
\item The instruction memory is read only for every process: $\LOWSEC
  \times \HIGHINT$.
\item Uninitialized memory can be written, but never read. This is only
  applicable in a more lazy setting where we don't zero out memory.
\end{itemize}

\subsection{Identity colorings}
\leo{Feel free to coin another name}

\leo{Went with S for ``self'' and O for ``other''. M/NM was confusing
  with the machine states also being M. T/F didn't really work
  with transitions. Open to other suggestions.}
An {\em identity coloring} of a trace $\seq{\mach}$ is an equal-length
sequence $\seq{\ID}$ of ids ($\IDS = \{\ME, \NOTME, \TRANS\}$, where
$\ID_j = \ME$ if the machine state $\mach_j$ is executing the same
process as $\mach_0$, $ID_j = \NOTME$ if it is executing a different
process, and $ID_j = \TRANS$ during a transition (e.g. during a call
or return sequence).

Given a machine trace $\seq{\mach}$ and a call map the identity coloring can be
computed by iterating through the trace:
\begin{enumerate}
\item Start by coloring $\mach_0$ as $\ME$.
\item Color every subsequent state as $\ME$, until the first machine
  state (if any) at which the instruction executed is a
  the beginning of a call sequence.
\item Color the entire call sequence $\TRANS$. This necessarily
  contains a machine state $\mach_c$ which is a $\JAL$.
\item Color every subsequent state as $\NOTME$, until the first state
  $\mach_r$ after $\mach_c$ in the trace (if any) such that the pc of
  $\PC{\mach_r}$ is equal to $\PC{\mach_c} + 4$, and whose stack
  pointer is identical to that of $\mach_c$. Then mark $\mach_r$ as
  $\ME$ and go to step (2).
\end{enumerate}

\subsection{Contoured Trace}

Given a contour $C$ and a machine state $M$, the {\em contoured trace}
induced by $C$ and $M$, written $\induced{C}{M}$, is the (finite or
infinite) sequence of pairs of (contour, machine state) pairs in which
states in adjacent pairs are related by $\stepstounderfull$, and in which
contours in adjacent pairs are constructed as follows:
\begin{itemize}
\item If in the identity coloring of $\seq{\mach}$ the identity of
  consecutive states is preserved ($\ID_i$ = $\ID_{i+1}$) then
  $C_{i+1} = C_i$.
\item If $\ID_{i} = \ME$ and $\ID_{i+1} = \TRANS$, then $C_{i+1}$ is
  constructed from $C_i$ by setting the local state of $\mach_i$ (the
  caller) to $\HIGHSEC \times \HIGHINT$. The local state is comprised
  of everything below the stack pointer at $\mach_i$.
\item If $\ID_{i} = \TRANS$ and $\ID_{i+1} = \NOTME$, then $C_{i+1}$ is
  constructed from $C_i$ by making the top $n$ locations in the stack,
  where $n$ is the mapping of the transition call sequence in the call map,
  readable and writeable $\LOWSEC \times \LOWINT$.
\item If $\ID_{i} = \TRANS$ \apt {$\NOTME$ ? } and $\ID_{i+1} = \ME$, then $C_{i+1}$ is
  constructed from $C_i$ by setting the local state of the caller
  to $\LOWSEC \times \LOWINT$, and making everything above the stack
  pointer $\HIGHSEC \times \HIGHINT$ again.
\end{itemize}

\subsection{Integrity}

A trace $\seq{\mach}$ satisfies the {\em integrity} safety property
with respect to a contour $\contour$, if for all components
$\component$ where $\contour(\component) = (\_, \HIGHINT)$,
$\mach_i(\component) = \mach_0(\component)$ for all $i$ in the trace.

\leo{For confidentiality we need observations first}

\subsection{Observations}

A {\em component observation} is either a word or the special value
$\bot$.  \leo{Fix notation, clashes with $\LOWINT$}  A {\em state
  observation} is a map from machine components to component
observations.

An {\em observation} is a nonempty, finite or infinite sequence of state
observations in which (1) adjacent elements are always distinct (``no
stuttering'') and (2) any component $\component$ that is mapped to $\bot$ by
the the $j^{th}$ state observation in the sequence must also be mapped to
$\bot$ by all observations earlier than $j$ in the sequence (i.e., once a
component's value changes from $\bot$ to anything else, it never changes
back to $\bot$ again).

In particular, the observation $\obstrace(\contour, \seq{\mach})$
arising from a contoured trace $\seq{(\contour, \mach)}$
is sequence of state observations $\stateobs_0,\, \stateobs_1,\,
\ldots$ defined informally as follows:
\begin{itemize}
\item $\stateobs_0$ maps every visible component $\component$ (where
  $\contour_0(\component) \in \{\LOWSEC \times \_\}$) to its value in
  $\mach_0$ and every hidden component to $\bot$;
\item $\stateobs_{i+1}$ is defined from $\stateobs_{i}$ by (1) for
  each visible component $\component$ (where
  $\contour_{i+1}(\component) \in \{\LOWSEC \times \_ \}$) its value
  from $\mach_{i+1}$, and (2) for each hidden component $\component$,
  where $\contour_{i+1} (\component) = \{\HIGHSEC \times \_\}$,
  copying its value from $\stateobs_{i}$, and (3) if the resulting
  $\stateobs_{i+1}$ is identical to $\stateobs_{i}$, then skipping
  $\stateobs_{i+1}$.  \iftext\bcp{Too informal!!}\fi
\end{itemize}
\iftext\bcp{Emphasize that ``observability is not observable.''}\fi

\subsection{Confidentiality}

Given a machine state $\mach$ and a contour $\contour$, a {\em
  variant} of $\mach$ with respect to $\contour$ is any machine state
$\mach'$ whose components agree with $\mach$ on all components marked
$(\LOWSEC, \_)$ by $\contour$---i.e., if $\contour(\component) =
(\LOWSEC, \_)$, then $\mach(\component) = \mach'(\component)$.

A pair of traces $\seq{M}$ and $\seq{N}$ satisfy the {\em
  confidentiality} safety hyperproperty with respect to a contour
$\contour$, if, if the initials states are variants of each other $N_0
\in \variant{C}{M_0}$, then the observations of one is a prefix of the
observations of the other: $\obstrace(\seq{\contour, \mach}) \subseteq
\obstrace(\seq{\contour, N})$.

\apt{Does this differ from lockstep equivalence? And why prefix?}

\subsection{Stack Safety}

A trace $\seq{\mach}$ satisfies {\em stack safety} with respect to a
contour $\contour$ if:
\begin{itemize}
\item $\seq{\mach}$ satisfies integrity with respect to $\contour$.
\item For every variant $N \in \variant{C}{\mach_0}$, $\seq{\mach}$
  and the the induced trace $\seq{N}$ satisfy confidentiality with
  respect to $\contour$.
\item Every subtrace $\seq{\mach}^r_c$ colored $\NOTME$ in the
  identity coloring of $\seq{\mach}$ satisfies stack safety with
  respect to the contour $\contour_c$.
\end{itemize}

\bcp{Needs to be formulated coinductively?!}

\bcp{What about unitialized memory (written by previous calls)}

\section{Related work}

\bcp{Make sure to mention that we are NOT enforcing well-bracketed control
  flow a la Birkedal et al!}

\section{Future Work}

Is there a knowledge-based presentation of all this?

\cleardoublepage
\leo{OLD STUFF BEGINS HERE}

\subsection{Contours}

\iftext
Intuitively, we use the word {\em policy} for any kind of dynamic
enforcement mechanism (e.g., a runtime taint tracker, heap coloring rules,
capability hardware, etc.).
We use {\em property} for a mathematical
condition on programs (i.e., machine states) articulating some useful
security goal, e.g. noninterference.
\fi

A {\em contour} $\contour \in \CONTOURS = \COMPONENTS \rightarrow \{\ACCYES,
\ACCNO, \ACCCODE\}$ is a map from machine components to accessibility levels.
$\ACCYES$ marks locations whose contents represent data observable from the
outside (by the ``attacker,'' e.g., by DMA), which moreover correspond to
low-integrity components (e.g., locations that can be written to \iftext
\bcp{directly or indirectly} \fi by the network). $\ACCNO$ marks internal
``hidden'' state that cannot be observed directly (e.g., processor registers and
memory addresses for temporary variables will usually be hidden), which is
moreover high-integrity (i.e., locations which should be protected from flows
from the network)
%
\rb{Tried to merge discussion on integrity and secrecy, but maybe it is clearer
  to separate both concerns?}
%
In addition to those two accessibility levels, $\ACCCODE$ marks locations that
hold executable instructions, which are considered to be low-secrecy (i.e.,
observable by the attacker) and high-integrity (i.e., the attacker cannot write
to them).

\rb{OLD:
\leo{We might need to change the intuition behind some of these things.}
A {\em contour} $\contour \in \CONTOURS = \COMPONENTS \rightarrow
\{\HIGHSEC,\LOWSEC\} \times \{\HIGHINT, \LOWINT\}$\bcp{We need more mnemonic names for
  these (that help us keep straight when we're talking about confidentiality
  and when integrity) in the way they are displayed.}
is a map from machine components
to confidentiality and integrity levels. $\LOWSEC$ marks locations whose
contents are observable from the outside (by the ``attacker,'' e.g.,
by DMA) and $\HIGHSEC$ marks internal ``hidden'' state that cannot be
observed directly (e.g., processor registers and memory addresses for
temporary variables will usually be hidden). Similarly, $\LOWINT$
locations correspond to low-integrity components (e.g. locations that
can be written to \iftext \bcp{directly or indirectly} \fi by the network), while $\HIGHINT$ locations should be
protected from such flows.
}

\rb{The flows-to relation was quite nice before, now it looks like it will get
  messier\ldots}
%
We denote this (reflexive) flows-to relation with $\flows$. Then
$\LOWSEC \flowsstrict \HIGHSEC$ and $\HIGHINT \flowsstrict
\LOWINT$. We can easily lift this relation to pairs of secrecy and
integrity labels, and from there to contours pointwise.

\subsection{Observations}

\rb{We are not using observations at the moment, but a few adjustments are made
  here.}

A {\em component observation} is either a word or the special value $\bot$.
A {\em state observation} is a map from machine components to component
observations.

An {\em observation} is a nonempty, finite or infinite sequence of state
observations in which (1) adjacent elements are always distinct (``no
stuttering'') and (2) any component $\component$ that is mapped to $\bot$ by
the the $j^{th}$ state observation in the sequence must also be mapped to
$\bot$ by all observations earlier than $j$ in the sequence (i.e., once a
component's value changes from $\bot$ to anything else, it never changes
back to $\bot$ again).

In particular, the observation $\obstrace(\contour, \seq{\mach})$
arising from a pair of a contour $\contour$ and a trace $\seq{\mach}$
is sequence of state observations $\stateobs_0,\, \stateobs_1,\,
\ldots$ defined informally as follows:
\begin{itemize}
\item $\stateobs_0$ maps every visible component $\component$ (where
  $\contour(\component) \in \{\ACCYES, \ACCCODE\}$) to its value in $\mach_0$
  and every hidden component to $\bot$;
\item $\stateobs_{i+1}$ is defined from $\stateobs_{i}$ by (1) for
  each visible component $\component$ (where $\contour(\component) \in
  \{\ACCYES, \ACCCODE\}$), copying its value from $\mach_{i+1}$, and (2) for
  each hidden component $\component$, where $\contour (\component) =
  \ACCNO$, copying its value from $\stateobs_{i}$, and (3) if
  the resulting $\stateobs_{i+1}$ is identical to $\stateobs_{i}$,
  then skipping $\stateobs_{i+1}$.  \iftext\bcp{Too informal!!}\fi
\end{itemize}

% For each component $\component$,
% %
% if
% $\contour_i(\component) = (\underscore,\HID)$ for all $i$, then
% $\obstrace(\component) = [\,]$;
% %
% otherwise, $\obstrace(\component)$ is a sequence whose first element
% is $\mach_i(\component)$ for the smallest $i$ such that
% $\contour_i(\component) = (\underscore,\VIS)$ and whose $(m+1)^{th}$ element
% (if any) is $\mach_j(\component)$, where $j$ is the smallest index greater
% than the index $i$ of the $m^{th}$ element and such that
% $\contour_j(\component) = (\underscore,\VIS)$ and
% $\mach_j(\component) \neq \mach_i(\component)$.
% %
% \bcp{Can be defined more simply}
% \iftext
% \bcp{Unfinished and horrible...  But maybe the textual description is OK?}
% \newcommand{\aux}{\mathit{aux}}
% \bcp{Don't like the ``rest'' argument and the fact that we don't
%   have a metavariable for sequences of (contour, machine state) pairs.
%   Consider defining one.}
% %
% \[
% \begin{array}{lcl}
% \aux \; ( [\,] ) \; \trace& = & \trace
% \\
% \aux \; ( (\contour,\mach) \mathrel{::} \mathit{rest} ) \; T
%   & = &
%         \aux \;( \mathit{rest} )
%         \\ && \quad (\lambda k.\; \mbox{\bcp{and so on}}
% \\
% \\
% \obstrace \;( (\contour_0,\mach_0),\, \ldots )
%   &=& \aux \; ( (\contour_0,\mach_0),\, \ldots ) \; (\lambda
%       \component.\, \bot)
% \end{array}
% \]
% \fi

% \bcp{Maybe make it a sequence of maps from components to values?  This is
%   simpler, but it means we can ``observe the observbility of locations...''
%   But is this too unrealistic?}

\iftext\bcp{Emphasize that ``observability is not observable.''}\fi

\subsection{Properties}

% A {\em contoured (hyper)property} is a function that takes a contour to a
% hyperproperty.  That is, it takes a starting contour and produces a
% \bcp{prefix-closed?} set of pairs of sequences of machine states.
%
% An {\em observer} $\observer \in CONTOURS \rightarrow (\MA \exists X.\; (\CONTOURS \rightarrow X) \times
% (X \rightarrow \CONTOURS) \times (\MACHS \times X \rightharpoonup \MACHS
% \times X) $
% comprises
% \begin{enumerate*}
%   \item a private type $X$,
%   \item a function taking a contour to an initial value of $X$, and
%   \item a function that allows ``reading off'' a contour from an $X$, and
%   \item a partial step function of type
%   $(\MACHS \times X) \rightharpoonup X$.
% \end{enumerate*}

Let $(\stepplus) :: (\CONTOURS \times \MACHS) \rightarrow (\CONTOURS
\times \MACHS)$ be an extension of the underlying step function, such
that $(C,M) \stepplus (C',M')$ implies that $M \stepstounderfull M'$.
Given a contour $C$ and a machine state $M$, the {\em contoured trace}
induced by $C$ and $M$, written $\induced{C}{M}$ is the largest
(finite or infinite) sequence of pairs of (contour, machine state)
pairs, in which adjacent pairs are related by $\stepstounderfull$ and
for which $C \flows C_i$ for all $i > 0$ in the sequence.
\leo{That is, the induced contoured trace by a (C,M) pair incorporates
  the ``return'' snipping}

Given a machine state $\mach$ and a contour $\contour$, a {\em
  variant} of $\mach$ with respect to $\contour$ is any machine state
$\mach'$ whose components agree with $\mach$ on all components marked
$\ACCYES$ or $\ACCCODE$ by $\contour$---i.e., if $\contour(\component) \in \{\ACCYES, \ACCCODE\}$, then
$\mach(\component) = \mach'(\component)$.
%
\rb{When we talk about observations, it is visibility that we are concerned with
  and moving from $\HIGHSEC$ to $\ACCNO$ and $\LOWSEC$ to $\ACCYES$ and
  $\ACCCODE$ is simple. Here, the case of code is slightly more
  interesting (are $\ACCCODE$-variants ever useful?).}

Let $\initmach$ be the set of initial states of the machine and let
$\initcontour(M)$ be the\bcp{an?} initial contour assigned to each $M \in
\initmach$. \iftext\leo{This could probably be generalized to a set}\fi

For each $M \in \initmach$ and $C = \initcontour(M)$, we define the
{\em closure} of $(C,M)$ as the set of triples of (contour, trace,
trace) as follows:
\[
\begin{array}{rcl}
  \closure{(C,M)} = \{ ( C_i, \seq{N}, \seq{N'})
  & | & C_{i-1} \not = C_i \\
  & , & \seq{(C_i, M_i)} = \induced{C}{M}\\
  & , & \seq{(\_, N_j)} = \induced{C_i}{M_i}\\
  & , & N'_0 \in \variant{C_i}{M_i}\\
  & , & \seq{(\_, N'_j)} = \induced{C_i}{N_0'} \}\\
\end{array}
\]
\leo{Alternative: We could do this for all $i$, but lose the
  trivial instantiation of noninterference later on}
\bcp{Don't follow the notation here.  :-(}

A trace $\seq{M}$ satisfies the {\em integrity} safety property with
respect to a contour $\contour$, if for all components $\component$
where $\contour(\component) = (\_, \HIGHINT)$, $M_i(K) = M_0(K)$ for
all $i$ in the trace.
%
\rb{Here, $\HIGHINT$ would be replaced by $\in \{\ACCNO, \ACCCODE\}$.}

A pair of traces $\seq{M}$ and $\seq{N}$ satisfy the {\em
  confidentiality} safety hyperproperty with respect to a contour
$\contour$, if, if the initials states are variants $N_0 \in
\variant{C}{M_0}$, then their observations coincide:
$\obstrace(\contour, \seq{M}) = \obstrace(\contour, \seq{N})$.
\leo{Should we cut at minimum length for termination-insensitiveness?}
\bcp{Or just ask that one be a prefix of the other?}
\bcp{Or go back to halting states.  (Which I guess really means go back to
  Halting + Failing states.  We never quite worked out how that would go.)}

\leo{From now on I need better terminology, but hopefully you get the
  point} An initial machine state \leo{or contour machine state pair}
is \leo{good} if for every triple $(C, \seq{N}, \seq{N'})$ in
$\closure{(\initcontour(M),M)}$ we have:
\begin{itemize}
\item The traces $\seq{N}$ and $\seq{N'}$ satisfy confidentiality
  with respect to $C$.
\item The traces $\seq{N}$ and $\seq{N'}$ each satisfy integrity
  with respect to $C$.
\end{itemize}

\leo{Combined result}
Noninterference holds for the set of \leo{good} initial machine
states.

\leo{NOTE:
  \begin{itemize}
    \item When the contours don't change this is trivially
      noninterference: only a variation of the initial state is
      added to the trace.
    \item This almost directly coincides with the LSE part
      of the stack-safety property.
  \end{itemize}
}

%A {\em contoured hyperproperty} is a set of triples,
%each consisting of a contour along with a pair of traces.
%
%\leo{No longer needed:?}
%A {\em contoured lockstep-hyperproperty} is a contoured hyperproperty
%such that each trace in every pair of traces in the set executes the
%same instruction sequence.
%
%Finally, we can parameterize the traces by some initial application-specific
%state to obtain a {\em contoured lockstep $X$-hyperproperty}, where every
%trace comes with more information, for example call sites in stack safety.
%\bcp{If we use this later, we need to say it more formally to be clear about
%  what we mean---e.g., I had thought both the traces and the contour would
%  be functions of $X$!}

\rb{New try. Contours are as above.}

A {\em call/return map} $\kappa \in \WORDS \rightarrow \{\CRCALL, \CRRET,
\CRBOT\}$ is a map from addresses to tags (not to be confused with tags at the
micropolicy level \rb{reference if needed}) that denote whether a memory
location is to be treated as (the first word of) a call instruction, a return
instruction, or neither \rb{(and we should compare these with call and return
machine instructions ``proper'')}.

The {\em step relation} $(\stepkappa) :: \MACHS \rightharpoonup \MACHS$ is a
partial function from machine states to machine states: a restriction of the
native machine's step relation $\stepstounderfull$ indexed by a call/return
map $\kappa$, such that \rb{(How much to build into this, and/or the machine
states themselves? Also describe and notate the concept of ``running until
the first unmatched return (cf. observable halting states)'') \ldots}

Given a machine state $\mach$ and associated contour $\contour$, an
$\ACCNO$-variant is any state $\mach'$ that varies machine components tagged as
$\ACCNO$ in $\mach$: that is, for any component $\component$ of $\mach$, if
$\contour(\component) \neq \ACCNO$, then
$\mach(\component) = \mach'(\component)$; otherwise (if
$\contour(\component) = \ACCNO$), then $\mach'(\component)$ holds an
arbitrary value, unrelated to $\mach(\component)$. Similarly, $\ACCYES$-variant
states are defined by scrambling those machine components tagged as $\ACCYES$
and leaving all others unchanged.

A machine state $\mach$ is {\em safe} with respect to a contour $\contour$
\rb{and call/return map $\kappa$} if it satisfies the following conditions:
%
\begin{enumerate}

\item {\em Integrity:} if we run $\mach$ until its first unmatched return (if
  any), all components other than those marked as accessible must remain
  unchanged with respect to $\mach$. \rb{That is, the final state is an
  $\ACCYES$-variant of $\mach$.}

\item {\em Confidentiality:} for every $\ACCNO$-variant $\mach'$ of $\mach$, if
  we run $\mach$ and $\mach'$ until their first unmatched returns, the resulting
  final states are themselves $\ACCNO$-variant of one another. \rb{(Homogenize
  notations, see also above.)}

\item Let $\mach_1, \mach_2, \ldots$ be a machine execution starting from
  $\mach$, i.e., $\mach_1 = \mach$. Let also $\contour_1, \contour_2, \ldots$
  be the corresponding sequence of contours, such that $\contour_1 = \contour$
  and at each step $\mach_i$ the corresponding $\contour_i$ \rb{\ldots better
  define the contour-updating step in the style of $\stepplus$.} For all $i$,
  if $M_i$ is a top-level call in the trace, then (the instruction immediately
  after) it \rb{$\mach_{i+1}$?} is safe with respect to $C_i$.

\item All instructions executed throughout any run starting from $\mach$ are
  marked as such in the contour $\contour$. \rb{Need notation to dereference the
  PC and have the memory be marked as $\ACCCODE$:
  $\contour_i(\PC{\mach_i}) = \ACCCODE$ (or noting invariance in $\ACCCODE$
  parts of $\contour$).}

\end{enumerate}

The step relation $\stepkappa$ is itself safe if every machine state $\mach$ is
safe with respect to the special contour where all memory locations containing
code are marked $\ACCCODE$ and all other components are marked $\ACCYES$.

\subsection{Noninterference}

\iftext
\leo{Indistinguishability/variations:}

\leo{Baseline noninterference:}

\leo{Is this noninterference or is it noninterference + integrity.
  I'm confused about terminology}
\fi

Our baseline security property is noninterference.
\begin{itemize}
\item {\em Confidentiality:}

  For each triple $(\contour, \overline{M}_n, \overline{M'}_{n'})$, if
  the initial elements of the traces are variants, then the final
  states of the traces are also variants.  \bcp{What does ``final''mean for
    infinite traces?  What about pairs where one is finite and the other
    infinite?}

\item {\em Integrity: }

  For each triple $(\contour, \overline{M}_n, \overline{M'}_{n'})$,
  and for every high-integrity component $\component$ for which
  $\contour(\component) = \HIGHINT$, $M_0(\component) = M_n(\component)$
  and $M'_0(\component) = M'_{n'}(\component)$.
\end{itemize}

\iftext
\leo{In the terminology of the original hyperproperty paper,
  confidentiality is a hyperproperty, integrity is a trace property
  that holds for every trace in a hyperproperty. This is a stronger
  version of integrity than DLM for example}.
\fi
%
%\leo{Nested lockstep noninterference:}
%
%Lockstep-Noninterference is a restricted form of traditional
%noninterference, that is nevertheless useful (e.g. to encode taint
%tracking in Section~\leo{Blah}) and easy to test (\leo{More blah}).
%At the same time, lockstepness makes it possible to generalize the
%setting and allow for the contours themselves to change throughout the
%execution.

%Generalizing to allow for contours to change throughout the execution,
%nested lockstep noninterference is the contoured lockstep hyperproperty
%where: \bcp{Which parts of this are common to {\em all} contoured lockstep
%  hyperproperties (i.e., which should be part of the definition of contoured
%  lockstep hyperproperties) and which are specific to (nested) NI?}
%\leo{I'd say contoured lockstep hyperproperties are as above - and the following are
%  the generalization for nested ones.}

\section{Separation is noninterference$+$}

\leo{To warm up, a super simple separation policy.}
\begin{itemize}
\item Any instruction can serve as a final instruction.  \bcp{My picture
  here was that, for this property, the $X$ parameter would be, say, the
  address where the machine is considered to halt. (I guess the picture is
  that we attach probes to the PC and to the rest of memory, and we read out
  the memory when the PC reaches this address.  But when I write it down
  that way it seems pretty awkward.  Maybe we should just assume that the
  machine has a HALT instruction or some other way of signaling that it is
  done---i.e., abstractly, simply take the step function as a partial
  function.  We will need to put a footnote somewhere acknowledging that
  this may be a bit of an abstraction from real modern processors, but the
  simple separation policy is an abstraction anyway!)}

\leo{What about
  instructions the are halted by the monitor?}  \bcp{Not sure what the
  question is here, but note that an instruction halted by the monitor will
  not appear in the trace.}
\item For forward compatibility we could treat the first unmatched return as
  a halt instruction.
\item The instruction memory is marked $\LOWSEC \times \HIGHINT$. That means
  it is observable and can't change.  \bcp{What does this assumption mean,
    precisely?  (I.e., what is ``the instruction memory''?)}
\item The memory space is split in two. One part is marked $\LOWSEC
  \times \LOWINT$: this is the public part (or the one that can be
  accessed by the current process e.g.). The other part is marked
  $\HIGHSEC \times \HIGHINT$: it should be completely inaccessible to the
  current process.
\item Separation is noninterference:
  \leo{Exactly the definition above}
\item Depending on what we do with final instructions, the property
  could be parameterized by the ``call/return sites''.
\end{itemize}
\leo{(The $+$ part in the title is a hint that one thing that gets added is that
the PCs of corresponding traces always stay in lock step because of integrity?)}
\bcp{The section titles are not working so well, now that we're being a bit
  less abstract about our definitions.}

\section{Stack Safety is noninterference$+$}

\leo{Build up to the interesting thing:}
\begin{itemize}
\item The first unmatched return serves as a halt.  \bcp{What does that mean
formally?}
\item The instruction memory is again marked $\LOWSEC \times \HIGHINT$. That
  means it is observable (both traces have the same instructions!) and
  can't change.
\item At the beginning of time\bcp{Not clear what ``beginning of time''
  means when we're talking about hyperproperties---the intuition of time is
  relevant to the traces within the hyperproperty, but not to the
  hyperproperty itself.  Simpler, I think, to view the hyperproperty as a
  starting set of traces (where the whole machine state [registers and PC too,
  right?] is marked $\LOWSEC$), closed under an operator that takes a
  contour+trace+trace and snips out all the subtraces between a call and its
return.  (But: eek---see below.)}, the entire data memory is marked $\LOWSEC
  \times \LOWINT$. That makes for a very unintersting property as all
  variants are necessarily identical.
\item BUT, we close the hyperproperty as follows:
  \begin{itemize}
  \item We need the state description stuff to enforce WBCF and be
    able to talk about ``first unmatched returns''. That is also a
    trace property.
  \item After every call, we keep the part of the (left-hand, wlog
    due to symmetry) trace until its first unmatched return.
  \item We construct a new contour at that point: after every call,
    the local state of the caller becomes inaccessible (marked
    $\HIGHSEC \times \HIGHINT$) until a subsequent return.
  \item For every variant of the new initial state with respect to the
    new contour, the contour plus pair of traces is in the
    hyperproperty.
  \end{itemize}
\end{itemize}

\bcp{Eeek.  Just realized why we absolutely need the ``lockstep'' part!
  The closure operator that snips out a ``subtrace'' between a call and the
  corresponding return has to do the snipping on {\em both} traces at once,
  and this only makes sense if they are executing in lockstep.}

\section{Implementation}
\label{impl}

Sketch of the micropolicies that claim to implement these properties on
PIPE...

\subsection{A taint checking monitor}

\subsection{A stack safety monitor}

\section{Testing the implementations}

\begin{itemize}
\item Experimental results of testing
\end{itemize}

\section{Related work}

\begin{itemize}
\item Nick and Andre's papers (and other micropolicy papers)
\cite{DBLP:conf/sp/RoesslerD18}

This is the basis of our run-time monitor in Section{XXX}.  Specifically,
our micropolicy is a simplified variant of their ... (I think it is the
Return-Address Protection + Static Authorities + Depth Isolation policy, but
need to double check---be careful about laziness.)  Essentially, our work
arose as an attempt to formalize the security property enforced by something
like one of their stack policies.

\item Hritcu et al's work on ``Testing Noninterference
Quickly''~\cite{DBLP:journals/jfp/HritcuLSADHPV16} laid the
foundation of the random testing strategy that we use here.  In particular,
that paper explored testing strategies based on both standard ``End-to-end
noninterference''---a pleasantly extensional and easy-to-define property
that leads to somewhat inefficient testing because process that misbehaves
while its PC is labeled ``high'' must return to a low PC before the
misbehavior can be identified as such---and ``Single-step
noninterference''---a more intricate property related to Goguen and
Meseguer's ``unwinding conditions''~\cite{GoguenMeseguer85} that ``fails
faster'' and is thus easier to test.  \bcp{Explain the relation of the
  latter property to our stack testing strategy.}

\item Azevedo de Amorim's presentation of heap safety as a noninterference
property~\cite{DBLP:conf/post/AmorimHP18} was a key inspiration for our
definition of stack safety.  (Details...)

\item StkTokens: Skorstengaard, Devriese, Birkedal
\begin{itemize}
\item POPL \cite{skorstengaard2019stktokens}
\item tech report with proofs: \cite{skorstengaard2018stktokens}
\url{https://arxiv.org/pdf/1811.02787.pdf}
\item TR with proofs for ``Reasoning about a machine...'', Feb 2019:
\url{https://arxiv.org/pdf/1902.05283.pdf}
\item \url{https://cs.au.dk/~birke/papers/local-capabilities-conf.pdf}
\item Also: {\em Reasoning about a Machine with Local Capabilities: Provably
  Safe Stack and Return Pointer Management} \cite{10.1145/3363519}
\url{https://dl.acm.org/doi/fullHtml/10.1145/3363519}

\bcp{I'm nervous that these papers may be viewed as subsuming most of
  ours---in particular, their security property is formulated as a logical
  relation, i.e. a relational property!  We really need to dig into the
  details (which are unfortunately rather technical).}

\rb{
  Some notes on StkTokens.
}
\rb{
  A calling convention based on linear capabilities to enforce WBCF and LCE. The
  program is divided into mutually distrustful components. Instead of using
  separate stacks for each component and a shared control stack, it uses a
  single shared stack. For this, it needs to pass stack and return capabilities
  to possibly untrusted components temporarily, revoking them later. Together
  with a small number of security checks, these measures suffice to guarantee
  WBCF and LCE. StkTokens employs linear capabilities to obtain this kind of
  result while limiting the amount of overhead needed to secure the transitions
  between boundary crossings, modeled by a standard notion of components,
  linking, disjoint interfaces, etc.
}
\rb{
  The capability machine that is modeled has two final configurations: halted
  (for successful termination) and failed. It is a mostly standard capability
  machine, modified by the additional requirements of linear capabilities
  (moves, stores and loads, seals, splitting and splicing of ranges of
  capability).
}
\rb{
  The formalization relies on the definition of a second operational semantics
  for the target language, where WBCF and LCE are natively enforced, and a proof
  of FA between that and the original operational semantics of the target. This
  semantics executes in lockstep with the original target semantics; in
  addition, it gives a special interpretation to the sequence of call
  instructions on top of the regular step relation. It assumes that all
  components meet some syntactic well-formedness requirements, and requires
  trusted components to perform a number of simple checks in addition to
  employing the calling convention proper (check of stack base address on call,
  appropriate use and protection of return and closure seals), as well as some
  conditions on initial system configurations. The formalization has a number
  of advantages over previous work, notably the establishment of some temporal
  safety guarantees.
}
\rb{
  The core of the proof of FA is the definition of when two components are
  related. This is modeled by a step-indexed Kripke logical with recursive
  worlds, which each collect assumptions about the system. Worlds are divided
  into sub-worlds for heap, call stack and free stack, each mapping region names
  to regions, which can be either spatial (all three) or shared (heap only,
  encapsulating a system invariant, including an invariant on seals). Spatial
  regions differ from shared regions in their linearity and (optionally)
  ownership. ``Regular'' spatial regions can become owned or revoked without
  while preserving the relation between memories in the two semantics. The proof
  uses (shared) code regions, regions for heap and stack memory, and regions to
  track immutable, inactive parts of the stack. With those Kripke worlds, the LR
  defines relatedness of various entities. There are two value relations for
  trusted and untrusted values (a subset of trusted values which are safe to
  pass to an adversary, including stack pointers and their linear capabilities,
  and sealed values, all under certain conditions on the ownership of the
  various parts of the stack). The top-level FA proof is straightforward.
}
\rb{
  The extended operational semantics has support for tail calls. Because data
  memory does not contain any seals or ways to get to those, it can always be
  shared safely.
}
\rb{
  Like in our scheme, instructions must be marked as executable and a check on
  the PC made at each step. Stack pointers are now linear stack capabilities
  (and there should only be stack pointers for the stack memory). Return
  pointers are pairs of sealed return capabilities, encapsulating the callers
  data and return code; the callee can only jump to these. A caller will split
  its own stack capability into two: one for its local stack frame (which will
  be sealed as the data component of the return capability pair) and one for the
  unused stack, which will be passed to the callee. This second capability is
  also used as a token to prove that the callee is allowed to return to the
  caller by adjacency with the sealed data capability (for this trick to work,
  stack frames must be non-empty). Another requirement is that each call point
  needs to be associated with a unique seal for returns, which should never be
  leaked to an adversary.
}
\rb{
  In their ESOP 2018 paper, the same authors present a similar scheme that uses
  local capabilities employing similar techniques. Their capability machine is
  mostly standard. Operations other than those working on capabilities are
  mostly standard, with small extensions to account for the presence
  capabilities. Notably, jmp needs to account for enter capabilities, which can
  only be used to jump to a location and then become read-execute; they
  represent an opaque packing of some code together with local state. The store
  operation is also complicated, this time by the presence of local
  capabilities, which can only be stored in registers (and write-local memory)
  and may be temporarily handed over to an adversary, say for the duration of a
  call.
}
\rb{
  The work presents a concrete calling convention that relies on a single shared
  stack and has moderate overhead with stack and return pointers passed through
  registers as local capabilities. The scheme imposes some standard conditions
  on initial state and memory allocation primitives, and safety measures a
  component needs to perform to protect itself against an adversary. The most
  demanding requirement is that not only non-return value registers and used
  stack, but also the unused part of the stack (which may contain local
  capabilities) needs to be cleared when returning to the adversary. Simple
  measures are applied on calls and returns to and from an adversary, and on
  calls from an adversary.
}
\rb{
  The logical relation that is presented is not specific to the particular
  calling convention. It uses a variant of the public-private separation of
  worlds to model the particular properties of local capabilities. In
  particular, worlds have permanent, temporary and revoked regions, with
  non-revoked regions comprising a state transition system with both public and
  private transitions. Local and global capabilities can depend on protocols
  from permanent regions, and local capabilities can also depend on protocols
  from temporary regions (which may be revoked in the future, and may not
  outlive those regions). A pair of future world relations describe the changes
  of memory over time. In the public FW relation, temporary and permanent
  regions can evolve according to the public part of their transition system,
  and revoked regions can be reinstated as temporary. In the private FW
  relation, temporary and revoked regions can be replaced by arbitrary regions,
  and permanent regions can evolve according to the private part of their
  transition system. The relation defines an observation relation for safe
  configurations (i.e., the memory of a halting configuration is satisfied by
  some private FW). The relation on values covers conditions for the safe use of
  write and write-local capabilities, and similarly for enter capabilities.
}
\rb{
  All this is used to prove WBCF and LCE for concrete example programs.
}

\end{itemize}

\item Stuff about dynamically changing labels (see footnote in Testing
Noninterference Quickly paper)

\item Simple Noninterference by Normalization \url{http://nachivpn.me/nibnbe.pdf}

\item Mechanized Reasoning about a Capability Machine: [Linn] Georges,
Trieu, Birkedal (PriSC 2020).
%
Described at the Iris Workshop as formalizing the security properties of
capabilities. This appears to involve a fairly complex and very large
mechanization in Iris (also in the eyes of the Iris people).

\item Rigorous engineering for hardware security: Formal modelling and proof in
the CHERI design and implementation process
\url{https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/202005oakland-cheri-formal.pdf}

\item \url{https://www.cis.upenn.edu/~stevez/papers/LZ05a.pdf} ??

\item Not so closely related?
\begin{itemize}
\item Daniel's tainting paper (and some refs cited there)
      \cite{DBLP:conf/eurosp/SchoepeBPS16} -- not needed if we postpone
      dealing with tainting till another paper!
\item We'd better say something about the relation to the original
hyperproperties paper, no?  (No, not if we drop the word hyperproperty!)
\end{itemize}
\end{itemize}

\iftext
\section{Future work}

\begin{itemize}
\item Variations / extensions (OS, multiple processes, coroutines, generalizing depths to stacks of static call points, etc.)
\item Extending the policy / property to more realistic ones
\begin{itemize}
\item Argument passing
\item Variable-size stack frames
\item Stack variables
\item Relation to Nick and Andre’s policy
\end{itemize}
\item Could we also implement all this using Cheri capabilities?
\item A more abstract presentation, perhaps unifying our treatments of
confidentiality and integrity?
\end{itemize}

More:
\begin{itemize}
\item More realistic calling conventions.  (We need to eventually match this to the particular calling convention of whatever compiler we choose.)  E.g., the above will not quite work for passing arguments on the stack: callee won’t be able to read them…So perhaps need to support a special kind of write instruction that stores D.PCdepth+1 . [RB: Or implement this distinction through tags?]
\item Combination with heap policy (colors, etc.)
\item For coroutines:
\begin{itemize}
\item Generalize depth to depth + PID
\item Private stuff not having changed as an idea should still work
\item Maybe not so hard: The scheduler + other coroutines are just a sort of generalized “callee” as far as this process is concerned.  Just need to fiddle th step relation so that it recognizes which process is getting returned to and updates its description appropriately.
\end{itemize}
\item If we had a heap policy, maybe we could talk about dynamic code generation, loading, as allocating a heap region, storing instructions into it, and then calling into them.  For now, we just make all the instructions read only and assume they exist in the initial state.
\item Question: how efficiently can consistency be tested? How much scrambling is needed, and does it really need to occur before every instruction? How expensive is it to check for agreement between the (in)accessible parts of two memories?  Would spot checking for agreement be adequate?]
\item What are the effects of compartmentalization on the ability of each compartment to change its own code/stack?
\item Tail calls (maybe by not marking them as call sites?)
\end{itemize}

\section*{Acknowledgments}
\fi

\section*{References}
\bibliographystyle{IEEEtran}
% \bibliography{bcp,local}

\newpage

\section*{Things to think about}

\begin{itemize}
\item
How does Nick’s stack policy actually work these days?
\item Andrew remembers that Catalin looked at something like this a long time ago and they decided that they needed unique tags for each dynamic call, not just levels.  We should check.
\item \bcp{A random thought about integrity: One thing that may be helping confuse
  us about integrity is that we've gone back and forth between ``eager'' and
  ``lazy'' versions of various micropolicies, where the ``lazy'' ones do
  allow high-integrity data to be overwritten, but only in a way that it
  cannot be read again later (e.g., the lazy heap policy guarantees that, if
  inaccessible memory is overwritten, then its color will change).  The lazy
point of view is much more subtle as an integrity property.  So, to keep our
heads straight here, we should be thinking only about eager properties in
the first instance.}
\end{itemize}

\newpage

\section{Old Stuff}

\begin{itemize}
\item {\em prefix-closed:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C,
    M')}_n$ in the set, \bcp{where $n$ is the length of the traces,}\leo{Yes I put that in the definition of traces above, but we could repeat it here} the
  pair of truncated traces $\overline{(C,
    M)}_m$ and $\overline{(C, M')}_m$ is also in the set if $m < n$ \bcp{or
    $n = \infty$}.

\item {\em suffix-closed:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C,
    M')}_n$ in the set, and for every $0 \leq i < n$, there exists in
  the set a pair of traces $\overline{(C', N)}_m$ and $\overline{(C',
    N')}_m$ such that for all $0 \leq j < m$, $C_j' = C_{i+j}$, $N_0 =
  M_i$, and $N_0' = M_i'$, and where $m$ is the maximum index for
  which $C_i \leq C_{i+j}$ for all $0 \leq j < m$. Here $C \leq C'$ if
  $\forall \component, C(\component) \leq C'(\component)$ and $\VIS <
  \HID$.

\item {\em variant-closed:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C,
    M')}_n$ in the set, and for every machine state $N_0$ such that
  $N_0$ is a variant of $M_0$, there exists in the set a pair of
  traces $\overline{(C, M)}_n$ and $\overline{(C, N)}_n$.\apt{Same
    complaint about $n$. And again, $N_0$ defines $\overline{N}$ but
    it doesn't define $\overline{(C,N)}$. }\leo{Cs should be the same
    right?}


\item {\em as in noninterfence:}

  For each pair of traces in the hyperproperty, if the initial machine
  states plus contour \apt{``elements''} are variants, then the observervations of the
  two traces coincide.

\end{itemize}

\bcp{It feels like something is missing here: This definition seems to be
  requiring that secret data never affect observations, but our tester is
  ensuring something more: that inaccessible locations are not {\em changed}
(at least without also changing their tag to make them accessible).  Where
  is that condition being imposed?}
\leo{It's not - I just went by the definition of (traditional) noninterference
  you had and repeated that. I'm thinking about that now}

\apt{Even if it works for subroutines,
  the basic idea of truncating traces when visibility increases doesn't
  seem to extend to things like coroutines, where we swap between two sets of visible locations on each transfer.}


% \bcp{Should we require that it contain all possible starting states and
%   contours (though of course the sequences can be singletons in many
%   cases!)?  What does it mean if it doesn't?}

\bcp{Policies and properties need to know where are the call and return
  sites, and for this they need to be initialized with some
  application-specific information.  So it seems what we should do is to
  talk instead about ``$X$ policies'' (i.e., make ``policy'' a type
  operator) and replace the initial $\CONTOURS$ argument to both policies
  and properties by an element of $X$.}


%
% \leo{Some notes for the meeting}
%
% In traditional NI viewed as a pair of contoured traces $\overline{(C, M_i)}$ and
% $\overline{(C, N_i)}$, we can have the following formulations:
% \begin{enumerate}
% \item $M_0, N_0 \in \mathit{Initial State}, ~\text{s.t.} ~\mathit{variant}(C, M_0, N_0)$
% \item $M_0 \in \mathit{Initial State}, N_0 \in \mathit{Variant}(C, M_0)$
% \item $M_0, N_0 \in \mathit{Reachable State}, ~\text{s.t.} ~\mathit{variant}(C, M_0, N_0)$
% \item $M_0 \in \mathit{Reachable State}, N_0 \in \mathit{Variant}(C, M_0)$
% \end{enumerate}
% %
% The (intuitive) top level property we care about is (1) - end to end
% noninterference.
% %
% Property (2) is easier to test - but not always equivalent (if the set
% of variants of an initial state can take you outside the set of
% initial states).
% %
% Property (3) is also easier to test than - you start from an arbitrary
% (reachable) state instead of an initial one, allowing to get to the
% interesting part sooner.
% %
% Property (4) corresponds to what we actually want to test - start from
% an arbitrary (reachable) state, vary it, test the trace.
%
% As far as facilitating testing goes, the assumption of SSNI is that
% you don't need to test full traces - you can test all traces of length
% 1 and that somehow gives you confidence for the full property.
% %
% More importantly, note that going from (1,2) to (3,4) doesn't really
% change the property itself {\em as long as the contour stays identical
%   throughout the execution}.
%
% Now, when the contour does change the expressive power of (3,4) and (1,2)
% is slightly different:
% \begin{itemize}
% \item If the contour C makes more things hidden at step $i$, then
%   starting from the (reachable) state $M_i$ and taking its variant can
%   lead to a pair $M_i, N_i$ that is not reachable from a pair of variant
%   initial states.
% \item If the contour C declassifies things at step $i$, then traces
%   that started from variants $M_0, N_0$ based on a more restrictive
%   contour C, can reach that point and no longer remain variant based
%   on the new contour.
% \end{itemize}
% Therefore an additional property of the hyperproperties when
% classification/declassification is involved, is that the traces
% in the property start at some contour level C0 and are truncated
% after C becomes more permissive than C0.
%
% The stack property we test is just a way of testing such a
% hyperproperty more efficiently.



% If $\mach$ and $\mach'$ are variant machine states with respect to contour
% $\contour$, then $\mach$ and $\mach'$ are said to be {\em indistinguishable}
% under policy $\pol$ if their observable
% %
% $\obstrace(
%                       (\contour,\mach)
%   \stepstounder{\pol} (\contour_1,\mach_1)
%   \stepstounder{\pol} (\contour_2,\mach_2)
%   \stepstounder{\pol} \ldots)$
% %
% yields the same trace as
% $\obstrace(
%                       (\contour,\mach')
%   \stepstounder{\pol} (\contour_1,\mach_1')
%   \stepstounder{\pol} (\contour_2,\mach_2')
%   \stepstounder{\pol} \ldots)$.

% % either (1) one or both of $(\contour,\mach)$ and
% % $(\contour,\mach')$ fail to terminate when executed with
% % $\stepstounder{\pol}$, or (2) both terminate and the machine-state
% % components of their results are variants with respect to the original
% % $\contour$.

\iftext
\begin{itemize}
\item \bcp{Should we be talking about end-to-end or single-step NI?  I guess we
  have to begin with EENI and then get to SSNI as a (stronger) refinement.}

\item Relation to the standard definition of NI.
\end{itemize}
\fi

% Policy $\pol$ {\em guarantees noninterference} if, for every $\contour$,
% every pair $(\mach,\mach')$ of variant machine states with respect to
% $\contour$ are indistinguishable under $\pol$.

\iftext
\bcp{
Fact: The standard RISC-V semantics (i.e., the null policy) does not
guarantee NI.  (Give a little example of a program that reads from a secret
location and writes to a public one, just to illustrate the definition of
NI.)}
\fi

\subsection{Policies}

\leo{I think with the property being just a (special) hyperproperty
  again, the policy can be ``more detailed'' - including low-level
  enforcement details like tags, etc. But you should always be able to
  reconstruct the contoured trace given an initial contour and an
  initial state. I'm taking that approach here:}

Formally, a policy
%
$\pol \in \exists X.\; (\CONTOURS \rightarrow X)
                       \times (X \rightarrow \CONTOURS)
                       \times (\MACHS \times X \rightharpoonup \MACHS \times X)$
%
comprises
\begin{enumerate*}
  \item a private type $X$ corresponding to an ``implementation'' of the contour,
  \item an initializer: a function taking a contour \leo{and a machine state?} to an initial value of $X$,
  \item a projection: a way of reading a contour out of the private type,
  \item a partial step function of type $(\MACHS \times X) \rightharpoonup X$
    that, when defined, defines the private state after a step of the machine
    (based on the $\stepstounderfull$ relation).
    \leo{Not sure this should be taking $\MACHS$ as input. It should take $X$
      plus just the instruction being executed? The rest are the tags in $X$}
\end{enumerate*}
That is, a policy takes a starting contour and produces a runtime monitor
that carries along some private information and uses it to decide whether to
terminate execution early.

\leo{Example? how detailed?}  For example, for standard
lockstep-noninterference with only two secrecy levels, the private
state {\em is} the contour.

A policy $\pol$ {\em guarantees} property $\prop$ if for every pair of
states $M$ and $M'$ and for every starting contour $C$, the pair of
contoured traces that you get from the policy is in the property.

\leo{New attempt ends here}
Informally, a (micro-){\em policy} is an enriched step function that,
whenever is is defined, agrees with $\stepstounderfull$.  It represents an
enforcement mechanism that sometimes halts programs earlier than the bare
step relation does but that agrees with the bare step relation as long as it
allows evaluation to proceed.  We write
$(\contour_1,\mach_1) \stepstounder{\pol} (\contour_2,\mach_2)$ for
$\pol(\contour_1,\mach_1) = (\contour_2,\mach_2)$.

\leo{Shouldn't this take a pair (C,M) to a pair (C,M)?}
Formally, a policy
%
$\pol \in \CONTOURS \rightarrow \MACHS \rightarrow \SEQ{\MACHS}$
%
takes a contour $\contour$ and a starting machine state $\mach_0$ and produces
a finite or infinite sequence of states $\mach_0,\,\mach_1 ,\, \ldots$ such
that $\mach_{i-1} \stepstounderfull \mach_i$ for each $i > 0$ in the sequence.

% \bcp{Fix: even simpler and cleaner, just run the step function to completion
%   and forget about $X$---i.e., a property is just a function from a pair of
%   a contour and a machine state to a finite or infinite sequence of machine
%   states!}
% Formally, a policy
% %
% $\pol \in \exists X.\; (\CONTOURS \rightarrow X) \times (\MACHS \times X
% \rightharpoonup \MACHS \times X)$
% %
% comprises
% \begin{enumerate*}
%   \item a private type $X$,
%   \item a function taking a contour to an initial value of $X$, and
%   \item a partial step function of type
%   $(\MACHS \times X) \rightharpoonup (\MACHS \times X)$ that, when defined,
%   agrees with $\stepstounderfull$ on machine states. \bcp{We could actually
%     just make it return an X and calculate the machine state from the
%     ordinary step function.  This is perhaps a bit cleaner.}
% \end{enumerate*}
% That is, a policy takes a starting contour and produces a runtime monitor
% that carries along some private information and uses it to decide whether to
% terminate execution early.

Policy $\pol$ {\em guarantees} property $\prop$ if \bcp{for every pair of
  starting states and every starting contour, the pair of traces that you
  get from the policy is in the property for {\em some} pair of sequences of
  contours that agree with the given contour on the first element.}

% every $\contour$,
% every pair $(\mach,\mach')$ of variant machine states with respect to
% $\contour$ are indistinguishable under $\pol$.


\subsection{Alternative Definition of Contoured Hyperproperty}

\apt{Just for the record, here's an attempt to write down the splice-based
  alternative I suggested. I \emph{think} it might work for stack safety
  (and coroutine safety).  But there are some problems: (a) it doesn't account for the caller being able to write into the callee's local data (although perhaps there's no good reason to allow this anyway); (b) two calls that just happen to use the same memory space for their frames will share the same contour, which seems wrong.  I'm wondering if it would be better to use a more
  explicit and nominal refinement of contours (maybe called ``context''); two
  contexts might have the same contour but the trace partitioning would be done based on context name. I haven't thought about relating all this to testing...}

  Let $T = \overline{(C,M)}_n$ be a contoured trace of length $n \leq \infty$.
  Write $T\vert_C$ for the result of
  filtering $T$ to contain only elements with contour $C$ and
  then projecting the trace components.
  The \emph{contour partition} of $T$ is the set
  $P(T) = \{(C_{i_1},T\vert_{C_{i_1}}),
  (C_{i_2},T\vert_{C_{i_2}}),
  \ldots,(C_{i_d},T\vert_{C_{i_d}})\}$ where
  $C_{i_1},C_{i_2},\ldots,C_{i_d}$ are the distinct contours appearing in $\overline{C}$.
  In other words, $P(T)$ is the result of dividing the trace into sections based on contour and then splicing together the sections. Note that these traces no longer obey the underlying step function; e.g., there might be a step directly from a call Jal to the return address. (We may need to pin down exactly what is legal in these ``gappy'' sequences.)

  Observations are a bit simpler than before.
  A \emph{state observation} with respect to a contour $C$ is a map from
  the machine components visible in $C$ to words.
  An \emph{observation} with respect to a contour $C$ is
  is a nonempty, finite or infinite sequence of
  state observations with respect to $C$, in which adjacent elements
  are distinct (``no stuttering'').
  In particular, the \emph{observation trace} of
  a machine state sequence $\overline{M}$ with respect to a contour $C$,
  written $\obstrace_C(\overline{M})$ is the observation
  obtained by removing duplicates from the sequence
  $\stateobs_0,\, \stateobs_1,\, \ldots$ where
  $\stateobs_i(\component) = M_i(\component)$ for all $\component$ such that $C(\component) = \VIS$.
  We extend observation traces to contour partitions piecewise:
  if $P(T) = \{(C_1,\overline{M}_1),(C_2,\overline{M}_2),\ldots,(C_d,\overline{M}_d)\}$, then $\obstrace(P(T))$ is $\{(C_1,\obstrace(\overline{M}_1)),
  (C_2,\obstrace(\overline{M}_2)),\ldots,(C_d,\obstrace(\overline{M}_d))\}$


  Variants are as before.
  Noninterference (no need for lockstep) with respect to a (single)
  contour $C$, written $NI_C$, is defined as as a (standard) hyperproperty: it is the set of pairs of (ordinary, but possibly gappy) machine-state traces such that if the initial elements of the traces are variants with respect to $C$ then their observation traces with respect to $C$ are identical.

  A \emph{contoured hyperproperty} (no restriction to lockstep) is still a set of pairs of contoured traces.

  \emph{Contoured noninterference} is the contoured hyperproperty defined as follows: the pair of contoured traces $(T,T')$ is in the hyperproperty if,
  for each $(C,\overline{M}) \in P(T)$ and $(C',\overline{M'}  ) \in P(T')$,
  if $C = C'$ then $(\overline{M},\overline{M'}) \in NI_{C}$. (NB: This may
  be too liberal; perhaps the sets of $C$'s should be the same?)

Standard noninterference falls out in the obvious way when trace contours are invariant. (In this case, the machine-state traces are not gappy.)

\iftext
\subsection{More...}
  \begin{itemize}
  \item Proposal: Maybe forget about full-blown NI and focus the whole paper
  on variants of ``lockstep NI'' where the PC is the same in every pair of
  related runs?
  \item One issue that I am not sure about: Could there be a sneaky way of
  ``putting secret information into the control state'' where the PCs of
  related runs are always in lockstep but, because the instruction memory is
  writeable, different instructions can get dispatched.

  E.g., suppose the program looks like
\begin{verbatim}
0:   load from address 1000
     write to address 100
     jump to address 100
100: <initial contents don't matter>
     write R3 into address 1004
     jump to address 100
1000: <marked HIGH so that initial
       contents vary on different runs>
1004: <marked OBSERVABLE>
\end{verbatim}
  If the initial contents of address 1000 in one run is the encoding of the
  instruction ``load immediate 0 into R3'' and the initial contents in the
  other run is the encoding of the instruction ``load immediate 1 into R3,''
  then the two programs execute different instructions (leading them to
  write different things to an observable location) even though their PCs
  are always in lock step.

  So maybe we should be asking that the instruction stream be
  identical, or maybe instructions paired with PCs?

  \bcp{Answer: Just make instructions read-only.}

  \item One nice observation is that, if we are only interested in pairs of
  runs with identical PCs, there are two different ways to proceed: (1) say
  that we {\em ignore} runs where the PCs (or instruction streams) diverge
  (e.g., taint tracking), or (2) {\em disallow} runs where the PCs (or
  instruction streams) diverge, i.e., demand that this never happens (e.g.,
  stack and heap policies).
  \item A remaining question is what to do about the possibility that the
  contour changes differently on two related runs.  We could disallow this,
  but not certain it's necessary---maybe everything works out OK.
  \end{itemize}
\fi

\newpage
\section{Tainting is noninterference$-$}

\leo{Rough draft/take on this section}
\begin{itemize}
\item Taint tracking is an interesting property.
\item It's weaker than traditional noninterference, but easier to enforce so people use it.
\item \leo{Some of the intuition from below}
\end{itemize}

\paragraph{Taint Tracking Property}

Given a contour C and pair of traces $\overline{M}$ and $\overline{N}$,
the pair of contoured trace $\overline(C, M)_n$ and $\overline(C,N)_n$ is in the
taint tracking contour-lockstep hyperproperty if:
\begin{itemize}
\item For all $0 \leq i < m$ the restriction of the trace to its
  length $i$ prefix is in the standard noninterference property
  \leo{Defined in the previous section}, where $m$ is the minimum
  index (or infinity) for which $PC(M_i) \not = PC(N_i)$ or
  $instr(M_i) \not = instr(N_i)$.
\end{itemize}

\paragraph{Taint Tracking Policy}

\newcommand*{\clean}{{\em clean}}
\newcommand*{\tainted}{{\em tainted}}
\newcommand*{\boring}{{\em boring}}
\begin{itemize}
\item We define three {\em tags} \leo{have we defined what these
  are?}: \clean, \tainted, and \boring. Machine components tagged
  \clean by the policy represent protected locations that should never
  be tainted. Components tagged \tainted are either sources of taint
  (e.g. network inputs) or components that have been influenced by
  other \tainted ones. Finally \boring components are locations that
  are allowed to become tainted (perhaps temporarily) but have not
  yet.
\item To implement the taint tracking property as a policy, we
  initialize a map from components to tags. From this map, we can read
  a contour in a straightforward manner: \clean is \VIS, the other
  tags are \HID.
\end{itemize}

\leo{How do we want to write these rules? Explain .dpl?}
%//TODO: This is a bug opportunity, right?
%   // explicit failure for write tainted val to clean addr
%   storeGrp(   mem == [+Clean], addr == _, val == [+Taint], env == _
%              -> fail "Tainted data written to clean memory")
%
%   // Propogate taint
%#ifndef ADD_NO_TAINT_1
%   ^ arithGrp(env == _, op1 == [+Taint], op2 == _ -> env = env, res = op1)
%#else
%//   ^ arithGrp(env == _, op1 == [+Taint], op2 == _ -> env = env, res = {})
%#endif
%#ifndef ADD_NO_TAINT_2
%   ^ arithGrp(env == _, op1 == _, op2 == [+Taint] -> env = env, res = op2)
%#else
%//   ^ arithGrp(env == _, op1 == _, op2 == [+Taint] -> env = env, res = {})
%#endif
%   ^ mulDivRemGrp(code == _, env == _, op1 == [+Taint], op2 == _ -> env = env, res = op1)
%   ^ mulDivRemGrp(code == _, env == _, op1 == _, op2 == [+Taint] -> env = env, res = op2)
%   ^ immArithGrp(env == _, op1 == [+Taint] -> env = env, res = op1)
%#ifndef NO_MEM_TAINT_CHECK_LOAD
%   ^ loadGrp(mem == [+Taint], addr == _, env == _ -> env = env, res = mem )
%#else
%// No mem check
%#endif
%#ifndef NO_ADDR_TAINT_CHECK_LOAD
%   ^ loadGrp(mem == _, addr == [+Taint], env == _ -> env = env, res = addr )
%#else
%// THIS WAS AN ACTUAL BUG! Addres check ommitted
%#endif
%#ifndef NO_VAL_TAINT_CHECK_STORE
%//NOT A BUG! We never write tainted data to clean memory because of the first rule
%   ^ storeGrp(mem == _, addr == _, val == [+Taint], env == _ -> env = env, mem = val)
%#else
%// NO CHECK
%#endif
%#ifndef NO_MEM_TAINT_CHECK_STORE
%   ^ storeGrp(mem == [+Taint], addr == _, val == _, env == _ -> env = env, mem = mem )
%#else
%// NO CHECK
%#endif
%#ifndef NO_ADDR_TAINT_CHECK_STORE
%   ^ storeGrp(mem == _, addr == [+Taint], val == _, env == _ ->
%     fail "Can't write through a tainted pointer")
%#else
%// Could also taint mem with addr. Also an actual bug (but one that I made).
%// THIS WAS AN ACTUAL BUG! Addres check ommitted
%#endif
%   // keep clean mem stays clean always
%   ^ storeGrp(   mem == [+Clean], addr == _, val == _, env == _ -> env = env, mem = mem)



\bcp{This needs to be written, now that we have added the hidden/observable stuff.}

\begin{itemize}
\item First intuition: A program is taint-NI if every pair of runs that don’t
branch on high data are noninterfering in the standard sense.  (i.e., they
don't write secret data to public locations and vice versa)
\item Better alternative: … for every pair of runs that take the same control path (even if they branch on tainted data)...
\item We could even go a step farther: {\em truncate} the runs at the
  first point where their PCs differ, then demand NI.  This is a less
  demanding property and probably a less desirable one, as it doesn't
  predict the behavior of actual taint policies.  Discuss.
\item Note that this is a super-simple property that doesn't really track
taint at all.
\item (Are there any other variations of tainting that we could present in
this framework?)
\end{itemize}


\section{Separation is noninterference$+$}

Presentation idea: Start here with a super-simple separation policy, which
just makes some part of the address space inaccessible, truncating any
traces that read or write it.  Formulate the property as a flavor of NI.
(The $+$ part in the title is a hint that one thing that gets added is that
the PCs of corresponding traces always stay in lock step.)

\section{Stack protection is noninterference$++$}

Here we consider stack protection as an instance of generalized noninterference \apt{or whatever it's called}.
Our notion of stack protection includes aspects both of control integrity and data security.
In the terminology of Skorstengaard et al.~\cite{Skorstengaard+19} we enforce:

\begin{itemize}
\item \emph{Well-bracketed control flow (WBCF)}, which says that ``invoked functions must either return to their callers,
  invoke other functions themselves, or diverge.''
\item \emph{Local state encapsulation (LSE)}, which says that ``when a function invokes another function, its local variables
  (saved on its stack frame) will not be read or modified until the invoked function returns.''
\end{itemize}
\apt{Should rephrase (and improve!) these in our own words.}

These properties are essentially orthogonal: one can certainly have WBCF without LSE, and variants of
LSE could apply to control constructs beyond simple procedure calls (e.g. exceptions, coroutines, threads, monitors, etc.).

Under the assumption that WBCF holds, we can describe LSE as an instance of Lockstep-Noninterference, where the contour at
each step maps the current stack frame to \VIS\ and the remainder of the stack to \HID\.
The observations on which noninterference is defined will (necessarily)  be made on the values in the current stack frame.
\apt{Again, we're conflating \VIS\ vs. \HID\ with \LOWSEC\ vs \HIGHSEC\; should probably be teased apart.}
LSE has two aspects: secrecy (callees cannot read caller variables) and integrity (callees cannot alter caller variables).
Secrecy is enforced by the variant-closure clause of L-N: since caller data is \HID, changing it cannot alter
the callee's observable behavior.  Integrity is enforced why??? \apt{I've lost confidence that it is.}


To make these ideas concrete in this paper, we adopt a very simple (and unrealistic) set of assumptions/conventions for stack frames and procedure calls.
Each procedure stack frame contains just one local variable (plus possible control information), which is pointed to by
the SP whenever the PC is within the procedure body (excluding entry and exit sequences). Our WBCF property says that
when a procedure is called from a given PC at a given SP, it eventually returns (if at all) to the next
address following the PC with the same SP. Our LSE-like property says that addresses between the base of the stack
up to (but not including) the current SP cannot be read or written.
\apt{Not clear why we should bother allowing addresses beyond the current top of stack to be accessible.}
In particular, this implies that upon return from a call,
the value of the local variable will be unchanged; moreover, the values of local variables cannot influence the
behavior of callees. Parameters and return values are passed in registers, which (except for SP and RA) do not change
during call or return.

{\bf Getting more precise about the property.}

Assumptions on code and environment\apt{trying to be as minimal as possible}:
\begin{itemize}
\item
  Memory is divided into two disjoint regions, one containing the code, the other the stack.
  Code begins at address 0; the stack begins at address B and grows up, in the direction of increasing addresses.
\item
  The part of the stack between $B$ and the stack pointer \textsc{sp} (inclusive) is structured into a contiguous sequence of
  \emph{frames}. Each frame contains a single word of local data, possibly preceded by control information. \apt{TMI?}
  The initial value of \textsc{sp} is $B-1$.
\item
  Code is assumed to be be annotated to indicate (a) instructions representing calls, (b) instructions forming the \emph{entry sequence} of
  a procedure, and (c) instructions forming the \emph{return sequence} of a procedure.
\item
  Execution of the entry sequence pushes a new frame on the stack, adjusting \textsc{sp} to point to that
  frame's data word.  Execution of the return sequence pops the frame on top of the stack by readjusting \textsc{sp}.
  \apt{TMI!?}
  Outside of the entry and return sequences, no instruction alters \textsc{sp}.
\item
  The call instruction and entry and return sequences do not alter any registers except \textsc{sp} and one
  particular register named \textsc{ra}.
\end{itemize}

DO HERE: Formal description of conjecture 2 property.  Or maybe we no longer really care about this particular property if we have something for conjecture 3?

An (abstract) \emph{state description} $D$ consists of
\begin{itemize}
\item
  A stack $\dstk{D}$ of addresses, representing the return addresses of the current procedure and its callers.
  \apt{No need to remember the sp's, since they can be computed given that we know the fixed frame size.}
  \apt{No need for $\dpcd{D}$ since it is just the size of $\dstk{D}$.}
\item
  For each memory location $a \geq B$, a natural number $\ddep{D}{a}$, representing the depth
  of the frame to which $a$ belongs ($\infty$ if none).
\end{itemize}

The \emph{initial state description} $\dinit$ has $\dstk{\dinit} = \empstack$ and $\ddep{\dinit}{a} = \infty$ for all $a \geq B$.

An address $a$ is \emph{accessible} with respect to a state $D$, written $\access{D}{a}$, if
$a \geq B$ and $\ddep{D}{a} \geq \norm{\dstk{D}}$.


TODO:
\begin{itemize}
\item
  Define step relation.
\item
  Define step consistency.
\item
  Discuss relationship between state consistency and top-level property.  (Former is: presumably stronger; hopefully not
  too strong that it produces lots of undesired test failures; surely easier to test).

\end{itemize}


\iftext
\section{Stack + heap protection too}

POTENTIALLY: Memory safety (before stack) + Conjunction of memory + stack
safety (after).

(Memory safety by itself is just arthur’s paper, but it’s cool to see how
they are combined, especially what bits can be factored out as common
structure, e.g. the notion of accessibility)
\fi

\end{document}
