%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\input{macros}

\begin{document}

%% Title information
\title{Stack Safety as a Security Property}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
%\author{First1 Last1}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
%  \institution{Institution1}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{Country1}                    %% \country is recommended
%}
%\email{first1.last1@inst1.edu}          %% \email is recommended
% 
%%% Author with two affiliations and emails.
%\author{First2 Last2}
%\authornote{with author2 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position2a}
%  \department{Department2a}             %% \department is recommended
%  \institution{Institution2a}           %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
%  \country{Country2a}                   %% \country is recommended
%}
%\email{first2.last2@inst2a.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Stack Safety, Micropolicy, Random Testing, RISC-V}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

\begin{figure}
  \begin{minipage}{\textwidth}
  \begin{center}
$\cdots$
\memory{4}{gray}%
\memory{8}{green}[{\makebox[0pt]{Caller}}]%
\memory{4}{yellow}[{\makebox[0pt]{Args}}]%
\memory{8}{red}[{\makebox[0pt]{Callee}}]%
\memory{4}{gray}%
~$\cdots$
  \end{center}
  \end{minipage}\\
~\\
~\\
  \begin{minipage}{0.45\textwidth}
    \begin{center}
      Code 1
    \end{center}
  \end{minipage}~
  \begin{minipage}{0.45\textwidth}
    \begin{center}
      Code 2
    \end{center}
  \end{minipage}
  \caption{Examples of Unsafe Programs}
  \label{fig:stackunsafety}
\end{figure}


Everybody likes stack safety. Nobody can say what it is precisely.

The intention is to protect callers from callees.

Examples of what it isn't in the literature.
Small bad examples of things that can go wrong.

Turn this into a positive security property: integrity + confidentiality.

\leo{Variations of these should probably go here:}
    {\it Eager stack integrity} states that if a function call returns, the caller's stack data
    will be identical to what it was before the call. This implies the weaker {\it observable
    stack integrity}, which states that any changes to the caller's frame will produce the same
    observable behavior.

    Confidentiality is in the style of noninterference, defined on a per-call basis. For each call,
    the caller's data and the uninitialized stack do not interfere with observable behavior until return.
    In {\it eager stack confidentiality} this means that when a function is called, the memory outside of
    its stack frame could be scrambled without changing its observable behavior or the changes it makes
    to the program state. This implies the weaker {\it observable stack confidentialty} in which
    inaccessible memory could be scrambled at each call and restored on return without changing the
    observable behavior of the remaining program.

Challenges?
Shifting notion of who the attacker is throughout execution.

Roadmap: 
Preliminaries before all these.

Contributions:
\begin{itemize}
\item A formal property capturing the informal understanding of what ``stack safety'' is.
\item Evidence that this property is strong enough to capture the folk
intuition: we show that the stack
  unsafe examples from the literature also fail our property.
\item Evidence that the property is not too strong. It's realizible by
  a previously proposed  micropolicy enforcement mechanism \leo{And it
    says yes on a substantial body of code}
\item A (inductive? step-by-step/stepwise) variant of this property
  tuned for testing/verification together with a proof that it implies
  the original property.  We test the whole thing with a cool
  framework.
\item A lazy version of the property that allows for more efficient/dynamic enforcement.
  Maybe testing.
\item TODO: Logic? Reasoning Principles?
\end{itemize}

Related work pointer + conclusions.

\section{Background}

We begin by describing our machine model. Concretely, we have in mind a
conventional machine architecture with a standard (RISC-V) processor
extended with some kind of (static or dynamic, software- or
hardware-enforced) security monitor, but we won't need to make any
specific choices about details until we get to \bcp{the policy one, probably}.
%In this section we will describe an abstract interface to our machine model.

Values and addresses are words drawn from some set of all words $\WORDS$. We will
denote words with $\word$.\leo{TODO: If we ever need ``A'' come back to this.}

Components are words (denoting addresses) and registers.
%
    \[\reg \in \REGS\]
    \[\component \in \COMPONENTS = \WORDS + \REGS \]
%
The registers must include two special purpose registers: the program
counter \PCname and the stack pointer \SP.

A machine state is just a map from components to values:
%
\[\mach \in \MACHS = \COMPONENTS \rightarrow \WORDS\]


Our stack safety property will be defined in terms of {\em observations}, which may be
silent (written $\tau$) or a word of data:
%
\[\obs \in \OBSS = \tau ~ | ~ \word \in \WORDS\]

These observations are a byproduct of the step function of the
machine, which takes a machine state and produces a pair of a
machine state and an observation.
%
\(\mach \stepstoobs{\obs} \mach' : \MACHS \rightarrow \MACHS \times \OBSS \).

\paragraph*{Policy}
    
A policy is a general model of an enforcement mechanism, consisting of
a set of policy states, \(\pol \in \POLS\) and a policy step function
\((\mach, \pol) \stepstopol \pol' : \MACHS \times \POLS
\rightharpoonup \POLS\).

%    The initializer and step function are both partial functions,
%    the former to reflect static guarantees (some initial states may not be valid at all) and
%    the latter to reflect dynamic fail-stop behavior. We then define machine-policy pairs and
%    a step function on them:

Let $\MPS$ be the set of all pairs of machine states and policy states.
%
\[\MPS = \MACHS \times \POLS\]
%
Then we can lift this policy step function to operate on such pairs,
by combining it with the regular step function for machine states.

%    \[\stepstoobs{}_P \subseteq \MPS \times \MPS\]

    \[\frac{\mach_1 \stepstoobs{\obs} \mach_2 \hspace{.5cm} (\mach_1, \pol_1) \stepstopol \pol_2}
           {\mpstate{\mach_1}{\pol_1} \stepstoobs{\obs}_P \mpstate{\mach_2}{\pol_2}}\]
\leo{Notation: Should $\stepstoobs{}$ be partial?}

\paragraph{Traces}

A trace over some type $A$ is a potentially infinite, nonempty
sequence of $A$s. We will mostly be concerned with sequences of
machines states, usually denoted $\machT$, and with sequences of
triples of (machine states, policy states, and observations), usually
denoted $\MPT$.

We define a few operations on traces generically.
The {\it split} operation \(\mathit{split}(f,T)\) takes a trace \(T\) and a predicate on elements \(f\) and
separates \(T\) into a prefix and suffix at the first element on which \(f\) holds:
  \[\frac{f\ t}
         {\mathit{split}(f,tT) = t, tT}\]
  \[\frac{\neg f\ t \hspace{.5cm} \mathit{split}(f,T) = T_1,T_2}
         {\mathit{split}(f,tT) = tT_1,T_2}\]

The {\it join} operation \(T_1 \cdot T_2\) takes two traces and links them by replacing the last element
of the first (if it has one) with the first of the second:
  \[\frac{}
         {T_1t \cdot T_2 = T_1 T_2}\]

We define the ``trace-of'' operator \(\hookrightarrow\) that coinductively
relates a machine state with the trace of machine states paired with
observations produced by repeated application of step:
\[\machT \in \mathit{MOTrace} = \mathit{Trace}\ (\MACHS \times \OBSS)\]
\[\hookrightarrow : \machT \rightarrow \mathit{MOTrace}\]
%
\[\frac{\mach_0 \stepstoobs{\obs} \mach_1 \hspace{.5cm} \mach_1 \hookrightarrow \machT}
       {\mach_0 \hookrightarrow (\mach_0,\obs) \machT}\]
%
Since the step function is total, if \(\mach \hookrightarrow \machT\),
then \(\machT\) must be infinite.

\sna{This is a bit off, because \(f\) is a predicate on machine states, not the pairs (and later triples).
     Will think about what the best way is to present this.}
We will also wish to take a prefix of the trace from an initial state up through the first state where
some condition holds, using {\it split}. Let \(f\) be a predicate on machine states. Then we define
\(\mach \hookrightarrow \machT | f\) (read ``\(\machT'\) is the prefix of \(\machT\) up to \(f\)''):
  \[\frac{\mach \hookrightarrow \machT \hspace{.5cm} \mathit{split}(f,\machT) = \machT_1,\machT_2}
         {\mach \hookrightarrow \machT_1 | f}\]

Similarly, we define \(\hookrightarrow_P\) to relate a machine-policy
state pair to the trace of triples of machine states, policy states,
and observations induced by by \(\stepstoobs{}_P\):
%
\leo{I think this would read better as not exists. Thoughts?}
\sna{Looks good.}
  \[\MPT \in \mathit{MPOTrace} = \mathit{Trace}\ (\MACHS \times \POLS \times \OBSS)\]
  \[\hookrightarrow_P : \MACHS \times \POLS \rightarrow \mathit{MPOTrace}\]
  \[\frac{\neg \exists \pol_1 . \pol_0 \rightharpoonup \pol_1}
         {\mpstate{\mach_0}{\pol_0} \hookrightarrow \mpostate{\mach_0}{\pol_0}{\tau}}\]
  \[\frac{\mach_0 \stepstoobs{\obs} \mach_1 \hspace{.5cm} \pol_0 \rightharpoonup \pol_1 \hspace{.5cm}
            \mpstate{\mach_1}{\pol_1} \hookrightarrow \machT}
         {\mpstate{\mach_0}{\pol_0} \hookrightarrow_P \mpostate{\mach_0}{\pol_0}{\obs} \machT}\]

We also lift the prefix-up-to relation to such traces.
  \[\frac{\mpstatename \hookrightarrow \MPT \hspace{.5cm} \mathit{split}(f,\MPT) = \MPT_1,\MPT_2}
         {\mpstatename \hookrightarrow \MPT_1 | f}\]

Finally, we will use \(\pi_m\) to project the trace of machine states
out of a trace, \(\pi_p\) to project the trace of policy states, and
\(\pi_o\) to project the observations.
       
%    \COQ{this operation steps until it reaches a state on which \(f\) holds,
%    and is infinite if it doesn't. It doesn't compute the observation of the step after the final,
%    which coq would. So coq may need a ``step until'' relation rather than ``prefix up to''.
%    Still thinking about this.}\leo{So this is strictly weaker than the one we have in Coq, right?
%      So its only the Eager implies Lazy direction that might need tweaking, but not the Test implies Eager one?}
%    \leo{Also, it steps until it reaches an f-state or if the policy raises a fault}

\paragraph*{Observations and Equivalence}

We say that a trace of observations $\obsT_1$ is a prefix of $\obsT_2$
\leo{Benjamin suggested ``as far as an attacker is conerned in an
  e-mail, but we haven't said anything about attackers yet.}, if the
sequence of word-observations of $\obsT_1$ is a prefix of those of
$\obsT_2$, that is we operate up to deletion of \(\tau\) observations, coinductively:

\[\frac{} {\obsT \lesssim \obsT}\]

\[\frac{} {\tau \lesssim \obsT}\]

\[\frac{\obsT_1 = \tau \obsT_1' \hspace{.5cm} \obsT_1' \lesssim \obsT_2}
       {\obsT_1 \lesssim \obsT_2}\]

\[\frac{\obsT_2 = \tau \obsT_2' \hspace{.5cm} \obsT_1 \lesssim \obsT_2'}
       {\obsT_1 \lesssim \obsT_2}\]

\[\frac{\obsT_1 = w \obsT_1' \hspace{.5cm} \obsT_2 = w \obsT_2' \hspace{.5cm} \obsT_1' \lesssim \obsT_2'}
       {\obsT_1 \lesssim \obsT_2}\]

% Fixed by Andrew:
%\COQ{This is the same as the coq version minus a redundant case.}
    
We then define equivalence of observation traces as traces prefixing each other:
\[O_1 \simeq O_2 \triangleq O_1 \lesssim O_2 \land O_2 \lesssim O_1\]

\leo{Should we point out here the edge cases of all-tau traces?}

% Fixed by Andrew:
%    \COQ{this should be equivalent to the coq version, and we should adopt it.}
%    \leo{We had this, but it was much harder to work with for my proofs. We should still
%      prove them equivalent if we want to present it this way (which is probably cleaner for
%      presentation purposes)}

Let the predicate \(\isinf(T)\) hold when the trace $T$ is infinite.
We then define {\em policy-sensitive observational equivalence}: an
{\it MPOTrace} \(\MPT\) is equivalent to an {\it MOTrace} trace \(\machT\) if \(\MPT\)
is infinite and the observations of \(\MPT\) and \(\machT\) coincide, or if the \(\MPT\)
is finite (due to a policy fault) and its observations are a prefix of those of M.

% Fixed by Sean
%\leo{Why $\mathit{Obs}$ and not $\pi_o$ defined earlier?}
\[\frac{\neg \isinf(\MPT) \hspace{.5cm} \pi_o(\MPT) \lesssim \pi_o(\machT)}
           {\MPT \sim_P \machT}\]
    
\[\frac{\isinf(\MPT) \hspace{.5cm} \pi_o(\MPT) \simeq \pi_o(\machT)}
           {\MPT \sim_P \machT}\]
    
\section{Stack Safety, Formally}

In this section we will describe stack safety as a formal
property.
\leo{Should call maps and returns go here or in preliminaries?}

\paragraph*{Call Maps and Returns}

A {\it call map} $\callmap$ identifies machine states that represent a
call, abstracting away from the calling convention of any concrete
machine. Formally $\callmap$ is a partial map from machine states to a
natural number, the number of arguments of that call.
%
\[\callmap \in \CALLMAPS = \MACHS \rightharpoonup \mathbb{N}\]

For concreteness, in a typical calling convention, a call map may be
considered to identify the state just before the \(\JAL\), in which
space for arguments is already allocated, but the mechanism is more
general.

A state on which a call map is defined is referred to as a {\it call
  state}, and we consider the call to have returned the first time
control returns to the instruction following the \(\JAL\) with the
stack restored. Formally this is a relation between the states:
    
\[\begin{split}
\ret{\mach_c}\ \mach_r \triangleq & \mach_r(\PCname) = \nextPC(\mach_c(\PCname)) \land \\
& \mach_r(\SP) = \mach_c(\SP)
\end{split}\]

\leo{How do we initialize the first policy state based on a call map? It's not
  part of the policy. Do we parameterize policies?}

\paragraph*{Stack safety}
  
A stack safety property is a property of a transition system, a
policy, and a callmap that is decomposed into an integrity property and a
confidentiality property.

    \[\begin{split}
      \textit{stack safety} \triangleq \textit{stack integrity} \land \textit{stack confidentiality} \\
    \end{split}\]

\leo{TODO: Rephrase from introduction} Informally, {\it Stack
  integrity} states that if a function call returns, the caller's
private stack data will be identical to what it was before the
call. {\it Stack confidentiality} states that data outside a callee's
stack frame is secret, and do not interfere with its observable
behavior or with the machine state at return.

As is standard with security properties, we associate with each
component of the machine a {\em label}: a pair of security levels
denoting high or low confidentiality and high or low integrity.
%
\[\mathit{label} ::= \{\HIGHSEC,\LOWSEC\} \times \{\HIGHINT,\LOWINT\}\]
%
Since we need to enforce integrity and confidentiality at {\em every}
function call in a trace, we must treat the security level of data
dynamically. To that end, we introduce the notion of a {\em contour},
a map from components to labels:
%
\[\contour \in \CONTOURS ::= \COMPONENTS \rightarrow \mathit{label}\]

\leo{What about instructions? Shouldn't they be LC/HI?}
When \(\mpstate{\mach}{\pol}\) is a call state \(\callmap(\mach) = n\)
for some \(n\), we can construct a contour based on the bounds of the
callee's stack frame, as follows:
\leo{Should the first two cases have a $k \not \in \REGS$?}
\[\mathit{Cof}(\mach,n)(\component) =
\begin{cases}
  (\HIGHSEC,\HIGHINT) & \text{if } \component \leq \mach(\SP) - n \\
  (\HIGHSEC,\LOWINT) & \text{if } \component \geq \mach(\SP) \\
  (\LOWSEC,\LOWINT) & \text{else} \\
\end{cases}\]
%
The private state of the callee is the entire area of the memory below
the stack pointer, with the exception of the $n$ locations
corresponding to the arguments of a call. These components are tagged
high confidentiality and high integrity: the callee should be able to
neither read, nor write them.
%
Everything above the stack pointer at the point of the call is
``uninitialized'' memory that can be written into but should not be
read. To protect the callee itself from such reads, these components
are marked high confidentiality and low integrity.
%
Registers and the frame of arguments to the callee are free for the
callee to use, and are therefore tagged with low integrity and low
confidentiality. 

\leo{Shouldn't this be a definition instead of a paragraph?}
%\paragraph{Integrity}

\definition{Stack Integrity}

A system satisfies integrity with respect to a callmap \(\callmap\)
if for any initial mpstate \(\mpstatename =
\mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\) and each call state
\(\mpostate{\mach_c}{\pol_c}{\_}\) in the induced trace from \(\mpstatename\)
where \(\callmap(\mach_c) = n\), if we take the prefix from
\(\mpstate{\mach_c}{\pol_c}\) until \(\ret{\mach_c}\) holds on some
\(\mach_p\), \(\mach_p\) matches \(\mach_c\) on each component whose integrity
in \(\mathit{Cof}(\mach_c,n)\) is \(\HIGHINT\).

\definition{Stack Confidentiality}

A system enjoys eager stack confidentiality with respect to a callmap
\(\callmap\) if, for any initial state \(\mpstatename =
\mpstate{\mach_0}{\mathit{pinit}(\mach_0,cm)}\), for each call state
\(\mpostate{\mach_c}{\pol_c}{\_}\) in the induced trace from \(\mpstatename\)
where \(\callmap(\mach_c) = n\) and each variant \(\mach_c'\) such that
\(\mach_c \approx_\contour \mach_c'\) for \(\contour = Cof(\mach_c, n)\),
one of two cases holds.

If the trace from the call reaches a return -- \(\mpstate{\mach_c}{\pol_c}
\hookrightarrow_P \MPT \mpostate{\mach_r}{\pol_r}{\_} | \ret{\mach_c}\) --
then the trace from the variant \(\mach_c'\) reaches a return --
\(\mach_c' \hookrightarrow \machT (\mach_r',\_) | \ret{\mach_c}\).
\(\MPT\) and \(\machT\) are observationally equivalent, \(\pi_o(\MPT) \eqsim
\pi_o(\machT)\). For any component \(\component\) that changed between
\(\mach_c\) and \(\mach_r\), or between \(\mach_c'\) and \(\mach_r'\),
\(\mach_r\) agrees with \(\mach_r'\) on \(\component\).

If the trace from the call never reaches a return, neither does the
trace from the variant. Then if \(\mpstate{\mach_c}{\pol_c} \hookrightarrow_P
\MPT\) and \(\mach_c' \hookrightarrow \machT\), \(\MPT \sim_P \machT\).

      \leo{Think more about whether we vary mc or step mc}
      \leo{Also, words}

\section{Discussion}

\bcp{Illustrate the definition by using it to discuss a range of ``stack
  unsafety'' examples from the literature. }

\section{Lazy Stack Safety}

    \paragraph{Observable Integrity}

      Observable integrity is concerned with the changes a callee makes to high integrity components,
      and the effects those writes have on the observable behavior of its caller
      {\it after its return}. Given a contour, a call state, and a returned state, we define
      a ``rollback'' function \(\mathit{roll}_I : \CONTOURS \times \MACHS \times \MACHS
      \rightarrow \MACHS\). The rollback creates a state that matches the call
      state on those components that are high integrity in its contour, and matches the return state
      on low integrity components:

      \[\mathit{roll}_I(\contour,\mach_c,\mach_r)(\component) =
      \begin{cases}
        \mach_c(\component) & \contour(\component) = (\HIGHINT,\_) \\
        \mach_r(\component) & \contour(\component) = (\LOWINT,\_) \\
      \end{cases}\]

      Intuitively, the result of a rollback is an idealized state that reflects changes to accessible
      components, but ignores the callee's interference with the caller's data. Then the observable
      behavior of the resulting trace is the standard to which we expect any real trace to conform.

      A system enjoys observable integrity with regard to \(\callmap\) as follows:

      For any initial state \(\mach_0\), call state \(\mach_c\), and policy state \(\pol_c\) such that
      \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)} \hookrightarrow ... \mpostate{\mach_c}{\pol_c}{\_} ...\)
      and \(\callmap(\mach_c) = n\), if \(\mpstate{\mach_c}{\pol_c} \hookrightarrow ...
        \mpostate{\mach_r}{\pol_r}{\_} | \ret{\mach_c}\):

          \begin{itemize}
            \item Let \(\contour = \mathit{Cof}(\mach_c,n)\)
            \item Let \(\mach_r' = \mathit{roll}_I(\contour,\mach_c,\mach_r)\), \(\mpstate{\mach_r}{\pol_r}
              \hookrightarrow \MPT\), and \(\mach_r' \hookrightarrow \machT'\)
            \item \(\MPT \sim_P \machT'\)
          \end{itemize}
    

      
    \paragraph{Observable Confidentiality}

      Observable confidentiality is concerned with whether high confidentiality data influences
      observable both behavior during and after a call. We define variants given the generalized notion
      of contours:
      \[\mach \approx_\contour \mach' \triangleq \forall \component .
      \contour(\component) = \LOWSEC \rightarrow \mach(\component) = \mach'(\component)\]
      \leo{Move earlier}

      Data that is high confidentiality within a callee due either to being in its caller's frame
      will become low confidentiality if the callee returns.\leo{??} We face a subtle distinction: 
      a callee treats the contents of its caller's frame as secrets, and they should not influence
      its behavior. Nor should the callee be able to influence behavior after its return based
      on the caller's secrets, for instance by copying them to registers that will later be output.
      But the caller itself may still adjust its behavior based on its own secrets. So our property
      relies on another rollback function to preserve changes made by the caller but remove other
      differences between variant states.

      In this case, a confidentiality rollback takes a contour and four states: two call states
      that will be variants, and two return states. It is not symmetric, regarding \(\mach_c\) and \(\mach_r\)
      as the ``real'' call and return, \(\mach_c'\) as a variant and \(\mach_r'\) as a return that follows it.
      \[\begin{split}
        & \mathit{roll}_C(\contour,\mach_c,\mach_c',\mach_r,\mach_r')(\component) = \\
        & \begin{cases}
          \mach_c(\component) & \text{if } C(\component) = \HIGHSEC \text{ and } \\
                  & \mach_c(\component) = \mach_r(\component) \text{ and }
                    \mach_c'(\component) = \mach_r'(\component) \\
          \mach_r'(\component) & \text{else} \\
        \end{cases}
      \end{split}\]
      \leo{Maybe this should be called unscramble}

      A system enjoys observable confidentiality with respect to \(\callmap\) as follows:

      For any initial state \(\mach_0\), call state \(\mach_c\), and policy state \(\pol_c\) such that
      \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)} \hookrightarrow ... \mpostate{\mach_c}{\pol_c}{\_} ...\) and
      \(\callmap(\mach_c) = n\):

      \begin{itemize}
        \item Let \(\contour = \mathit{Cof}(\mach_c,n)\)
        \item For all \(\mach_c'\) such that \(\mach_c \approx_C \mach_c'\):
        \item If \(\mpstate{\mach_c}{p_c} \hookrightarrow \MPT_1 \mpostate{\mach_r}{\pol_r}{\_} | \ret{\mach_c}\)
          \begin{itemize}
            \item Then there is some \(\mach_r'\) where

              \(\mach_c' \hookrightarrow \machT_1' (\mach_r',\_) | \ret{\mach_c'}\)
            \item Let \(\mach_r'' = \mathit{roll}_C(\contour,\mach_c,\mach_r,\mach_c',\mach_r')\),

              \(\mpstate{\mach_r}{p_r} \hookrightarrow \MPT_2\), and \(\mach_r'' \hookrightarrow \machT_2'\)
            \item \(\MPT_1 \cdot \MPT_2 \sim_P \machT_1' \cdot \machT_2'\)
          \end{itemize}
        \item Else, for \(\MPT\) and \(\machT'\) such that \(\mpstate{\mach_c}{\pol_c} \hookrightarrow \MPT\)
          and \(\mach_c' \hookrightarrow \machT'\), \(\MPT \sim_P \machT'\)
      \end{itemize}

      \leo{Need to fix append. Maybe call it join. It should remove the last
        state of left arg}

\section{Future Work}

We've assumed that callees always have less access than their callers, but
in real systems things are more complicated (because of objects, static
variables in C, software compartmentalization, coroutines, ...).  What we've
defined is a very ``pure'' variant of stack safety.  In future work, we
should go further. :-)


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
%\bibliography{bibfile}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
