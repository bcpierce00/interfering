\documentclass[conference]{IEEEtran}
\newif\ifdraft \drafttrue
\newif\iftext \draftfalse

\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand{\bcp}[1]{\ifdraft\textcolor{violet}{{[BCP:~#1]}}\fi}


\begin{document}

\title{Interfering with Noninterference
\iftext\thanks{\bcp{Identify applicable funding agencies here (DARPA and NSF
    and...?)}}\fi
}

\iftext
\author{\IEEEauthorblockN{Roberto Blanco}
\IEEEauthorblockA{\textit{\bcp{affiliation?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
\and
\IEEEauthorblockN{Leonidas Lampropoulos}
\IEEEauthorblockA{\textit{University of Maryland \bcp{right?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\IEEEauthorblockN{Benjamin C. Pierce}
\IEEEauthorblockA{\textit{University of Pennsylvania}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\IEEEauthorblockN{Andrew Tolmach}
\IEEEauthorblockA{\textit{Portland State University}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
}
\fi

\maketitle

\iftext
\begin{abstract}
\end{abstract}

\begin{IEEEkeywords}
% component, formatting, style, styling, insert
\end{IEEEkeywords}
\fi

\section{Preliminaries}

\begin{itemize}
\item (A sketch of) the RISC-V machine model and operational semantics.
\item Reminder of the standard definition of NI.

\bcp{Write it!}

Designate sets of private and public addresses.

Begin by defining what it means for two traces to witness interference?

\item Fact: The standard RISC-V semantics does not guarantee NI.  (Give a
little example of a program that reads from a secret location and writes to
a public one, just to illustrate the definition of NI.)
\end{itemize}

\section{Tainting is (a bit less than) noninterference}

\begin{itemize}
\item First intuition: A program is taint-NI if every pair of runs that don’t
branch on high data are noninterfering in the standard sense.  (i.e., they
don't write secret data to public locations and vice versa)
\item Better alternative: … for every pair of runs that take the same control path (even if they branch on tainted data)...
\item \bcp{We could even go a step farther: {\em truncate} the runs at the
  first point where their PCs differ, then demand NI.}
\end{itemize}

\section{Stack protection is (a bit more than) noninterference}

Formal definition.

\iftext
\section{Stack + heap protection too}

POTENTIALLY: Memory safety (before stack) + Conjunction of memory + stack
safety (after).

(Memory safety by itself is just arthur’s paper, but it’s cool to see how
they are combined, especially what bits can be factored out as common
structure, e.g. the notion of accessibility)
\fi

\section{Implementation}

Sketch of the micropolicies that claim to implement these properties on
PIPE...

\subsection{A taint checking monitor}

\subsection{A stack safety monitor}

\section{Testing the implementations}

\begin{itemize}
\item Experimental results of testing
\end{itemize}

\section{Related work}

\begin{itemize}
\item Daniel's tainting paper (and some refs cited there)
\item Nick and Andre's papers (and other micropolicy papers)
\item StkTokens: Skorstengaard, Devriese, Birkedal
\begin{itemize}
\item {https://arxiv.org/pdf/1811.02787.pdf}
\item {https://arxiv.org/pdf/1902.05283.pdf}
\item {http://cs.au.dk/~lask/papers/esop2018.pdf}
\end{itemize}


\item Mechanized Reasoning about a Capability Machine: [Linn] Georges,
Trieu, Birkedal (PriSC 2020).
%
Described at the Iris Workshop as formalizing the security properties of
capabilities. This appears to involve a fairly complex and very large
mechanization in Iris (also in the eyes of the Iris people).
\end{itemize}

\iftext
\section{Future work}

\begin{itemize}
\item Variations / extensions (OS, multiple processes, coroutines, generalizing depths to stacks of static call points, etc.)
\item Extending the policy / property to more realistic ones
\begin{itemize}
\item Argument passing
\item Variable-size stack frames
\item Stack variables
\item Relation to Nick and Andre’s policy
\end{itemize}
\item Could we also implement all this using Cheri capabilities?
\end{itemize}

More:
\begin{itemize}
\item More realistic calling conventions.  (We need to eventually match this to the particular calling convention of whatever compiler we choose.)  E.g., the above will not quite work for passing arguments on the stack: callee won’t be able to read them…So perhaps need to support a special kind of write instruction that stores D.PCdepth+1 . [RB: Or implement this distinction through tags?]
\item Combination with heap policy (colors, etc.)
\item For coroutines:
\begin{itemize}
\item Generalize depth to depth + PID
\item Private stuff not having changed as an idea should still work
\item Maybe not so hard: The scheduler + other coroutines are just a sort of generalized “callee” as far as this process is concerned.  Just need to fiddle th step relation so that it recognizes which process is getting returned to and updates its description appropriately.
\end{itemize}
\item If we had a heap policy, maybe we could talk about dynamic code generation, loading, as allocating a heap region, storing instructions into it, and then calling into them.  For now, we just make all the instructions read only and assume they exist in the initial state.
\item Question: how efficiently can consistency be tested? How much scrambling is needed, and does it really need to occur before every instruction? How expensive is it to check for agreement between the (in)accessible parts of two memories?  Would spot checking for agreement be adequate?]
\item What are the effects of compartmentalization on the ability of each compartment to change its own code/stack?
\item Tail calls (maybe by not marking them as call sites?)
\end{itemize}

\section*{Acknowledgments}
\fi

\section*{References}
\bibliographystyle{IEEEtran}
\bibliography{bcp,local}

\newpage

\section*{Things to think about}

\begin{itemize}
\item
How does Nick’s stack policy actually work these days?
\item Andrew remembers that Catalin looked at something like this a long time ago and they decided that they needed unique tags for each dynamic call, not just levels.  We should check.
\end{itemize}

\end{document}
