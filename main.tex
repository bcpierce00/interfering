%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\input{macros}

\begin{document}

%% Title information
\title{Stack Safety as a Security Property}         %% [Short Title] is optional;
                                        %% when present, will be used in
v                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
%\author{First1 Last1}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
%  \institution{Institution1}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{Country1}                    %% \country is recommended
%}
%\email{first1.last1@inst1.edu}          %% \email is recommended
%
%%% Author with two affiliations and emails.
%\author{First2 Last2}
%\authornote{with author2 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position2a}
%  \department{Department2a}             %% \department is recommended
%  \institution{Institution2a}           %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
%  \country{Country2a}                   %% \country is recommended
%}
%\email{first2.last2@inst2a.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Stack Safety, Micropolicy, Random Testing, RISC-V}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}
 
\newcommand*{\MemoryLabel}[3]{\raisebox{#2}{\makebox(0,0){\hspace{#1}#3}}}
 
%\begin{figure}
%  \begin{minipage}{\textwidth}
%    \begin{center}
%\MemoryLabel{10em}{1.5em}{40}
%\MemoryLabel{16em}{1.5em}{60}
%\MemoryLabel{22em}{1.5em}{80}
%$\cdots$
%\memory{4}{gray}%
%\memory{5}{green}[{\makebox[0pt]{Caller}}]%
%\memory{5}{yellow}[{\makebox[0pt]{Args}}]%
%\memory{8}{red}[{\makebox[0pt]{Callee}}]%
%\memory{4}{gray}%
%~$\cdots$\\
%  \end{center}
%  \end{minipage}\\
%~\\
%~\\
%  \begin{minipage}{0.45\textwidth}
%    \begin{center}
%\begin{verbatim}
%jal ...
%lw r1 r0 40
%\end{verbatim}
%    \end{center}
%  \end{minipage}~
%  \begin{minipage}{0.45\textwidth}
%    \begin{center}
%\begin{verbatim}
%jal ...
%sw r0 r0 40
%\end{verbatim}
%    \end{center}
%  \end{minipage}
%  \caption{Examples of Unsafe Programs\bcp{The numbers don't line up with
%      the boxes; the program fragments need comments explaining what each
%      line does.}}
%  \label{fig:stackunsafety}
%\end{figure}
% 
%\leo{I hate the writing here, but I wanted to make a start.}

The call stack is a perennially popular target for attacks
exploiting memory safety vulnerabilities, with potential consequences
ranging from leakage or corruption of private stack data to
hijacking of the program's control flow. To prevent such attacks, many
software and hardware techniques for stack safety have been proposed, % in the literature and implemented in production systems,
including stack canaries~\citep{Cowan+98},
shadow stacks~\citep{Dang+15,Shanbhogue+19},
split stacks~\citep{Kuznetsov+14},
bounds checking~\citep{NagarakatteZMZ09,NagarakatteZMZ10,DeviettiBMZ08},
capabilities~\citep{Woodruff+14,Chisnall+15,Skorstengaard+19,Skorstengaard+19b},
and hardware tagging~\citep{DBLP:conf/sp/RoesslerD18}. \apt{Mostly from nick;there could be more}

But what {\em is} this ``stack safety'' of which we speak? Precise formal
definitions are lacking in the literature; instead, the notion of safety
is usually defined negatively, by enumerating the bad things that a safe system
prevents, such as corruption of return addresses, buffer overflows, or
use of uninitialized variables.
%with the notion usually being
%defined negatively: through examples of stack-based exploits 
%\rb{usually though not always; as noted below there are other
%  approaches}\bcp{Yes, we have to be very careful about this}.
%\leo{Examples at a high level}: such as -- does not overwrite return addresses, or ... 
We are only aware of one, quite recent, attempt to frame a positive definition.
\citet{Skorstengaard+19} define stack safety as
the conjunction of two properties, local state encapsulation and well-bracketed control flow.
They formalize these properties by defining an abstract capability-based machine   
that ``satisfies [stack safety] by construction.'' We believe there is still room
to craft a more abstract and less intensional characterization of
stack safety, and that is the goal of the present paper. \apt{still needs tuning}

Our approach is to give alternative formal
definitions of local state encapsulation and well-bracketed control flow
using the conceptual framework of language-based security.
%
The underlying notion behind local state encapsulation is the
intention to protect callers from callees: a callee should be not be
able to access or overwrite a caller's private data. We formalize this
intuition as a security property with both confidentiality and
integrity components.
%
Intuitively, {\em stack confidentiality} promises that a callee's
observable behavior is not affected by memory outside its stack frame
(e.g. a caller's private data or uninitialized memory).  {\em Stack
  integrity} guarantees that, if a function call ever returns, the caller's
stack data at the point of return will be identical to what it was before
the call.  \bcp{We need to point out somewhere that we are only dealing with
stack safety, though we discuss (somewhere) how our property can be combined
with the heap safety property of [Azevedo et al]}

% BCP idea: contrast intrinsic vs. extrinsic property definition
% Remember to talk about spatial vs temporal safety 

While integrity and confidentiality are standard security
properties, applying them in the stack-safety setting raises a novel challenge:
the notion of ``attacker'' changes during execution. Not only
does a caller need to be protected from its callee, but the callee
itself needs to be protected from {\em its} callees.
We address this challenge by adjusting the integrity and confidentiality
of different stack frames at each call or return transition between functions.\apt{connection to ``attacker'' still vague.}

The underlying notion behind well-bracketed control flow is
the need to protect the call structure itself: a callee should not be
allowed to jump to the middle of an arbitrary block of code either
directly (via a jump instruction) or indirectly (by corrupting stack
data and returning). Well-bracketed control flow establishes safety between
functions: each instruction is uniquely owned by some function, and all jumps between functions
are either calls that enter at a marked entry point or returns that re-enter
just after their associated call in the standard nested call structure.
\apt{clarify what we are contributing here.}

To provide evidence that our definitions capture the inituitive notion of stack safety,
we show that they rule out a wide \apt{really?} range of exploitable bad behaviors.\apt{``from the literature''??}
To assess whether they are implementable, 
we compare them against the proposed capability-based enforcement
mechanism of \citet{Skorstengaard+19} \apt{we really should} and the existing tag-based enforcement mechanism
of \citet{DBLP:conf/sp/RoesslerD18}.

In summary, we offer the following contributions:
\begin{itemize}
\item
  % \leo{More? Extensional}\bcp{We might need to invent a word for   this---''quasi-extensional''?}
  Abstract formal properties capturing the 
  intuitive concepts of local state encapsulation and well-bracketed
  control flow~(\Cref{sec:lse-and-wbcf}) in a very general setting. These properties
  rule out common examples of stack memory abuse.
\item
  A case study of the Depth Isolation policy of \citet{DBLP:conf/sp/RoesslerD18}, based on hardware tags~(\Cref{sec:enforcement}).
  This policy enforces our stack safety property, and also a (provably) stronger property that is easier to test.
  \apt{If we have no testing, do we even want to talk about the testing property?}
\item
  A refinement of the case study that considers the more efficient Lazy Tagging and Clearing policy 
  of \citet{DBLP:conf/sp/RoesslerD18}~(\Cref{sec:lazy}).  This policy does not enforce our property, but we give a
  variant of the policy that does enforce a (provably) weaker variant of our property. \apt{Awkward, but the truth I fear.}

  %\item As evidence that the property is not too strong\apt{But we add the lazy version because the strict version \emph{is} too strong, in some sense.}, we show that it is
%  realizible by
%  a previously proposed micropolicy enforcement
%  mechanism~(\Cref{sec:micropolicy}). \leo{And it says yes on a
%    substantial body of code}. We also present a variation of the
%  property + policy that is lazy, easier/more efficient to implement,
%  and provably weaker (\Cref{sec:lazy}).
%\item A provably stronger (inductive? step-by-step/stepwise) variant
%  of this property tuned for testing/verification.  We test the whole
%  thing with a cool framework. \bcp{Which section?}
\end{itemize}
Section~\ref{sec:relwork} discusses related work, and
Section~\ref{sec:future} sketches directions for future work.
%
We begin with a running example that we refer
to throughout the paper (Section~\ref{sec:running-example}) and some
technical preliminaries (Section~\ref{sec:prelim}).

\section{Running Example}
\label{sec:running-example}

To help keep things concrete throughout the more technical sections
that follow, we first introduce a running example. We will
use it to demonstrate various potentially problematic
behaviours in this section, and then show how our properties and
enforcement mechanisms preclude them later on in the paper.

The program appears in Figure~\ref{fig:running-program}. It consists
of a {\tt main} function that performs a call to some function {\tt
  f}, which in turns makes a nested call to some function {\tt g}
before returning, all while performing some simple arithmetic
in the process.

\begin{figure}[b]
  \begin{centering}
    \begin{minipage}{.3\textwidth}
\begin{verbatim}
main = {
  int x = 42, y = 0;
  y = g(0);
  print (x + y);
}
\end{verbatim}
    \end{minipage}
    \begin{minipage}{.3\textwidth}
\begin{verbatim}
g(z) = {
  int w = h(17);
  print z;
  return (z + w);
}
\end{verbatim}
    \end{minipage}
    \begin{minipage}{.3\textwidth}
\begin{verbatim}
h(v) = {
  return (v + 1);
}


\end{verbatim}
    \end{minipage}
\end{centering}
\caption{High-level Program with Simple Nested Calls}
\label{fig:running-program}
\end{figure}


\newcommand*{\add}{\textsc{add}}
\newcommand*{\addi}{\textsc{addi}}
\newcommand*{\sw}{\textsc{sw}}
\newcommand*{\lw}{\textsc{lw}}
\newcommand*{\jal}{\textsc{jal}}
\newcommand*{\jalr}{\textsc{jalr}}
\newcommand*{\rsp}{\textsc{sp}}
\newcommand*{\rra}{\textsc{ra}}
\newcommand*{\rout}{\textsc{out}}

\newcounter{pcctr}
\setcounter{pcctr}{0}
\newcommand*{\row}[4]{
  \thepcctr & \stepcounter{pcctr} #1 & #2 & #3 & \text{#4}\\
}
\newcommand*{\tracerow}[5]{
  #1 & #2 & #3 & #4 & \text{#5}\\
}
\newcommand*{\summary}[6]{
\[
\begin{array}{cccccc}
  \PCname = #1 & r_0 = #2 & \rra = #3 & \rsp = #4 & r_4 = #5 & r_5 = #6
\end{array}
\]
}    
\newcommand{\negate}{\textrm{-}}

\begin{figure}

%Starting Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{25em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
\memory{10}{gray}[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\\
\end{center}
% Starting Register File
\summary{0}{0}{?}{100}{?}{?}
\vspace*{0.2em}
\[
  \begin{array}{c|c|c|c|c}
    PC & \mathit{Instruction} & \mathit{Description} & \mathit{Effect} & \\
    \hline
    \row{\addi ~ \rsp ~ \rsp ~ 2}{\rsp \leftarrow \rsp + 2}{\rsp \leftarrow 102}
        {Allocate private {\tt main} data}
    \row{\addi ~ r_4 ~ r_0 ~ 42}{r_4 \leftarrow r_0 + 42}{r_4 \leftarrow 42}
        {Put 42 in $r_4$}
    \row{\sw ~ \rsp ~ r_4 ~ \negate 2}{[\rsp-2] \leftarrow r_4}{[100] \leftarrow 42}
        {Set {\tt x} to 42}
    \row{\sw ~ \rsp ~ r_0 ~ \negate 1}{[\rsp-1] \leftarrow r_0}{[101] \leftarrow 0}
        {Set {\tt y} to 0}
    \row{\addi ~ \rsp ~ \rsp ~ 2}{\rsp \leftarrow \rsp + 2}{\rsp \leftarrow 104}
        {Allocate {\tt g}'s call frame}
    \row{\sw ~ \rsp ~ r_0 ~ \negate 2}{[\rsp-2] \leftarrow r_0}{[102] \leftarrow 0}
        {Set argument to 0}
    \row{\sw ~ \rsp ~ r_0 ~ \negate 1}{[\rsp-1] \leftarrow r_0}{[103] \leftarrow 0}
        {Zero out result\apt{why?}}
    \row{\jal ~ \rra ~ 20}{??}{\PCname \leftarrow 20; ~ \rra \leftarrow \thepcctr}
        {Make the call}
  \end{array}
  \]
  ~ \\
  ~\\
% At Call to G
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{43.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
\memory{2}{green}[{\makebox[0pt]{${\texttt main}_{priv}$}}]%
\memory{2}{green}[{\makebox[0pt]{{\tt g}'s call frame }}]%
\memory{6}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{0}
\\
\end{center}
% Starting Register File
\summary{20}{0}{\thepcctr}{104}{42}{?}
%\vspace*{0.2em}
\setcounter{pcctr}{20}%
% G - Body - 1
\vspace*{0.2em}
\[
  \begin{array}{c|c|c|c|c}
    \row{\addi ~ \rsp ~ \rsp ~ 2}{\rsp \leftarrow \rsp + 2}{\rsp \leftarrow 106}
        {Allocate local {\tt g} state}
    \row{\sw ~ \rsp ~ \rra ~ \negate 2}{[\rsp - 2] \leftarrow \rra}{[104] \leftarrow 8}
        {Store return address}
    % Zero out z?
    \row{\addi ~ \rsp ~ \rsp ~ 2}{\rsp \leftarrow \rsp + 2}{\rsp \leftarrow 108}
        {Allocate for call frame}
    \row{\addi ~ r_4 ~ r_0 ~ 17}{r_4 \leftarrow r_0 + 17}{r_4 \leftarrow 17}
        {Store 17 to $r_4$}
    \row{\sw ~ \rsp ~ r_4 ~ \negate 2}{[\rsp - 2] \leftarrow r_4}{[106] \leftarrow 17}
        {Store 17 as the argument {\tt v}}
    \row{\sw ~ \rsp ~ r_0 ~ \negate 1}{[\rsp - 1] \leftarrow r_0}{[107] \leftarrow 0}
        {Zero out result}
    \row{\jal ~ \rra ~ 40}{??}{PC \leftarrow 40; ~ \rra \leftarrow \thepcctr}
        {Make the call to {\tt h}}
  \end{array}
  \]
  ~ \\
  ~ \\
% At Call to H
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{61.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
\memory{2}{green}[{\makebox[0pt]{${\texttt main}_{priv}$}}]%
\memory{2}{green}[{\makebox[0pt]{{\tt g}'s call frame }}]%
\memory{2}{yellow}[{\makebox[0pt]{${\texttt g}_{priv}$}}]%
\memory{2}{yellow}[{\makebox[0pt]{{\tt h}'s call frame }}]%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{0}
\MemoryLabel{-30.5em}{0.75em}{8}
\MemoryLabel{-26.5em}{0.75em}{}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-18.5em}{0.75em}{0}
\\
\end{center}
% Starting Register File
\summary{40}{0}{\thepcctr}{108}{17}{?}
\setcounter{pcctr}{40}
\vspace*{0.2em}
% H - Body
\[
\begin{array}{c|c|c|c|c}
  \row{\addi ~ \rsp ~ \rsp ~ 1}{\rsp \leftarrow \rsp + 1}{\rsp \leftarrow 109}
      {Allocate for return address}
  \row{\sw ~ \rsp ~ \rra ~ \negate 1}{[\rsp - 1] \leftarrow \rra}{[108] \leftarrow 27}
      {Store return address}
  \row{\lw ~ r_4 ~ \rsp ~ \negate 3}{r_4 \leftarrow [\rsp - 3]}{r_4 \leftarrow 17}
      {Load the argument {\tt v} to $r_4$}
  \row{\addi ~ r_4 ~ r_4 ~ 1}{r_4 \leftarrow r_4 + 1}{r_4 \leftarrow 18}
      {Increment $r_4$ by 1}\end{array}
\]
~\\
~\\
% At Middle of H
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{65.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
\memory{2}{green}[{\makebox[0pt]{${\texttt main}_{priv}$}}]%
\memory{2}{green}[{\makebox[0pt]{{\tt g}'s call frame }}]%
\memory{2}{yellow}[{\makebox[0pt]{${\texttt g}_{priv}$}}]%
\memory{2}{yellow}[{\makebox[0pt]{{\tt h}'s call frame }}]%
\memory{1}{red}%[{\makebox[0pt]{{\texttt h} ra}}]
\memory{1}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{0}
\MemoryLabel{-30.5em}{0.75em}{8}
\MemoryLabel{-26.5em}{0.75em}{}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-18.5em}{0.75em}{0}
\MemoryLabel{-14.5em}{0.75em}{27}
\\
\end{center}
% Register File
\summary{40}{0}{\thepcctr}{109}{18}{?}
\vspace*{0.2em}
\label{fig:running-trace-a}
\end{figure}

\begin{figure}
\[
\begin{array}{c|c|c|c|c}
  \row{\sw ~ \rsp ~ r_4 ~ \negate 2}{[\rsp - 2] \leftarrow r_4}{[107] \leftarrow 18}
      {Store $r_4$ as the return value}
  \row{\lw ~ \rra ~ \rsp ~ \negate 1}{\rra \leftarrow [\rsp - 1]}{\rra \leftarrow 31}
      {Load return address}
  \row{\addi ~ \rsp ~ \rsp ~ \negate 1}{\rsp \leftarrow \rsp - 1}{\rsp \leftarrow 108}
      {Restore the stack pointer of {\tt g}}
  \row{\jalr ~ \rra ~ \rra ~ 0}{??}{PC \leftarrow 31}
      {Return to {\tt g}}
  \end{array}
\]
  
% After Return from H
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{61.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
\memory{2}{green}[{\makebox[0pt]{${\texttt main}_{priv}$}}]%
\memory{2}{green}[{\makebox[0pt]{{\tt g}'s call frame }}]%
\memory{2}{yellow}[{\makebox[0pt]{${\texttt g}_{priv}$}}]%
\memory{2}{yellow}[{\makebox[0pt]{{\tt h}'s call frame }}]%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{0}
\MemoryLabel{-30.5em}{0.75em}{8}
\MemoryLabel{-26.5em}{0.75em}{}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-18.5em}{0.75em}{18}
\\
\end{center}
% Starting Register File
\summary{27}{0}{\thepcctr}{108}{18}{?}
\vspace*{0.2em}

\setcounter{pcctr}{27}
% H - Body
\vspace*{0.2em}
\[
\begin{array}{c|c|c|c|c}
  \row{\lw ~ r_4 ~ \rsp ~ 0}{r_4 \leftarrow [\rsp]}{r_4 \leftarrow 18}
      {Load return value to $r_4$}
  \row{\sw ~ \rsp ~ r_4 ~ \negate 3}{[\rsp - 3] \leftarrow r_4}{[105] \leftarrow 18}
      {Set {\tt w} to 18}
  \row{\addi ~ \rsp ~ \rsp ~ \negate 2}{\rsp \leftarrow \rsp - 2}{\rsp \leftarrow 106}
      {Deallocate {\tt h}'s call frame}
  \row{\lw ~ r_5 ~ \rsp ~ \negate 6}{r_5 \leftarrow [\rsp - 6]}{r_5 \leftarrow 0}
      {Load argument {\tt z} $r_5$}
  \row{\sw ~ \rout ~ r_5 ~ 0}{[\rout] \leftarrow r_5}{[99] \leftarrow 0}
      {Print {\tt z}}      
  \row{\add ~ r_4 ~ r_4 ~ r_5}{r_4 \leftarrow r_4 + r_5}{r_4 \leftarrow 18}
      {Add $r_4$ and $r_5$}
  \row{\sw ~ \rsp ~ r_4 ~ \negate 3}{[\rsp - 3] \leftarrow r_4}{[103] \leftarrow 18}
      {Store $r_4$ as ther return of {\tt g}}
  \row{\lw ~ \rra ~ \rsp ~ \negate 2}{\rra \leftarrow [\rsp - 2]}{\rra \leftarrow 8}
      {Load return address}
  \row{\addi ~ \rsp ~ \rsp ~ \negate 2}{\rsp \leftarrow \rsp - 2}{\rsp \leftarrow 104}
      {Deallocate {\tt g}'s local state}
  \row{\jalr ~ \rra ~ \rra ~ 0}{??}{PC \leftarrow 8}{Return to {\tt main}}
\end{array}
\]
% Return to main
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{43.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
\memory{2}{green}[{\makebox[0pt]{${\texttt main}_{priv}$}}]%
\memory{2}{green}[{\makebox[0pt]{{\tt g}'s call frame }}]%
\memory{6}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-51em}{0.75em}{0}
\MemoryLabel{-47em}{0.75em}{42}
\MemoryLabel{-43em}{0.75em}{0}
\MemoryLabel{-39em}{0.75em}{0}
\MemoryLabel{-35em}{0.75em}{18}
\\
\end{center}
% Register File
\summary{8}{0}{\thepcctr}{104}{18}{0}
%\vspace*{0.2em}
\setcounter{pcctr}{8}
\[
\begin{array}{c|c|c|c|c}
  \row{\lw ~ \rsp ~ r_4 ~ \negate 1}{r_4 \leftarrow [\rsp - 1]}{r_4 \leftarrow 18}
      {Load return value to $r_4$}
  \row{\sw ~ \rsp ~ r_4 ~ \negate 3}{[\rsp - 3] \leftarrow r_4}{[101] \leftarrow 18}
      {Set {\tt y} to the result}
  \row{\addi ~ \rsp ~ \rsp ~ \negate 4}{\rsp \leftarrow \rsp - 2}{\rsp \leftarrow 102}
      {Deallocate {\tt g}'s call frame}
  \row{\lw ~ \rsp ~ r_5 ~ \negate 2}{r_5 \leftarrow [\rsp - 2]}{r_5 \leftarrow 42}
      {Load {\tt x} to $r_5$}
  \row{\add ~ r_4 ~ r_4 ~ r_5}{r_4 \leftarrow r_4 + r_5}{r_4 \leftarrow 60}
      {Add {\tt x} and {\tt y}}
  \row{\sw ~ \rout ~ r_4 ~ 0}{[\rout] \leftarrow r_4}{[99] \leftarrow 60}
      {Print {\tt x + y}}
\end{array}
\]
\vspace*{0.2em}
% Return to main
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{31.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
\memory{2}{green}[{\makebox[0pt]{${\texttt main}_{priv}$}}]%
\memory{8}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-51em}{0.75em}{60}
\MemoryLabel{-47em}{0.75em}{60}
\MemoryLabel{-43em}{0.75em}{42}
\\
\end{center}
% Starting Register File
\summary{\thepcctr}{0}{37}{102}{60}{42}
\caption{Detailed Execution Trace
  \rb{A suggestion for the description of $\jal$ and $\jalr$:
    call(function label) [if labels are added next to the entrypoints]
    or call(address of entrypoint) and return()?}
}
\label{fig:running-trace-b}
\end{figure}

To show a trace of the execution of this program, we need
a low-level view of both the code and the machine it runs on. While
our concrete implementation (Section~\leo{cite}) operates on a full
conventional RISC-V architecture, we make a few simplifying
assumptions here to ease the exposition. 

\bcp{We should also emphasize, again, that there is no heap (if there were,
we might put it above the stack or between the instructions and the stack)}
First of all, we ignore the heap. We are mainly concerned
with stack interactions so that will be the main focus. \leo{We're
  going to come back to that at the end. Will we?} We also
abstract away low-level details of memory layout and present a
machine that is word-addressed, with instructions starting from
location 0, a dedicated output at location 99, and lay the stack from
location 100 upwards. \leo{Explain more? How to connect to realistic
  one? Observations? DMA? Interrupt handlers?}
%
A sketch of the memory layout at that point can be found in the top of
Figure~\ref{fig:running-trace-b}: instructions for {\tt main} begin at
0, the dedicated output is empty, while the (uninitialized) stack
begins at 100. Directly below the layout, we summarize the parts of
the register file that are relevant to the example.
%
The rest of Figure~\ref{fig:running-trace-b} details the execution of the
program, showing the machine state at call and return points, as well
as describing the full effect of each instruction in detail.
\leo{Expand upon this?}

\apt{Need to clarify to what extent our properties depend on the
particular compilation style, calling sequences, etc. illustrated here.}

\bcp{ Comments on the example:
\begin{itemize}
\item We will also need to be careful about fonts ($f$ vs {\texttt f}),
capitalization of register names (sp vs SP), etc. Maybe typeset instructions
in small caps?  Maybe typeset everything that is part of a concrete machine
in small caps??
%
\item The colors are helpful in making the big page of instruction traces easier
on the eye; maybe they would be even more helpful if
corresponding colors appeared elsewhere in the example (on the instructions
themselves, e.g.).  But we need to be careful to keep it readable -- maybe
they should be background colors, like you've done, rather than text colors.
\item Asking readers to wade through all this is asking quite a bit!  We
need to make sure we are going to get sufficient value out of the example
later (I think we can, but we should really convince ourselves) to make it
worthwhile.
\item Create a new column that just literally pronounces each instruction in
English, so people don't have to read RISC-V opcodes.
\item As discussed, we should move this to before section 2, we should
extend it with a bit more at the end so we can talk about the lazy policy
with the same example, we should add
in some bad variants (doing it here replaces the ``Examples'' from the
Discussion section), and we should consider discussing the attacker model 
here (we need to discuss it someplace in any case!)
\end{itemize}
}

\subsection{Attacker Model + Unsafe Variations}

\leo{TODO: Make attacker model more explicit} The execution trace
shown in Figure~\ref{fig:running-trace-b} is an example of a
``stack-safe'' execution: each process interacts only with the
registers, its local stack space and its call frame. But what could go
wrong if an attacker could hijack an arbitrary call and execute
arbitrary code? In the rest of this section we'll go over examples of
unsafe behaviors, before formally capturing what stack-safe means
formally and discussing enforcement techniques from the literature
in later sections.

\leo{TODO: Add citations of mitigation techniques}

\paragraph*{Bad write}

\[
44 : ~ \sw ~ \rsp ~ r_4 ~ \negate 5
\]

Instruction 44 currently is $\sw ~ \rsp ~ r_4 ~ \negate 2$, with the
effect of storing the contents of $r_4$ as the result of {\tt h}. If
instead it wrote to location $[\rsp - 5]$ then it would be overriding
private data (the return address) belonging to {\tt g}.

\paragraph*{Bad read}

\[
30 : ~ \lw ~ r_5 ~ \rsp ~ \negate 8
\]

Instruction 30 currently is $\lw ~ r_5 ~ \rsp ~ \negate 6$, with the
effect of loading the argument of {\tt g} to $r_4$. If instead it
loaded the contents of location $[\rsp - 8]$, it would obtain access
to {\tt main}'s private information. Worse, since the next instruction
outputs the contents of $r_5$ that would immediately be made public.

\paragraph*{Control flow}

\leo{What should we do here? Overwrite our own ra and return?}

\paragraph*{Reusing call frames}

\leo{TODO}

\section{Machines, Traces, and Observations}
\label{sec:prelim}

To set the stage, we first describe our machine model. Our definition
of stack safety is generic and this section discusses an abstract
interface to our machine model and some kind of static or dynamic,
software- or hardware-enforced security monitor.  For concreteness,
our running examples will use a conventional machine architecture and
a standard (RISC-V) instruction set; in~\Cref{sec:micropolicies} we
will extend this model it with a dynamic policy enforcement mechanism
based on \bcp{NickPaper,AndMaybeSomeOthers}.

\paragraph*{Values, States, and Observations}

The basic building blocks of the machine are {\em values} and {\em
  addresses}. Both are drawn from some set of {\em words}
$\WORDS$, ranged over by $\word$.
%
Our machine states are composed of {\em components} $k$, addressed either by
words (memory addresses) or by by register names ($r$) drawn from some set
$\REGS$.
%
    \[\component \in \COMPONENTS = \WORDS + \REGS \]
%
The register names are assumed to include two special purpose registers: the
program counter {\PCname} and the stack pointer \SP.

A machine state is a map from components to values:
%
\[\mach \in \MACHS = \COMPONENTS \rightarrow \WORDS\]

The step function of the
machine takes a machine state and produces a pair of a
machine state and an {\em observation}, which may be either
silent (written $\tau$) or a word of data that the machine communicates to
the outside world (e.g., by writing to a DMA address):\leo{Needs more
  exposition}\bcp{Like that?}
%
\[\obs \in \OBSS = \{\tau\} \uplus \WORDS\]
\[\mach \stepstoobs{\obs} \mach' : \MACHS \rightarrow \MACHS \times \OBSS \]
%

\paragraph*{Running Example: RISC-V}

Mapping a conventional architecture to this abstract interface is
straightforward. To build up our running example, we are going to use
a standard 64-bit RISC machine, just like the one we are using in our
experiments later on \leo{Mention FORVIS?}. In this setting, $\WORDS$
is the set of 64-bit integers, $\REGS$ is the set $\{r_0, \cdots,
r_{31}\} \cup \{\PCname\}$, and $\SP = r_2$.
% \leo{Mention We use the standard encoding of instructions to words?}
% BCP: Nah.

The first interesting choice is that of observations, as there are
multiple reasonable options. At one extreme, we could choose to define
observations as the value written at any component. However, that
would pose problems later on when we treat some components as ``secret''
when they correspond to a caller's private state. \leo{On the other extreme,
we could pick a particular component and treat it as the ``output'' of
our system. }  \bcp{But in this paragraph we are describing the particular
choise that we make for our running example, no?  But we certainly want to
discuss this fully someplace!}

\paragraph*{Policies}

\bcp{More explanation needed, plus examples.}A policy is a general model of an enforcement mechanism, consisting of
a set of policy states \(\pol \in \POLS\), and a policy step function
\((\mach, \pol) \stepstopol \pol' : \MACHS \times \POLS
\rightharpoonup \POLS\).

We write $\MPS$ for the set of all pairs of machine states and policy
states.
%
\[\MPS = \MACHS \times \POLS\]
%
We lift the policy step function to operate on such pairs
by combining it with the regular step function for machine states.

\judgmenttwo{\(\mach_1 \stepstoobs{\obs} \mach_2\)}{\((\mach_1, \pol_1) \stepstopol \pol_2\)}
            {\(\mpstate{\mach_1}{\pol_1} \stepstoobs{\obs}_P \mpstate{\mach_2}{\pol_2}\)}

\leo{Notation: Should $\stepstoobs{}$ use harpoon for the lifted
  step?}\bcp{Yes.}

\leo{TODO: Forward pointer to policies right?}\bcp{Yes.  But also we can say
in more detail that the intention is to capture any kind of dynamic
enforcement mechanism and give as many names and citations as we can.}

\leo{Policies of interest: null, micro, cherri, software-only}
\leo{TODO: Write down carefully}

\paragraph{Traces}

A trace over a type $A$ is a nonempty, finite or infinite
sequence of $A$s. We will mostly be concerned with sequences of
machines states, usually\bcp{not always?} denoted $\machT$, and with sequences of
triples of (machine states, policy states, and observations), usually
denoted $\MPT$.
\rb{The way the definitions are set up, one may expect MPO, but\ldots}
To continue\bcp{??}, we will require four generic operations
on traces: a ``trace-of'' operation to construct the
trace induced by a step relation and a machine state
\rb{not an op on traces per se?}\bcp{+1};
a ``split'', to break a
trace into two components based on a predicate; a ``join'', the
reverse of split; and a ``prefix'', as a shorthand to only keep the
first component of a split.  \bcp{Not sure it's worth enumerating them
  rather than just getting down to the actual definitions below.}

The ``trace-of'' operator, written \(\hookrightarrow\), coinductively
relates a machine state with the trace of machine states paired with
observations produced by repeated application of step:  \bcp{above, we
  showed operators applied to metavariables, not just the bare operator
  symbol.}
%
\[\hookrightarrow : \machT \rightarrow \MOTRACE\]%
%
\judgmenttwo{\(\mach_0 \stepstoobs{\obs} \mach_1\)}{\(\mach_1 \hookrightarrow \machT\)}
            {\(\mach_0 \hookrightarrow (\mach_0,\obs) \machT\)}%
%
\noindent
Since the step function is total, if \(\mach \hookrightarrow \machT\),
then \(\machT\) must be infinite.

\leo{TODO: Add an example of a trace once I figure out the notations}
\bcp{Let's also try to clean up the spacing a little -- many of these
  sequences of rules can be typeset on fewer lines}

Similarly, we define \(\hookrightarrow_P\) to relate a machine-policy
state pair to the trace of triples of machine states, policy states,
and observations induced by by \(\stepstoobs{}_P\): \bcp{Observe that this
  time the trace can be either finite or infinite.}
%
\[\hookrightarrow_P : \MACHS \times \POLS \rightarrow \MPOTRACE \]
%
\judgment{\(\neg \exists \pol_1 . \pol_0 \rightharpoonup \pol_1\)}
         {\(\mpstate{\mach_0}{\pol_0} \hookrightarrow \mpostate{\mach_0}{\pol_0}{\tau}\)}
%
\judgmentthree{\(\mach_0 \stepstoobs{\obs} \mach_1\)}
              {\(\pol_0 \rightharpoonup \pol_1\)}
              {\(\mpstate{\mach_1}{\pol_1} \hookrightarrow \machT\)}
              {\(\mpstate{\mach_0}{\pol_0} \hookrightarrow_P \mpostate{\mach_0}{\pol_0}{\obs} \machT\)}
We will also use \(\pi_m\) to project the trace of machine states
out of a trace, \(\pi_p\) to project the trace of policy states, and
\(\pi_o\) to project the observations.  \bcp{I'm getting a little lost in
  all these.  E.g., do these traces include the final state of a finite
  execution?  If so, what observation is it paired with?}

% SNA: fixed
%\leo{PUT is completely ambiguous as a choice of abbreviation. Just ``Pre''
%  seems better}
The {\it prefUpTo} operation \(\PUT(\Trace,f)\) \bcp{Why does it have two
  different abbreviated names?  And wouldn't ``While'' be more mnemonic?}
takes a trace \(T\)
and a predicate on elements \(f\) and gives the prefix of \(T\)
ending with the first element on which \(f\) holds, coinductively:

\judgment{\(f\ \traceelem\)}
         {\(\PUT(f,\traceelem\Trace) = \traceelem\)}
%
\judgment{}
         {\(\PUT(f,\traceelem) = \traceelem\)}
%
\judgmenttwo{\(\neg f\ \traceelem\)}{\(\PUT(f,\Trace) = \Trace'\)}
            {\(\PUT(f,\traceelem\Trace) = \traceelem\Trace'\)}
%
Note that if the resulting trace is a strict prefix of the parameter, then the
predicate must hold on its final element. If the predicate never holds,
\(\PUT\) is the identity function.

% The {\it join} operation, written \(T_1 \cdot T_2\) is the reverse of
%$\mathit{split}$: it takes two traces and links them by replacing the
%last element of the first (if it has one) with the first element of
%the second

%\judgment{} {\(t \cdot T = T\)}
%\judgment{\(T_1 \cdot T_2 = T\)}{\(tT_1 \cdot T_2 = tT\)}
%\leo{Lemma/theorem: split/join = id?}
%\leo{TODO: FORMATTING: Remove force line break/par at end of judgments}

We will frequently take a prefix of the trace from an initial state up
through the first state where some condition holds on the machine state.
This can easily be implemented using \(\PUT\), and we provide special notation
for convenience.
%
Let \(f\) be a predicate on machine states. Then we define \(\mach
\hookrightarrow \machT | f\) (read ``\(\machT'\) is the prefix of
running \(\mach\) up to \(f\)''): \bcp{M and M' should be swapped, I think.}

\judgmenttwo{\(\mach \hookrightarrow \machT'\)}
            {\(\PUT(\lambda (\mach',\obs).f\ \mach',\machT')
              = \machT\)}
            {\(\mach \hookrightarrow \machT | f\)}
\noindent
And similarly for traces with policies:

\judgmenttwo{\(\mpstatename \hookrightarrow \MPT\)}
            {\(\PUT(\lambda \mpostate{\mach}{\pol}{\obs}.f(\mach),\MPT) = \MPT'\)}
         {\(\mpstatename \hookrightarrow \MPT' | f\)}

%    \COQ{this operation steps until it reaches a state on which \(f\) holds,
%    and is infinite if it doesn't. It doesn't compute the observation of the step after the final,
%    which coq would. So coq may need a ``step until'' relation rather than ``prefix up to''.
%    Still thinking about this.}\leo{So this is strictly weaker than the one we have in Coq, right?
%      So its only the Eager implies Lazy direction that might need tweaking, but not the Test implies Eager one?}
%    \leo{Also, it steps until it reaches an f-state or if the policy raises a fault}

\paragraph*{Observational Equivalence}

We say that a trace of observations $\obsT_1$ is a prefix of $\obsT_2$
\leo{Benjamin suggested ``as far as an attacker is concerned'' in an
  e-mail, but we haven't said anything about attackers yet.}\bcp{We don't
  have to talk about attackers, just external observers.}, if the
sequence of non-silent observations of $\obsT_1$ is a prefix of those
of $\obsT_2$; that is we operate up to deletion of \(\tau\)
observations, coinductively:

%\leo{TODO: We really need a better layout than centered paragraphs.}

\begin{minipage}{.3\textwidth}
  \judgment{}{\(\obsT \lesssim \obsT\)}
\end{minipage}
\begin{minipage}{.3\textwidth}
\judgment{}{\(\tau \lesssim \obsT\)}
\end{minipage}
\begin{minipage}{.3\textwidth}
\judgment{}{\(w \lesssim w\obsT\)}
\end{minipage}

\begin{minipage}{.3\textwidth}
\judgment{\(\obsT_1 \lesssim \obsT_2\)}
         {\(\tau \obsT_1 \lesssim \obsT_2\)}
\end{minipage}
\begin{minipage}{.3\textwidth}
\judgment{\(\obsT_1 \lesssim \obsT_2\)}
         {\(\obsT_1 \lesssim \tau \obsT_2\)}
\end{minipage}
\begin{minipage}{.3\textwidth}
\judgment{\(\obsT_1 \lesssim \obsT_2\)}
         {\(w\obsT_1 \lesssim w\obsT_2\)}
\end{minipage}

% Fixed by Andrew:
%\COQ{This is the same as the coq version minus a redundant case.}

We then define similarity of observation traces as traces prefixing each other:

\bcp{Can we please call it something else?  An
  ``equivalence'' should always be transitive.}
\sna{Similarity seems less loaded?}
\[O_1 \simeq O_2 \triangleq O_1 \lesssim O_2 \land O_2 \lesssim O_1\]

\leo{Rephrase transition. I hate it:} There are two interesting things
to note.  First, observation trace equivalence could alternatively be
defined as the prefix relation but dropping the only assymetric rules
\leo{2 + 3. TODO: name rules?}

\leo{Also rephrase this.}
Second, an infinite silent trace is a prefix of (and equivalent to)
any other trace. While this might seem surprising at first, it makes
sense in a timing-insensitive context: an external observer looking
at two machine runs cannot (computably) distinguish between a machine that
steps forever and a machine that steps for a long time before producing
some output.

%Let the predicate \(\isinf(T)\) hold when the trace $T$ is infinite.
%We then define {\em policy-sensitive observational equivalence}: a
%trace $\MPT \in \MPOTRACE$ is equivalent to a trace $\machT \in
%\MOTRACE$ if (1) \(\MPT\) is infinite and the observations of \(\MPT\)
%and \(\machT\) are equivalent, or (2) if the \(\MPT\) is finite (due to a
%policy fault) and its observations are a prefix of those of M.
%
%% Fixed by Sean
%%\leo{Why $\mathit{Obs}$ and not $\pi_o$ defined earlier?}
%\judgmenttwo{\(\neg \isinf(\MPT)\)}{\(\pi_o(\MPT) \lesssim \pi_o(\machT)\)}
%            {\(\MPT \sim_P \machT\)}
%
%\judgmenttwo{\(\isinf(\MPT)\)}{\(\pi_o(\MPT) \simeq \pi_o(\machT)\)}
%            {\(\MPT \sim_P \machT\)}

\section{Stack Safety, Formally}
\label{sec:lse-and-wbcf}

In this section we will describe stack safety as a formal property. We
begin with introducing a running example that will help keep things
concrete throughout this section, continue with our model of
\leo{compiler-provided?} knowledge about the program structure, and
then dive in to formal definitions local state encapsulation and
well-bracketed control flow.




\subsection{Program Structure}

Our properties and policies are parameterized by several types of
annotations describing features of a program. A {\em code map}
\leo{TODO: function map}
identifies some addresses as code and assigns each to a function. A
{\em call map} identifies addresses that complete a call sequence,
abstracting away from any concrete calling convention. Likewise a {\em
  return map} identifies addresses that complete a return sequence. An
{\em entry map} identifies valid entry points to a function.

Formally a code map\bcp{I'd love to change ``cdm'' to ``km''.  Should we
  also call it a ``kode map'' in English?  Maybe that's a bit too far.} is a
partial function from addresses to a function
identifier drawn from the set \(\FUNIDS\).
  %
\[\codemap \in \CODEMAPS = \WORDS \rightharpoonup \FUNIDS\]
%
In our running example, instructions 100-124 correspond to $f$,
instructions 140-196 correspond to $g$, and instructions 200-228
correspond to $h$.

A call map is a partial function from addresses to a natural number,
the number of arguments and return values of the call.
  %
\[\callmap \in \CALLMAPS = \WORDS \rightharpoonup \mathbb{N}\]
%
In our running example, the callmap would contain (at least) two
entries: the word 112 corresponding to the first $\jal$
instruction to $g$, which would map to $2$ as the call has one
argument; and the word 164 also mapping to $2$ corresponding
to the call to $h$.

For concreteness, in a typical calling convention, a call map may be
considered to identify the state just before the \(\JAL\), in which
space for arguments is already allocated, but the mechanism is more
general. A state in which a call map is defined on the program counter
is referred to as a {\it call state}.

A return map is simply a predicate on addresses and may be considered
to identify the final jump of the return sequence. An entry map is
likewise a predicate on addresses.
  %
\[\retmap \in \RETMAPS \subseteq \WORDS\]
\[\entmap \in \ENTMAPS \subseteq \WORDS\]
%
In our running example, the return map identifies the $\jalr$
instructions 196 and 224, while the entry map identifies
instructions 140 and 200.

\paragraph*{What is a return?}

We separately identify, for any call state, what is means for a state
to have correctly returned from a call. We consider the call to have
returned the first time control returns to the instruction following
the \(\JAL\) with the stack restored. Formally this is a relation
between the states:

\[\begin{split}
    \ret{\mach_c}\ \mach_r \triangleq & \mach_r(\PCname) =
    \nextPC(\mach_c(\PCname)) \land \\ & \mach_r(\SP) = \mach_c(\SP)
\end{split}\]

\leo{Point to the trace. two return points}

\subsection{Local State Encapsulation}
\label{sec:lse}

The first part of stack safety is {\em local state encapsulation}.
Informally, it captures the notion that a caller's data is
protected from a callee's actions. We formalize this notion
as a security property with an integrity and a confidentiality
component, where the former protects the caller's data from being
written and the latter from being read.

As is standard with security properties, we associate with each
component of the machine a {\em label}: a pair of security levels
denoting high or low confidentiality and high or low integrity.
%
\[\mathit{label} ::= \{\HIGHSEC,\LOWSEC\} \times \{\HIGHINT,\LOWINT\}\]
%
In a traditional setting, integrity would enforce that the contents of
$\HIGHINT$ locations remain unchanged, while confidentiality would
enforce that the contents of $\HIGHSEC$ locations don't influence the
observable behavior. However, when dealing with nested calls and
returns, stack safety needs to enforce integrity and confidentiality
for {\em every} function call in a trace; that is, we must treat the
security level of data dynamically.
%
To that end, we introduce the notion of a {\em contour}, a map from
components to labels:
%
\[\contour \in \CONTOURS ::= \COMPONENTS \rightarrow \mathit{label}\]

When \(\mach_c\) is a call state \(\callmap(\mach(\PCname)) = n\) for
some \(n\) and \(\mach_c \stepstoobs{\obs} \mach_e\), we can construct
a contour based on the bounds of the callee's stack frame.
%
The private state of the callee is the entire area of the memory from
stack base to stack pointer, with the exception of the $n$ locations
corresponding to the arguments of a call. Private components are
marked high confidentiality and high integrity: the callee should be
able to neither read, nor write them.
%
Everything above the stack pointer at the point of the call is
``uninitialized'' memory that can be written into but should not be
read. To protect the callee itself from such reads, these components
are marked high confidentiality and low integrity.
%
Special care is needed for the code memory corresponding to the
callee: they are marked low confidentiality if they belong to the
callee and high confidentiality otherwise; regardless they are always
high integrity.\leo{That would mean we scramble some instructions, I
  guess that makes sense.}
%
Finally, registers and the frame of arguments to the callee are free
for the callee to use, and are therefore tagged with low integrity and
low confidentiality.

 \[\mathit{Cof}(\mach,\funid,n)(\component) =
  \begin{cases}
    (\LOWSEC,\HIGHINT) & \text{if } \component \in \WORDS
                         \text{ and for some } \funid, \codemap(\component) = \funid \\
    (\HIGHSEC,\HIGHINT) & \text{else if } \component \in \WORDS
                          \text{ and } \component \leq \mach(\SP) \negate  n \\
    (\HIGHSEC,\LOWINT) & \text{else if } \component \in \WORDS
                         \text{ and } \component \geq \mach(\SP) \\
    (\LOWSEC,\LOWINT) & \text{else} \\
  \end{cases}\]

  \leo{Snapshot state at the point of the call from TOP to F, collor
    the different things}

\paragraph*{Stack Integrity}

The first component of local state encapsulation is an integrity
property: it ensures that the caller's data is never overwritten by a
callee. We will formally define integrity in two steps: first, we will
define integrity as a trace property over the trace corresponding to a
single call (from its entry point to its corresponding return), and
then we will lift that to a property for every such subtrace of a
callee.

\definition{Trace Integrity}
\label{def:trace-integrity}
Let $\contour$ be a contour and $MP$ be a (potentially infinite)
$\MPOTRACE$. We will say $MP$ satisfies {\em trace integrity} with
respect to $\contour$ if its final state (if any) agrees with its
initial one on all components marked $\HIGHSEC$ in $\contour$:
%
\[
\mathit{int} ~ \contour ~ MP \triangleq
\left \{ \begin{array}{ll}
  \mathit{True}, & \text{if $MP$ is infinite}\\
  \forall \component. ~ \contour(\component) = \HIGHSEC \rightarrow m_0(\component) = m_f(\component), & \text{otherwise} \\
\end{array}
\right .
\]
\leo{TODO: DISCUSS: Figure out notation for first/last machine state in a trace}

Intuitively, the caller expects to find their private data untouched
after the callee returns. That means that if the callee never returns,
integrity is trivially satisfied. Similarly, the callee is allowed to
temporarily overwrite these locations, as long as they are restored
once control returns. We will see variations of this later on: a
stronger, inductive integrity property that ensures that the caller's
private data is never overwritten, even during the caller's execution
(a variation that leads to easier reasoning and more effective testing);
and a weaker, lazy integrity property that only ensures that the
locations that a caller accesses are preserved (a variation that allows
for a more efficient enforcement mechanism).

Trace integrity characterizes the trace corresponding to a single
callee. We now lift this definition to an integrity property for a
complete execution trace. We do this by requiring that trace integrity
holds for every transition between a caller and a callee $f$ for
the entirety of the trace of $f$.

\definition{Transition}
Given a trace $MP$, a call map $\callmap$ and a code map $\codemap$,
an $n$-{\em transition} to a callee $f$ is a pair of machine-policy
state pairs $(\mach_c, \pol_c)$ and $(\mach_e, \pol_e)$ in the trace
such that:
\begin{itemize}
\item one state pair steps to the other:
  $$\exists \obs. ~ (\mach_c, \pol_c) \stepstoobs{\obs}_P (\mach_e, \pol_e),$$
\item $\mach_c$ is a valid call with $n$ arguments:
  $$\callmap(\mach_c(\PCname)) = n,$$
\item and $\mach_e$ is an entry point for $f$:
  $$\codemap(\mach_e(\PCname)) = f.$$
\end{itemize}

For an example see Figure \ref{fig:intex}, in which {\tt h} writes its return
value to {\tt g}'s return location the stack rather than its own. That address
is high integrity (red), and so writing to it causes the property to fail.

\definition{Stack Integrity}
Let $\callmap$ be a call map and $\codemap$ a code map. We say that a
system satisfies {\em stack integrity} with respect to $\callmap$ and
$\codemap$ if, for every initial machine-policy state pair $(\mach_0,
\pol_0)$ and its induced trace $MP$, and every $n$-transition
$(\mach_c, \pol_c)$ and $(\mach_e, \pol_e)$ to a callee $f$ in $MP$,
the prefix $MP_{pre}$ of $MP$ from $(\mach_e, \pol_e)$ until the first
return corresponding to $\mach_c$ (if any) satisfies trace integrity
with respect to the contour at the call:
%
$$\forall MP_{pre}. ~ \mpstate{\mach_e}{\pol_e} \hookrightarrow_P
MP_{pre} ~ | ~ \ret{\mach_c} \rightarrow
\mathit{int}~\mathit{Cof}(\mach_c, f, n)~MP_{pre}$$

\paragraph*{Stack Confidentiality}

The second component of local state encapsulation is a confidentiality
property: just like integrity ensures that a caller's data is never
overwritten by a callee, confidentiality ensures that it never
influences its observable behavior. We will formally define
confidentiality in two similar steps: a trace version and a system
version.

Unlike integrity, confidentiality is a noninterference-style property,
comparing the behavior of a machine with an arbitrary variant that
preserves low confidentiality data.

\definition{Variations}
We say two machine states $\mach$ and $\mach'$ are {\em variations} of one
another given a contour $\contour$ if they agree on low
confidentiality data:
%
\[
\mach \approx_\contour \mach' \triangleq \forall \component .
\contour(\component) = \LOWSEC \rightarrow \mach(\component) =
\mach'(\component)
\]
%
Then, the trace version of confidentiality operates on two traces: the
``original'' one $MP \in \MPOTRACE$ that corresponds to a callee $f$
and a ``variant'' one $M \in \MTRACE$ that would corresponding to $f$
if it started from a variant initial machine state. An example in

\definition{Trace Confidentiality}
\leo{Add info for ``valid return'':}
We will say two traces $MP$ and $M$ satisfy {\em trace
  confidentiality} with respect to $\contour$ if:
\begin{itemize}
\item If $MP$ is finite and its final state $\mach_r$ is a valid
  return, then $M$ is also finite with some final state $\mach_r'$ and
  any changes from the initial states have changed in the same way:
$$\forall \component. ~ \mach_e(\component) \not = \mach_r(\component)
  \vee \mach_e'(\component) \not = \mach_r'(\component) \rightarrow
  \mach_r(\component) = \mach_r'(\component)$$
  In addittion their observations must be equivalent:
  $$\pi_o(MP) \eqsim \pi_o(M)$$
\item If $MP$ is infinite, then $M$ is also infinite and their
  observations are equivalent:
  $$\pi_o(MP) \eqsim \pi_o(M)$$
\item If the $MP$ ends prematurely with a policy fault, then
  we require that its observations are a prefix of those of $M$:
  $$\pi_o(MP) \lesssim \pi_o(M)$$
\end{itemize}

Figure \ref{fig:confex2} shows the initial states \(\mach_e\), left,
and \(\mach_e'\), right. Low confidentiality data in green is shared
between them, while high confidentiality data in red and yellow may differ.
After executing the code shown, the final states below have written different
values to address 42, represented by the black and white components.
It is allowed for address 40 to differ between the states due to the initial
variation, but address 42 changed differently between the traces, representing
a leak of data. %Meanwhile \ref{fig:lazyex2}, while high confidentiality data
%is read, it is overwritten before return, and the write at step 3 always writes
%the same value. Yellow and red locations differ between variations only because
%of the initial variation, and the rest are identical. So this example passes.

\begin{figure}
% At Call to H
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{61.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
  \memory{6}{red}[{\makebox[0pt]{\(\HIGHINT\)}}]%
  \memory{2}{green}[{\makebox[0pt]{\(\LOWINT\)}}]%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{0}
\MemoryLabel{-30.5em}{0.75em}{8}
\MemoryLabel{-26.5em}{0.75em}{}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-18.5em}{0.75em}{0}
\\
\end{center}
% Starting Register File
\summary{40}{0}{\thepcctr}{108}{17}{?}
\setcounter{pcctr}{40}
\vspace*{0.2em}
% H - Body
\[
\begin{array}{c|c|c|c|c}
  \row{\addi ~ \rsp ~ \rsp ~ 1}{\rsp \leftarrow \rsp + 1}{\rsp \leftarrow 109}
      {Allocate for return address}
  \row{\sw ~ \rsp ~ \rra ~ \negate 1}{[\rsp - 1] \leftarrow \rra}{[108] \leftarrow 27}
      {Store return address}
  \row{\lw ~ r_4 ~ \rsp ~ \negate 3}{r_4 \leftarrow [\rsp - 3]}{r_4 \leftarrow 17}
      {Load the argument {\tt v} to $r_4$}
  \row{\addi ~ r_4 ~ r_4 ~ 1}{r_4 \leftarrow r_4 + 1}{r_4 \leftarrow 18}
      {Increment $r_4$ by 1}
  \row{\sw ~ \rsp ~ r_4 ~ \negate 5}{[\rsp - 5] \leftarrow r_4}{[103] \leftarrow 18}
      {Store $r_4$ as {\tt g}'s return value}
  \row{\lw ~ \rra ~ \rsp ~ \negate 1}{\rra \leftarrow [\rsp - 1]}{\rra \leftarrow 31}
      {Load return address}
  \row{\addi ~ \rsp ~ \rsp ~ \negate 1}{\rsp \leftarrow \rsp - 1}{\rsp \leftarrow 108}
      {Restore the stack pointer of {\tt g}}
  \row{\jalr ~ \rra ~ \rra ~ 0}{??}{PC \leftarrow 31}
      {Return to {\tt g}}
  \end{array}
\]
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{44em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
  \memory{3}{red}%
  \memory{1}{green}%
  \memory{2}{red}%
  \memory{2}{gray}%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{18}
\MemoryLabel{-30.5em}{0.75em}{8}
\MemoryLabel{-26.5em}{0.75em}{}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-18.5em}{0.75em}{0}
\MemoryLabel{-16em}{0.75em}{108}
\\
\end{center}
%
  \caption{Failing Trace Integrity}
  \label{fig:intex}
\end{figure}

\begin{figure}
% At Call to H
% Memory Layout
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{61.5em}{2em}{\SP}
\memory{3}{gray}[{\makebox[0pt]{Instructions}}]%
\hspace*{3pt}
$\cdots$
\memory{1}{white}[{\makebox[0pt]{Output}}]%
  \memory{6}{red}[{\makebox[0pt]{\(\HIGHSEC\)}}]%
  \memory{2}{green}[{\makebox[0pt]{\(\LOWSEC\)}}]%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{0}
\MemoryLabel{-30.5em}{0.75em}{8}
\MemoryLabel{-26.5em}{0.75em}{}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-18.5em}{0.75em}{0}
\\
\end{center}
% Variant
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{61.5em}{2em}{\SP}
\memory{3}{gray}%
\hspace*{3pt}
$\cdots$
\memory{1}{white}%
  \memory{6}{yellow}[{\makebox[0pt]{Varied}}]%
  \memory{2}{green}%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{?}
\MemoryLabel{-42.5em}{0.75em}{?}
\MemoryLabel{-38.5em}{0.75em}{?}
\MemoryLabel{-34.5em}{0.75em}{?}
\MemoryLabel{-30.5em}{0.75em}{?}
\MemoryLabel{-26.5em}{0.75em}{?}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-18.5em}{0.75em}{0}
\\
\end{center}

% Starting Register File
\summary{40}{0}{\thepcctr}{108}{17}{?}
\setcounter{pcctr}{40}
\vspace*{0.2em}
% H - Body
\[
\begin{array}{c|c|c|c|c}
  \row{\addi ~ \rsp ~ \rsp ~ 1}{\rsp \leftarrow \rsp + 1}{\rsp \leftarrow 109}
      {Allocate for return address}
  \row{\sw ~ \rsp ~ \rra ~ \negate 1}{[\rsp - 1] \leftarrow \rra}{[108] \leftarrow 27}
      {Store return address}
  \row{\lw ~ r_4 ~ 100}{r_4 \leftarrow 100}{r_4 \leftarrow 42/?}
      {Load {\tt main}'s secret {\tt x} to $r_4$}
  \row{\addi ~ r_4 ~ r_4 ~ 1}{r_4 \leftarrow r_4 + 1}{r_4 \leftarrow 43/(?+1)}
      {Increment $r_4$ by 1}
  \row{\sw ~ \rsp ~ r_4 ~ \negate 2}{[\rsp - 2] \leftarrow r_4}{[107] \leftarrow 43/(?+1)}
      {Store $r_4$ as the return value}
  \row{\lw ~ \rra ~ \rsp ~ \negate 1}{\rra \leftarrow [\rsp - 1]}{\rra \leftarrow 31}
      {Load return address}
  \row{\addi ~ \rsp ~ \rsp ~ \negate 1}{\rsp \leftarrow \rsp - 1}{\rsp \leftarrow 108}
      {Restore the stack pointer of {\tt g}}
  \row{\jalr ~ \rra ~ \rra ~ 0}{??}{PC \leftarrow 31}
      {Return to {\tt g}}
  \end{array}
\]
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{44em}{2em}{\SP}
\memory{3}{gray}%
\hspace*{3pt}
$\cdots$
\memory{1}{white}%
  \memory{6}{red}%
  \memory{1}{green}%
  \memory{1}{pink}%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{42}
\MemoryLabel{-42.5em}{0.75em}{0}
\MemoryLabel{-38.5em}{0.75em}{0}
\MemoryLabel{-34.5em}{0.75em}{0}
\MemoryLabel{-30.5em}{0.75em}{8}
\MemoryLabel{-26.5em}{0.75em}{}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-19em}{0.75em}{43}
\MemoryLabel{-16em}{0.75em}{108}
\\
\end{center}
%
\begin{center}
\MemoryLabel{4em}{2em}{0}
\MemoryLabel{21em}{2em}{99}
\MemoryLabel{44em}{2em}{\SP}
\memory{3}{gray}%
\hspace*{3pt}
$\cdots$
\memory{1}{white}%
  \memory{6}{yellow}%
  \memory{1}{green}%
  \memory{1}{pink}%
\memory{2}{gray}%[{\makebox[0pt]{Uninitialized}}]
~$\cdots$
\MemoryLabel{-46.5em}{0.75em}{?}
\MemoryLabel{-42.5em}{0.75em}{?}
\MemoryLabel{-38.5em}{0.75em}{?}
\MemoryLabel{-34.5em}{0.75em}{?}
\MemoryLabel{-30.5em}{0.75em}{?}
\MemoryLabel{-26.5em}{0.75em}{?}
\MemoryLabel{-22.5em}{0.75em}{17}
\MemoryLabel{-19em}{0.75em}{?}
\MemoryLabel{-16em}{0.75em}{108}
\\
\end{center}
%
  \caption{Failing Trace Confidentiality}
  \label{fig:confex2}
\end{figure}

Figure \ref{confex2} gives an example of a trace that fails trace
confidentiality. At instruction 42, {\tt h} reads {\tt x} from {\tt main}.
Since {\tt x}, at address 100, is high confidentiality (red) the variant
may have a different value (yellow). So both \(r_4\) and address 107
differ in the final state between the original trace and the variant one,
failing the ending condition of trace confidentiality.

To lift trace confidentiality to a system property, we follow the same
pattern as in stack integrity:

\definition{Stack Confidentiality}
Let $\callmap$ be a call map and $\codemap$ a code map. We say that a
system satisfies {\em stack confidentiality} with respect to
$\callmap$ and $\codemap$ if, for every initial machine-policy state
pair $(\mach_0, \pol_0)$ and its induced trace $MP$, and every
$n$-transition $(\mach_c, \pol_c)$ and $(\mach_e, \pol_e)$ to a callee
$f$ in $MP$, the prefix $MP_{pre}$ of $MP$ from $(\mach_e, \pol_e)$
until the first return corresponding to $\mach_c$ (if any) satisfies
trace integrity with respect to every similarly prefixed machine trace
of every variation $\mach_e'$ with the contour at the call:
$$\forall MP_{pre} ~ M_{pre}. ~
\mpstate{\mach_e}{\pol_e} \hookrightarrow_P MP_{pre} ~ | ~ \ret{\mach_c} \rightarrow$$
$$\forall \mach_e'. ~ \mach_e \approx_{\mathit{Cof}(\mach_c, f, n)} \mach_e' \wedge
\mach_e' \hookrightarrow M_{pre} ~ | ~ \ret{\mach_c} \rightarrow$$
$$\mathit{conf}~\mathit{Cof}(\mach_c, f, n) ~ MP_{pre} ~ M_{pre}$$

\subsection{Well-bracketed Control Flow}
\label{sec:wbcf}

Our integrity and confidentiality properties concern themselves with
data, and may hold on a wide range of programs that violate expected
control flow.  But well-bracketed control flow prevents this style of
attack by guaranteeing that every jump between functions is either a
call or a return, and each return jumps to the instruction after a
corresponding call.

\leo{Also dumping in relevant wbcf discussion part. TODO: merge}
    Some forms of security rely on protected control flow. In a classic
    example, a system call that launches a missile might be gated behind code
    that checks a password. A piece of malicious code can jump into the middle
    of the sequence and execute the system call without the appropriate password,
    and still obey integrity if the malicious code never returns to its caller.
    Integrity here protects data, not privileges. But such a jump does violate
    eager stack confidentiality if the attacker jumps beyond its own function's
    instructions without performing a designated call or returning to an
    appropriate site.

    A jump to a function's own code does not violate either, even if done using
    nefarious means such as return-oriented programming (ROP). Our model would
    permit such a jump within the function, so privilege is not elevated by
    permitting ROP in this case.

    But, our policies do enforce orthogonal control flow properties that
    protect from calls that enter outside of valid entry points and from all
    invalid returns, even if they would not escalate privilege. Most notably
    {\em well-bracketed control flow}, below.

\definition{Control Separation}
A system enjoys {\em control separation} with regard to a code map
\(\codemap\), a call map \(\callmap\), and a return map \(\retmap\) if
for any initial state \(\mach_0\) and any adjacent pair of states
\(\mach_1\) and \(\mach_2\) in the induced trace from
\(\mpstate{\mach_0}{\pinit(\mach_0)}\), if
\(\codemap(\mach_1(\PCname)) \not = \codemap(\mach_2)\), then either
\(\callmap(\mach_1(\PCname)) = n\) for some \(n\), or
\(\retmap(\mach_1)\).

\definition{Entry Integrity}
A system enjoys {\em entry integrity} with regard to a call map
\(\callmap\) and entry map \(\entmap\) if for any initial state
\(\mach_0\) and any adjacent pair of states \(\mach_c\) and
\(\mach_e\) in the induced trace from
\(\mpstate{\mach_0}{\pinit(\mach_0)}\), if
\(\callmap(\mach_c(\PCname)) = n\) then \(\entmap(\mach_e)\).

\definition{Return Integrity}
Return integrity captures the expected behavior of marked returns with
regard to their call points. We begin by defining a coinductive
relation \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT_1
\MPT_2\). Given a call map \(\callmap\) and return map \(\retmap\),
\(\MPT\) is related to \(\MPT'\) if \(\MPT'\) is a suffix of \(\MPT\)
whose head is the first unmatched return in \(\MPT\). So if \(\MPT\)
starts with a return, it is related to itself:

  \judgmenttwo{\(\callmap(\mach(\PCname)) = \bot\)}
           {\(\retmap(\mach(\PCname))\)}
      {\(\mathit{Unmatched}\ \callmap\ \retmap\ \mpstate{\mach}{\pol}\
        \mpstate{\mach}{\pol}\)}
  \judgmenttwo{\(\callmap(\mach(\PCname)) = \bot\)}
              {\(\retmap(\mach(\PCname))\)}
      {\(\mathit{Unmatched}\ \callmap\ \retmap\ \mpstate{\mach}{\pol}\MPT\
              \mpstate{\mach}{\pol}\MPT\)}

If \(\MPT\) starts with a non-call, non-return state, its unmatched
return must come later:

  \judgment{\(\callmap(\mach(\PCname)) = \bot
              \hspace{.5cm} \neg \retmap(\mach(\PCname))

              \mathit{Unmatched}\ \callmap\ \retmap\ \MPT\ \MPT'\)}
           {\(\mathit{Unmatched}\ \callmap\ \retmap\
            \mpstate{\mach}{\pol}\MPT\ \MPT'\)}

And most intricately, if \(\MPT\) starts with a call, we must find the
return that matches it, which will be the unmatched return once we
step past the call. Then the first unmatched return beyond it is the
true unmatched return.

    \judgment{\(\callmap(\mach(\PCname)) = n
              \hspace{.5cm} \neg \retmap(\mach(\PCname))\)

              \(\MPT = \mpstate{\mach}{\pol} \MPT_{\mathit{call}}\)

              \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT_{\mathit{call}}\ \MPT_{\mathit{matched}}\)

              \(\MPT_{\mathit{matched}} = \mpstate{\mach'}{\pol'} \MPT_{\mathit{tail}}\)

              \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT_{\mathit{tail}}\ \MPT_{\mathit{unmatched}}\)}
            {\(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT\ \MPT_{\mathit{unmatched}}\)}

A system enjoys {\em return integrity} with regard to a call map
\(\callmap\) and return map \(\retmap\) if for any initial state
\(\mach_0\) and any call state and policy state \(\mach_c\) and
\(\pol_c\) in the induced trace from
\(\mpstate{\mach_0}{\pinit(\mach_0)}\), if \(\mpstate{\mach_c}{\pol_c}
\hookrightarrow_P \MPT\) and \(\mach_r\) is the first unmatched
return, with \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT \ \MPT'\)
and \(\mach_r\) the first machine state of \(\MPT'\), then
\(\ret{\mach_c}\ \mach_r\).

\definition{Well Bracketed Control Flow}
The above properties are somewhat orthogonal, but together they
capture a standard notion of control flow for a stack: functions keep
their code separate outside of calls and returns, calls respect
explicit entry points, and returns respect implicit entry points
corresponding to their call.  A system that enjoys them with regard to
a code, a call, a return, and an entry map is said to enjoy {\em well
  bracketed control flow} with regard to those maps.


\section{Enforcement}
\label{sec:enforcement}

\rb{Better section name and headings, references.}

\paragraph*{Micropolicies}
%
In order to enforce a given security policy on a system dynamically, we resort
to a programmable, tag-based reference monitor that runs alongside the program.
To control this monitor, we use a programming model that allows fine-grained
manipulation of metadata tags to encode so-called \emph{micropolicies}
\rb{cite}.

In such a system, all memory addresses, registers and the program counter are
enriched with an abstract metadata tag, which can point to the representation of
an arbitrary data structure. A micropolicy is thus defined by a collection of
rules to be checked as each instruction executes and together define the
transfer function of the security policy. Each rule inspects the tags associated
to the inputs of an instruction (PC, registers, memory) as well as the
instruction opcode itself, and produces one of two outcomes: either the
instruction is allowed to execute (and tags for the new PC and its result are
produced and assigned to those), or the machine fail-stops with a policy
violation.

Efficient execution of these micropolicies relies on hardware implementations
such as the PUMP architecture \rb{cite}, which include a monitor rule cache that
maps tag inputs to outputs and a mechanism to trap misses to software handlers
and thereby computes the transfer function of the software-defined policy.
Previous work has shown that a wide range of micropolicies can be defined and
enforced efficiently \rb{cite}.
%
\rb{Maybe go into more detail, examples later\ldots or try to segue into stack
policies}

\paragraph*{A conservative policy}

This conservative policy enforces our stack safety policy. Moreover, it enforces
a provably stronger \emph{testing property}.

The properties we give are indeed enforceable.

Less conservative policies can be more efficient, but also harder to test.

What is the strongest property enforced by the conservative policy?
%
\rb{Not too much focus on this}

\rb{We have not proved that this policy guarantees our property, but we have
tested it against a stronger property.}

\paragraph*{Testing the conservative policy}

\paragraph*{End-to-end stack safety property}

\paragraph*{Eager vs lazy testing}

\rb{This part should probably be somewhere in the lazy section.}
%
In practice, this \emph{eager policy} is too slow to be of practical interest:
what we really want in practice is a \emph{lazy policy} that can be efficiently
implemented.

We can also test the lazy policy, even if less efficiently, and it should
enforce an inductive property, which may be more amenable to proving.
%
\rb{Would need careful phrasing.}
%
\rb{Implied by the property we started with?}

\rb{Explain and compare what each policy enforces.}

\section{Lazy Stack Safety}
\label{sec:lazy}

    \definition{Observable Integrity}
      Observable integrity weakens eager integrity by allowing a returned state
      to differ from its call state at high integrity components, provided the
      observable behavior of the induced trace from the return matches that of
      an idealized state whose high integrity components do match the call
      state.

      Given a contour, a call state, and a returned state, we define a
      ``rollback'' function \(\mathit{roll} : \CONTOURS \times \MACHS \times
      \MACHS \rightarrow \MACHS\). The rollback returns a state that matches
      the call state on those components that are high integrity in its
      contour, and matches the return state on low integrity components:
      \[\mathit{roll}(\contour,\mach_c,\mach_r)(\component) =
      \begin{cases}
        \mach_c(\component) & \contour(\component) = (\HIGHINT,\_) \\
        \mach_r(\component) & \contour(\component) = (\LOWINT,\_) \\
      \end{cases}\]

      If \(\mach_e\) is an entry to a call with contour \(\contour\) and
      \(\mach_r\) its return, \(\mathit{roll}(\contour,\mach_e,\mach_r)\)
      agrees with \(\mach_e\) on every component the callee should not change,
      but with \(\mach_r\) on those components that it is permitted to change.
      So the observable behavior that follows is the idealized behavior to
      which we compare the trace from \(\mach_r\), which must prefix it (to
      account for premature halts due to policy violations.)
      %
      \[\begin{split}
        \text{\sc ObsInt}_\contour ~ \MPT \triangleq
          & \MPT = \mpostate{\mach_e}{\pol_e}{\obs_e} \dots
            \mpostate{\mach_r}{\pol_r}{\obs_r} \Rightarrow \\
        & \mpstate{\mach_r}{\pol_r} \hookrightarrow \MPT' \Rightarrow \\
        & \mathit{roll}(\contour,\mach_e,\mach_r) \hookrightarrow \machT' \Rightarrow \\
        & \pi_o(\MPT') \lesssim_O \pi_o(\machT')
      \end{split}\]

    \definition{Observable Stack Integrity}

      A system enjoys {\em observable integrity} with regard to \(\callmap\)
      and  \(\codemap\) if for any initial state \(\mach_0\) and each
      transition with entry state \(\mpostate{\mach_e}{\pol_e}{\obs_e}\) and
      contour \(\contour\) in the induced trace from
      \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\), if
      \(\mpstate{\mach_e}{\pol_e} \hookrightarrow \MPT | \ret{\mach_e}\),
      then \(\text{\sc ObsInt}_\contour ~ \MPT\).

    \definition{Observable Trace Confidentiality}

      Trace confidentiality is a property of two traces whose initial machine
      states are variations, with two sub-properties. First, the behavioral
      condition -- that their observable behaviors prior to the end of the
      trace are equivalent -- reflects the intuition that secret values should
      not influence visible behavior. Second, we have the end condition that
      their final states (if any) are equal up to the original variation. The
      end condition over-approximates the extension of the behavioral condition
      to future execution.

      We introduce {\em observable trace confidentiality}, which extends the
      behavioral condition to apply to execution from the final state on.
      This requires restoring varied components to their original values,
      since after return they will once again be accessible legitimately.

      In Figure \ref{fig:lazyex1}, the final states of the original and variant
      differ, because a written value (in black or white) depended on the value
      of a high confidentiality location. So the resulting trace fails trace
      confidentiality. For observable trace confidentiality, we ask whether the
      differing values at address 42 cause any observable distinctions in
      future behavior. To do so, we must undo the variation of formerly high
      confidentiality locations, so that those in yellow match those in red,
      while preserving the updated values where data may have been leaked.

      The \(\mathit{restore}\) function takes a contour and four states: the
      original call state, a variant call state, and corresponding return
      states, and returns another state. The resulting state restores those
      components that are high confidentiality to match the original call,
      unless they were changed during execution:
      \[\mathit{restore}(\contour,\mach_e,\mach_e',\mach_r,\mach_r')(\component) =
        \begin{cases}
          \mach_c(\component) & \text{if } \contour(\component) = (\HIGHSEC,\_) \text{ and } \\
                  & \mach_e(\component) = \mach_r(\component) \text{ and }
                    \mach_e'(\component) = \mach_r'(\component) \\
          \mach_r'(\component) & \text{else} \\
        \end{cases}\]

      A pair of traces \(\MPT\) and \(\machT\) starting from \(\mach_e\) and
      \(\mach_e'\), respectively, with \(\mach_e \approx_\contour \mach_r'\),
      enjoy observable trace confidentiality with respect to \(\contour\) if
      two conditions hold:

      The two traces are observationally equivalent: \(\pi_o(\MPT) \eqsim
      \pi_o(\machT)\).

      If \(\MPT\) is finite and ends with the state
      \(\mpostate{\mach_r}{\pol_r}{\obs_r}\), then \(\machT\) is finite. Let
      \(\mach_r'\) be the final state of \(\machT\). Then the induced traces
      \(\mpstate{\mach_r}{\pol_r} \hookrightarrow \MPT'\) and
      \(\mathit{restore}(\contour,\mach_e,\mach_e',\mach_r,\mach_r')
      \hookrightarrow \machT'\) are observationally prefixed,
      \(\pi_o(\MPT') \lesssim \pi_o(\machT')\).

      We write this \(\text{\sc ObsConf}_\contour ~ \MPT\).

    \definition{Observable Stack Confidentiality}

      From observable trace confidentiality we construct {\em observable stack
      confidentiality}. A system enjoys {\em observable stack confidentiality}
      with regard to \(\callmap\) and \(\codemap\) if for any initial state
      \(\mach_0\) and each transition with entry state
      \(\mpostate{\mach_e}{\pol_e}{\obs_e}\) and contour \(\contour\) in the
      induced trace from \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\), if
      \(\mpstate{\mach_e}{\pol_e} \hookrightarrow \MPT | \ret{\mach_e}\),
      then \(\text{\sc ObsConf}_\contour ~ \MPT\).


    \definition{Observable Stack Safety}
      A system enjoys {\em observable stack safety} with regard to a call map
      and a code map if it enjoys both observable integrity and observable
      confidentiality with regard to them.


\section{Related Work}
\label{sec:relwork}

\section{Future Work}
\label{sec:future}

\section{Discussion}

\bcp{Make this a subsection?}
\label{sec:disc}


  \paragraph{What about tail recursion and other non-stack-like control flow}

\bcp{And this and the next belong in Future Work...}

  \paragraph{Adding Heap Safety}

    While these ideas are here presented in a stack-centric style, they could
    be extended to heap safety in a system extended with a heap. Heap safety,
    like stack safety, may be framed as a form of noninterference
    [cite Meaning of Memory Safety]. For each certain component marked as
    containing a valid pointer to a heap object, we can propagate that
    validity when the pointer moves or is used in pointer arithmetic. Heap
    objects to which a valid pointer is in a register are reachable, and
    treated as low confidentiality and low integrity.

We've assumed that callees always have less access than their callers, but
in real systems things are more complicated (because of objects, static
variables in C, software compartmentalization, coroutines, ...).  What we've
defined is a very ``pure'' variant of stack safety.  In future work, we
should go further. :-)


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
\bibliography{bcp.bib,local.bib}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
