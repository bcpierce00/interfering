\documentclass[conference]{IEEEtran}
\input{macros}

\begin{document}

\title{Interfering with Noninterference
\iftext\thanks{\bcp{Identify applicable funding agencies here (DARPA and NSF
    and...?)}}\fi
}

\iftext
\IEEEauthorblockN{Leonidas Lampropoulos}
\IEEEauthorblockA{\textit{University of Maryland \bcp{right?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\author{\IEEEauthorblockN{Roberto Blanco}
\IEEEauthorblockA{\textit{\bcp{affiliation?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
\and
\IEEEauthorblockN{Benjamin C. Pierce}
\IEEEauthorblockA{\textit{University of Pennsylvania}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\IEEEauthorblockN{Andrew Tolmach}
\IEEEauthorblockA{\textit{Portland State University}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
}
\fi

\maketitle

\iftext
\begin{abstract}
\end{abstract}

\begin{IEEEkeywords}
% component, formatting, style, styling, insert
\end{IEEEkeywords}
\fi

\iftext
\section{Introduction}

\bcp{How about coining the term ``lockstep noninterference'' and then saying
that we study several variants...?}

\fi

\section{Preliminaries}

\subsection{Machine model}

Concretely, we have in mind a conventional machine architecture with a
RISC-V processor, perhaps extended with some kind of hardware-enforced
security policy, but we won't need any RISC-V-specific details till we get
to \cref{impl}.

Conventions:
%
\begin{itemize}
\item Words / addresses: $\word,\addr \in \WORDS$
\item Registers: $\reg \in \REGS$
\item Machine components: $\component \in \WORDS \cup \REGS \cup \{
\textsc{pc} \}$
\item Machine states: $\mach \in \MACHS = \COMPONENTS\rightarrow\WORDS$
\end{itemize}

% \bcp{Now we need to define {\em property} formally.  But since we're talking
% about hyperproperties, I'm not certain how to go about it.  The standard way
% would be something like ``A policy $P$ has property $Q$ (i.e., $P$ is
% noninterfering) if, for every pair of traces $\trace{M}$ and $\trace{M'}$
% in $P \times P$, if the initial states $M_0$ and $M'_0$ differ only in
% high parts then every pair ...'' (blah: I'm not sure whether to talk about
% lockstep-corresponding states, which seems too restrictive, or final states,
% which doesn't work if the traces are infinite!  do we really need some kind
% of reactive noninterference here?? Urg.)  (Well, no, we can just do
% a flavor of termination-insensitive NI, which says that all infinite traces
% are indistinguishable from anything...?)}

% \bcp{Should we start from a notion of ``variant traces'' and then talk about
% pairs of variant traces being ``distinguishable'' and then go to the full
% thing?}

The {\em underlying} step function, $\mathord{\stepstounderfull} \in \MACHS
\rightarrow \MACHS$, embodies the standard RISC-V ISA semantics.

% \bcp{Needed?}A {\em trace} $\trace{M}$ is a nonempty, finite or infinite
% sequence of machine states $\mach_0, \mach_1, \mach_2, ...$ such that
% $\mach_{i-1} \stepsto \mach_i$, for each $i \geq 1$.

\subsection{Contours}

\iftext
Intuitively, we use the word {\em policy} for any kind of dynamic
enforcement mechanism (e.g., a runtime taint tracker, heap coloring rules,
capability hardware, etc.). We use {\em property} for a mathematical
predicate on programs (i.e., machine states) articulating some useful
security goal, e.g. noninterference. \iftext\bcp{Not quite true, if we stick
  with hyperproperties.} \fi
\fi

A {\em contour}
$\contour \in \CONTOURS = \COMPONENTS \rightarrow \{\VIS,\HID\}$ is a map
from machine components to ``observabilities,'' where
$\VIS$ marks locations whose contents are observable from the outside (by
the ``attacker,'' e.g., by DMA) and $\HID$ marks internal ``hidden''
state that cannot be observed directly (e.g., processor registers and memory
addresses for temporary variables will usually be hidden).

A {\em contoured trace} of length $n$, where $n$ can be finite or
infinite, is a length-$n$ sequence $\seq{(\contour,\mach)}_n =
(\contour_0,\mach_0),\, (\contour_1,\mach_1),\ldots$ of (contour,
machine state) pairs in which adjacent machine states are related by
$\stepstounderfull$---i.e., in which $\mach_{i-1} \stepstounderfull
\mach_i$ for each $i > 0$ in the sequence.

 
\subsection{Observations}
 
A {\em component observation} is either a word or the special value $\bot$.
A {\em state observation} is a map from machine components to component
observations.
 
An {\em observation} is a nonempty, finite or infinite sequence of state
observations in which (1) adjacent elements are always distinct (``no
stuttering'') and (2) any component $\component$ that is mapped to $\bot$ by
the the $j^{th}$ state observation in the sequence must also be mapped to
$\bot$ by all observations earlier than $j$ in the sequence (i.e., once a
component's value changes from $\bot$ to anything else, it never changes
back to $\bot$ again).
 
In particular, the observation $\obstrace(\seq{(\contour,\mach)})$ arising
from a contoured trace $\seq{(\contour,\mach)}$ is sequence of state
observations $\stateobs_0,\, \stateobs_1,\, \ldots$ defined informally as
follows:
\begin{itemize}
\item $\stateobs_0$ maps every visible component (where $\contour_0 = \VIS$)
to its value in $\mach_0$ and every hidden
component to $\bot$; 
\item $\stateobs_{i+1}$ is defined from $\stateobs_{i}$ by (1) for each
visible component (where $\contour_{i+1} = \VIS$), copying its
value from $\mach_{i+1}$, and (2) for each
hidden component, where $\contour_i = \VIS$, copying its
value from $\stateobs_{i+1}$\apt{$\stateobs_i$ ?}, and (3) if the resulting $\stateobs_{i+1}$ is
identical to $\stateobs_{i}$, then skipping $\stateobs_{i+1}$.
\iftext\bcp{Too informal!!}\fi
\end{itemize}

% For each component $\component$,
% %
% if
% $\contour_i(\component) = (\underscore,\HID)$ for all $i$, then
% $\obstrace(\component) = [\,]$;
% %
% otherwise, $\obstrace(\component)$ is a sequence whose first element
% is $\mach_i(\component)$ for the smallest $i$ such that
% $\contour_i(\component) = (\underscore,\VIS)$ and whose $(m+1)^{th}$ element
% (if any) is $\mach_j(\component)$, where $j$ is the smallest index greater
% than the index $i$ of the $m^{th}$ element and such that
% $\contour_j(\component) = (\underscore,\VIS)$ and
% $\mach_j(\component) \neq \mach_i(\component)$.
% %
% \bcp{Can be defined more simply}
% \iftext
% \bcp{Unfinished and horrible...  But maybe the textual description is OK?}
% \newcommand{\aux}{\mathit{aux}}
% \bcp{Don't like the ``rest'' argument and the fact that we don't
%   have a metavariable for sequences of (contour, machine state) pairs.
%   Consider defining one.}
% %
% \[
% \begin{array}{lcl}
% \aux \; ( [\,] ) \; \trace& = & \trace
% \\
% \aux \; ( (\contour,\mach) \mathrel{::} \mathit{rest} ) \; T
%   & = &
%         \aux \;( \mathit{rest} )
%         \\ && \quad (\lambda k.\; \mbox{\bcp{and so on}}
% \\
% \\
% \obstrace \;( (\contour_0,\mach_0),\, \ldots )
%   &=& \aux \; ( (\contour_0,\mach_0),\, \ldots ) \; (\lambda
%       \component.\, \bot)
% \end{array}
% \]
% \fi

% \bcp{Maybe make it a sequence of maps from components to values?  This is
%   simpler, but it means we can ``observe the observbility of locations...''
%   But is this too unrealistic?}

\iftext\bcp{Emphasize that ``observability is not observable.''}\fi

\subsection{Properties}

% A {\em contoured (hyper)property} is a function that takes a contour to a
% hyperproperty.  That is, it takes a starting contour and produces a
% \bcp{prefix-closed?} set of pairs of sequences of machine states.

% An {\em observer} $\observer \in CONTOURS \rightarrow (\MA \exists X.\; (\CONTOURS \rightarrow X) \times
% (X \rightarrow \CONTOURS) \times (\MACHS \times X \rightharpoonup \MACHS
% \times X) $
% comprises
% \begin{enumerate*}
%   \item a private type $X$,
%   \item a function taking a contour to an initial value of $X$, and
%   \item a function that allows ``reading off'' a contour from an $X$, and
%   \item a partial step function of type
%   $(\MACHS \times X) \rightharpoonup X$.
% \end{enumerate*}

A {\em contoured hyperproperty} is a set of pairs of contoured
traces.

A {\em contoured lockstep-hyperproperty} is a contoured hyperproperty
such that:

\leo{Informally first, I don't like it too much:}
\begin{itemize}
\item each trace in every pair of a contoured trace in the set have the
  same length, and
\item each pair of elements in every pair of a contoured trace in the
  set have the same contour.
\end{itemize}

\leo{Formally:}
\begin{itemize}
\item {\em same-length:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C',
    M')}_m$ in the set, $n = m$.

\item {\em contour-lockstep:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C',
    M')}_n$ in the set, $C_i = C_i'$ for all $i<n$.
\end{itemize}

\subsection{Noninterference}

\leo{Indistinguishability/variations:}

Given a machine state $\mach$ and a contour $\contour$, a {\em
  variant} of $\mach$ with respect to $\contour$ is any machine state
$\mach'$ whose components agree with $\mach$ on all components marked
$\VIS$ by $\contour$---i.e., if $\contour(\component) = \VIS$, then
$\mach(\component) = \mach'(\component)$.

\leo{Normal lockstep noninterference:}

(Lockstep-)Noninterference is the contoured lockstep hyperproperty
where:
\begin{itemize}
\item For each pair of traces in the hyperproperty, all the contours
  coincide.\apt{This is still a bit ambiguous. How about: For each pair of
    contoured traces in the hyperproperty, the contour is invariant 
    along each trace.}
  \item For each pair of contoured traces in the hyperproperty, if the
    initial elements of the traces are variants, then the observervations
    of the two traces coincide.
\end{itemize}

\leo{Nested lockstep noninterference:}

Generalizing to allow for contours to change throughout the execution,
nested lockstep noninterference is the contoured lockstep hyperproperty
where: \bcp{Which parts of this are common to {\em all} contoured lockstep
  hyperproperties (i.e., which should be part of the definition of contoured
  lockstep hyperproperties) and which are specific to (nested) NI?}
\leo{I'd say contoured lockstep hyperproperties are as above - and the following are
  the generalization for nested ones.}

\begin{itemize}
\item {\em prefix-closed:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C,
    M')}_n$ in the set, \bcp{where $n$ is the length of the traces,}\leo{Yes I put that in the definition of traces above, but we could repeat it here} the
  pair of truncated traces $\overline{(C, 
    M)}_m$ and $\overline{(C, M')}_m$ is also in the set if $m < n$ \bcp{or
    $n = \infty$}. 

\item {\em suffix-closed:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C,
    M')}_n$ in the set, and for every $0 \leq i < n$, there exists in
  the set a pair of traces $\overline{(C', N)}_m$ and $\overline{(C',
    N')}_m$ such that $C_0' = C_i$, $N_0 = M_i$, and $N_0' = M_i'$.
  \apt{I don't see how we can leave $m$ unspecified: doesn't it need to be as long as possible subject to well-formedness? Also, the evolution of $C$ is not determined by the machine, so don't we need $C_j' = C_{i+j}$ for all $0 \leq j < m$ ? }
  
\item {\em variant-closed:}

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C,
    M')}_n$ in the set, and for every machine state $N_0$ such that
  $N_0$ is a variant of $M_0$, there exists in the set a pair of
  traces $\overline{(C, M)}_m$ and $\overline{(C, N)}_m$.\apt{Same complaint about $n$. And again, $N_0$ defines $\overline{N}$ but it doesn't define $\overline{(C,N)}$. }

\item {\em contour-wellformedness:}  

  For every pair of traces $\overline{(C, M)}_n$ and $\overline{(C,
    M')}_n$ in the set, $C_0 \leq C_i$ for all $i<n$, where $C \leq
  C'$ if $\forall \component, C(\component) \leq C'(\component)$ and
  $\VIS < \HID$.
  \apt{Isn't this effectively still a negation in the functor? I thought for strategy for describing execution after a Return was to apply suffix closure to the original full trace -- but doesn't this criterion rule out the original full trace?}

\item {\em as in noninterfence:}

  For each pair of traces in the hyperproperty, if the initial machine
  states plus contour \apt{``elements''} are variants, then the observervations of the
  two traces coincide.
  
\end{itemize}

\bcp{It feels like something is missing here: This definition seems to be
  requiring that secret data never affect observations, but our tester is
  ensuring something more: that inaccessible locations are not {\em changed}
(at least without also changing their tag to make them accessible).  Where
  is that condition being imposed?}
\leo{It's not - I just went by the definition of (traditional) noninterference
  you had and repeated that. I'm thinking about that now}

\apt{Even if it works for subroutines,
  the basic idea of truncating traces when visibility increases doesn't 
  seem to extend to things like coroutines, where we swap between two sets of visible locations on each transfer.}

% \bcp{Should we require that it contain all possible starting states and
%   contours (though of course the sequences can be singletons in many
%   cases!)?  What does it mean if it doesn't?}

\bcp{Policies and properties need to know where are the call and return
  sites, and for this they need to be initialized with some
  application-specific information.  So it seems what we should do is to
  talk instead about ``$X$ policies'' (i.e., make ``policy'' a type
  operator) and replace the initial $\CONTOURS$ argument to both policies
  and properties by an element of $X$.}


%  
% \leo{Some notes for the meeting}
%  
% In traditional NI viewed as a pair of contoured traces $\overline{(C, M_i)}$ and
% $\overline{(C, N_i)}$, we can have the following formulations:
% \begin{enumerate}
% \item $M_0, N_0 \in \mathit{Initial State}, ~\text{s.t.} ~\mathit{variant}(C, M_0, N_0)$
% \item $M_0 \in \mathit{Initial State}, N_0 \in \mathit{Variant}(C, M_0)$
% \item $M_0, N_0 \in \mathit{Reachable State}, ~\text{s.t.} ~\mathit{variant}(C, M_0, N_0)$
% \item $M_0 \in \mathit{Reachable State}, N_0 \in \mathit{Variant}(C, M_0)$
% \end{enumerate}
% %
% The (intuitive) top level property we care about is (1) - end to end
% noninterference.
% %
% Property (2) is easier to test - but not always equivalent (if the set
% of variants of an initial state can take you outside the set of
% initial states).
% %
% Property (3) is also easier to test than - you start from an arbitrary
% (reachable) state instead of an initial one, allowing to get to the
% interesting part sooner.
% %
% Property (4) corresponds to what we actually want to test - start from
% an arbitrary (reachable) state, vary it, test the trace.
%  
% As far as facilitating testing goes, the assumption of SSNI is that
% you don't need to test full traces - you can test all traces of length
% 1 and that somehow gives you confidence for the full property.
% %
% More importantly, note that going from (1,2) to (3,4) doesn't really
% change the property itself {\em as long as the contour stays identical
%   throughout the execution}.
%  
% Now, when the contour does change the expressive power of (3,4) and (1,2)
% is slightly different:
% \begin{itemize}
% \item If the contour C makes more things hidden at step $i$, then
%   starting from the (reachable) state $M_i$ and taking its variant can
%   lead to a pair $M_i, N_i$ that is not reachable from a pair of variant
%   initial states.
% \item If the contour C declassifies things at step $i$, then traces
%   that started from variants $M_0, N_0$ based on a more restrictive
%   contour C, can reach that point and no longer remain variant based
%   on the new contour.
% \end{itemize}
% Therefore an additional property of the hyperproperties when
% classification/declassification is involved, is that the traces
% in the property start at some contour level C0 and are truncated
% after C becomes more permissive than C0.
%  
% The stack property we test is just a way of testing such a
% hyperproperty more efficiently.



% If $\mach$ and $\mach'$ are variant machine states with respect to contour
% $\contour$, then $\mach$ and $\mach'$ are said to be {\em indistinguishable}
% under policy $\pol$ if their observable
% %
% $\obstrace(
%                       (\contour,\mach)
%   \stepstounder{\pol} (\contour_1,\mach_1)
%   \stepstounder{\pol} (\contour_2,\mach_2)
%   \stepstounder{\pol} \ldots)$
% %
% yields the same trace as
% $\obstrace(
%                       (\contour,\mach')
%   \stepstounder{\pol} (\contour_1,\mach_1')
%   \stepstounder{\pol} (\contour_2,\mach_2')
%   \stepstounder{\pol} \ldots)$.

% % either (1) one or both of $(\contour,\mach)$ and
% % $(\contour,\mach')$ fail to terminate when executed with
% % $\stepstounder{\pol}$, or (2) both terminate and the machine-state
% % components of their results are variants with respect to the original
% % $\contour$.

\iftext
\begin{itemize}
\item \bcp{Should we be talking about end-to-end or single-step NI?  I guess we
  have to begin with EENI and then get to SSNI as a (stronger) refinement.}

\item Relation to the standard definition of NI.
\end{itemize}
\fi

% Policy $\pol$ {\em guarantees noninterference} if, for every $\contour$,
% every pair $(\mach,\mach')$ of variant machine states with respect to
% $\contour$ are indistinguishable under $\pol$.

\iftext
\bcp{
Fact: The standard RISC-V semantics (i.e., the null policy) does not
guarantee NI.  (Give a little example of a program that reads from a secret
location and writes to a public one, just to illustrate the definition of
NI.)}
\fi

\subsection{Policies}

\leo{I think with the property being just a (special) hyperproperty
  again, the policy can be ``more detailed'' - including low-level
  enforcement details like tags, etc. But you should always be able to
  reconstruct the contoured trace given an initial contour and an
  initial state. I'm taking that approach here:}

Formally, a policy
%
$\pol \in \exists X.\; (\CONTOURS \rightarrow X)
                       \times (X \rightarrow \CONTOURS)
                       \times (\MACHS \times X \rightharpoonup \MACHS \times X)$
%
comprises
\begin{enumerate*}
  \item a private type $X$ corresponding to an ``implementation'' of the contour,
  \item an initializer: a function taking a contour \leo{and a machine state?} to an initial value of $X$,
  \item a projection: a way of reading a contour out of the private type,
  \item a partial step function of type $(\MACHS \times X) \rightharpoonup X$
    that, when defined, defines the private state after a step of the machine
    (based on the $\stepstounderfull$ relation).
    \leo{Not sure this should be taking $\MACHS$ as input. It should take $X$
      plus just the instruction being executed? The rest are the tags in $X$}
\end{enumerate*}
That is, a policy takes a starting contour and produces a runtime monitor
that carries along some private information and uses it to decide whether to
terminate execution early.

\leo{Example? how detailed?}  For example, for standard
lockstep-noninterference with only two secrecy levels, the private
state {\em is} the contour.

A policy $\pol$ {\em guarantees} property $\prop$ if for every pair of
states $M$ and $M'$ and for every starting contour $C$, the pair of
contoured traces that you get from the policy is in the property.

\leo{New attempt ends here}
Informally, a (micro-){\em policy} is an enriched step function that,
whenever is is defined, agrees with $\stepstounderfull$.  It represents an
enforcement mechanism that sometimes halts programs earlier than the bare
step relation does but that agrees with the bare step relation as long as it
allows evaluation to proceed.  We write
$(\contour_1,\mach_1) \stepstounder{\pol} (\contour_2,\mach_2)$ for
$\pol(\contour_1,\mach_1) = (\contour_2,\mach_2)$.

\leo{Shouldn't this take a pair (C,M) to a pair (C,M)?}
Formally, a policy
%
$\pol \in \CONTOURS \rightarrow \MACHS \rightarrow \SEQ{\MACHS}$
%
takes a contour $\contour$ and a starting machine state $\mach_0$ and produces
a finite or infinite sequence of states $\mach_0,\,\mach_1 ,\, \ldots$ such
that $\mach_{i-1} \stepstounderfull \mach_i$ for each $i > 0$ in the sequence.

% \bcp{Fix: even simpler and cleaner, just run the step function to completion
%   and forget about $X$---i.e., a property is just a function from a pair of
%   a contour and a machine state to a finite or infinite sequence of machine
%   states!}
% Formally, a policy
% %
% $\pol \in \exists X.\; (\CONTOURS \rightarrow X) \times (\MACHS \times X
% \rightharpoonup \MACHS \times X)$
% %
% comprises
% \begin{enumerate*}
%   \item a private type $X$,
%   \item a function taking a contour to an initial value of $X$, and
%   \item a partial step function of type
%   $(\MACHS \times X) \rightharpoonup (\MACHS \times X)$ that, when defined,
%   agrees with $\stepstounderfull$ on machine states. \bcp{We could actually
%     just make it return an X and calculate the machine state from the
%     ordinary step function.  This is perhaps a bit cleaner.}
% \end{enumerate*}
% That is, a policy takes a starting contour and produces a runtime monitor
% that carries along some private information and uses it to decide whether to
% terminate execution early.

Policy $\pol$ {\em guarantees} property $\prop$ if \bcp{for every pair of
  starting states and every starting contour, the pair of traces that you
  get from the policy is in the property for {\em some} pair of sequences of
  contours that agree with the given contour on the first element.}

% every $\contour$,
% every pair $(\mach,\mach')$ of variant machine states with respect to
% $\contour$ are indistinguishable under $\pol$.


\iftext
\subsection{More...}
  \begin{itemize}
  \item Proposal: Maybe forget about full-blown NI and focus the whole paper
  on variants of ``lockstep NI'' where the PC is the same in every pair of
  related runs?
  \item One issue that I am not sure about: Could there be a sneaky way of
  ``putting secret information into the control state'' where the PCs of
  related runs are always in lockstep but, because the instruction memory is
  writeable, different instructions can get dispatched.

  E.g., suppose the program looks like
\begin{verbatim}
0:   load from address 1000
     write to address 100
     jump to address 100
100: <initial contents don't matter>
     write R3 into address 1004
     jump to address 100
1000: <marked HIGH so that initial
       contents vary on different runs>
1004: <marked OBSERVABLE>
\end{verbatim}
  If the initial contents of address 1000 in one run is the encoding of the
  instruction ``load immediate 0 into R3'' and the initial contents in the
  other run is the encoding of the instruction ``load immediate 1 into R3,''
  then the two programs execute different instructions (leading them to
  write different things to an observable location) even though their PCs
  are always in lock step.

  So maybe we should be asking that the instruction stream be
  identical, or maybe instructions paired with PCs?

  \bcp{Answer: Just make instructions read-only.}

  \item One nice observation is that, if we are only interested in pairs of
  runs with identical PCs, there are two different ways to proceed: (1) say
  that we {\em ignore} runs where the PCs (or instruction streams) diverge
  (e.g., taint tracking), or (2) {\em disallow} runs where the PCs (or
  instruction streams) diverge, i.e., demand that this never happens (e.g.,
  stack and heap policies).
  \item A remaining question is what to do about the possibility that the
  contour changes differently on two related runs.  We could disallow this,
  but not certain it's necessary---maybe everything works out OK.
  \end{itemize}
\fi

\newpage
\section{Tainting is noninterference$-$}

\bcp{This needs to be written, now that we have added the hidden/observable stuff.}

\begin{itemize}
\item First intuition: A program is taint-NI if every pair of runs that don’t
branch on high data are noninterfering in the standard sense.  (i.e., they
don't write secret data to public locations and vice versa)
\item Better alternative: … for every pair of runs that take the same control path (even if they branch on tainted data)...
\item We could even go a step farther: {\em truncate} the runs at the
  first point where their PCs differ, then demand NI.  This is a less
  demanding property and probably a less desirable one, as it doesn't
  predict the behavior of actual taint policies.  Discuss.
\item Note that this is a super-simple property that doesn't really track
taint at all.
\item (Are there any other variations of tainting that we could present in
this framework?)
\end{itemize}


\section{Separation is noninterference$+$}

Presentation idea: Start here with a super-simple separation policy, which
just makes some part of the address space inaccessible, truncating any
traces that read or write it.  Formulate the property as a flavor of NI.
(The $+$ part in the title is a hint that one thing that gets added is that
the PCs of corresponding traces always stay in lock step.)

\section{Stack protection is noninterference$++$}

Here we consider stack protection as an instance of generalized noninterference \apt{or whatever it's called}.
Our notion of stack protection includes aspects both of control integrity and data security.
In the terminology of Skorstengaard et al.~\cite{Skorstengaard+19} we enforce:

\begin{itemize}
\item \emph{Well-bracketed control flow (WBCF)}, which says that ``invoked functions must either return to their callers,
  invoke other functions themselves, or diverge.''
\item \emph{Local state encapsulation (LSE)}, which says that ``when a function invokes another function, its local variables
  (saved on its stack frame) will not be read or modified until the invoked function returns.''
\end{itemize}
\apt{Should rephrase (and improve!) these in our own words.}

These properties are essentially orthogonal: we could enforce WBCF without LSE, and variants of
LSE could apply to control constructs beyond simple procedure calls (e.g. exceptions, coroutines, threads, monitors, etc.).


In terms of NI....
\apt{Perhaps the NI-like property is just LSE, but it holds only if WBCF holds?}

To make these ideas concrete in this paper, we adopt a very simple (and unrealistic) set of assumptions/conventions for stack frames and procedure calls.
Each procedure stack frame contains just one local variable (plus possible control information), which is pointed to by
the SP whenever the PC is within the procedure body (excluding entry and exit sequences). Our WBCF property says that
when a procedure is called from a given PC at a given SP, it eventually returns (if at all) to the next
address following the PC with the same SP. Our LSE-like property says that addresses between the base of the stack
up to (but not including) the current SP cannot be read or written.
\apt{Not clear why we should bother allowing addresses beyond the current top of stack to be accessible.}
In particular, this implies that upon return from a call,
the value of the local variable will be unchanged; moreover, the values of local variables cannot influence the
behavior of callees. Parameters and return values are passed in registers, which (except for SP and RA) do not change
during call or return.

{\bf Getting more precise about the property.}

Assumptions on code and environment\apt{trying to be as minimal as possible}:
\begin{itemize}
\item
  Memory is divided into two disjoint regions, one containing the code, the other the stack.
  Code begins at address 0; the stack begins at address B and grows up, in the direction of increasing addresses.
\item
  The part of the stack between $B$ and the stack pointer \textsc{sp} (inclusive) is structured into a contiguous sequence of
  \emph{frames}. Each frame contains a single word of local data, possibly preceded by control information. \apt{TMI?}
  The initial value of \textsc{sp} is $B-1$.
\item
  Code is assumed to be be annotated to indicate (a) instructions representing calls, (b) instructions forming the \emph{entry sequence} of
  a procedure, and (c) instructions forming the \emph{return sequence} of a procedure.
\item
  Execution of the entry sequence pushes a new frame on the stack, adjusting \textsc{sp} to point to that
  frame's data word.  Execution of the return sequence pops the frame on top of the stack by readjusting \textsc{sp}.
  \apt{TMI!?}
  Outside of the entry and return sequences, no instruction alters \textsc{sp}.
\item
  The call instruction and entry and return sequences do not alter any registers except \textsc{sp} and one
  particular register named \textsc{ra}.
\end{itemize}

DO HERE: Formal description of conjecture 2 property.  Or maybe we no longer really care about this particular property if we have something for conjecture 3?

An (abstract) \emph{state description} $D$ consists of
\begin{itemize}
\item
  A stack $\dstk{D}$ of addresses, representing the return addresses of the current procedure and its callers.
  \apt{No need to remember the sp's, since they can be computed given that we know the fixed frame size.}
  \apt{No need for $\dpcd{D}$ since it is just the size of $\dstk{D}$.}
\item
  For each memory location $a \geq B$, a natural number $\ddep{D}{a}$, representing the depth
  of the frame to which $a$ belongs ($\infty$ if none).
\end{itemize}

The \emph{initial state description} $\dinit$ has $\dstk{\dinit} = \empstack$ and $\ddep{\dinit}{a} = \infty$ for all $a \geq B$.

An address $a$ is \emph{accessible} with respect to a state $D$, written $\access{D}{a}$, if
$a \geq B$ and $\ddep{D}{a} \geq \norm{\dstk{D}}$.


TODO:
\begin{itemize}
\item
  Define step relation.
\item
  Define step consistency.
\item
  Discuss relationship between state consistency and top-level property.  (Former is: presumably stronger; hopefully not
  too strong that it produces lots of undesired test failures; surely easier to test).

\end{itemize}


\iftext
\section{Stack + heap protection too}

POTENTIALLY: Memory safety (before stack) + Conjunction of memory + stack
safety (after).

(Memory safety by itself is just arthur’s paper, but it’s cool to see how
they are combined, especially what bits can be factored out as common
structure, e.g. the notion of accessibility)
\fi

\section{Implementation}
\label{impl}

Sketch of the micropolicies that claim to implement these properties on
PIPE...

\subsection{A taint checking monitor}

\subsection{A stack safety monitor}

\section{Testing the implementations}

\begin{itemize}
\item Experimental results of testing
\end{itemize}

\section{Related work}

\begin{itemize}
\item Daniel's tainting paper (and some refs cited there)
\item Nick and Andre's papers (and other micropolicy papers)
\item StkTokens: Skorstengaard, Devriese, Birkedal
\begin{itemize}
\item {https://arxiv.org/pdf/1811.02787.pdf}
\item {https://arxiv.org/pdf/1902.05283.pdf}
\item {http://cs.au.dk/~lask/papers/esop2018.pdf}
\item {https://dl.acm.org/doi/fullHtml/10.1145/3363519}
\end{itemize}

\item Simple Noninterference by Normalization {http://nachivpn.me/nibnbe.pdf}

\item Mechanized Reasoning about a Capability Machine: [Linn] Georges,
Trieu, Birkedal (PriSC 2020).
%
Described at the Iris Workshop as formalizing the security properties of
capabilities. This appears to involve a fairly complex and very large
mechanization in Iris (also in the eyes of the Iris people).
\end{itemize}

\iftext
\section{Future work}

\begin{itemize}
\item Variations / extensions (OS, multiple processes, coroutines, generalizing depths to stacks of static call points, etc.)
\item Extending the policy / property to more realistic ones
\begin{itemize}
\item Argument passing
\item Variable-size stack frames
\item Stack variables
\item Relation to Nick and Andre’s policy
\end{itemize}
\item Could we also implement all this using Cheri capabilities?
\end{itemize}

More:
\begin{itemize}
\item More realistic calling conventions.  (We need to eventually match this to the particular calling convention of whatever compiler we choose.)  E.g., the above will not quite work for passing arguments on the stack: callee won’t be able to read them…So perhaps need to support a special kind of write instruction that stores D.PCdepth+1 . [RB: Or implement this distinction through tags?]
\item Combination with heap policy (colors, etc.)
\item For coroutines:
\begin{itemize}
\item Generalize depth to depth + PID
\item Private stuff not having changed as an idea should still work
\item Maybe not so hard: The scheduler + other coroutines are just a sort of generalized “callee” as far as this process is concerned.  Just need to fiddle th step relation so that it recognizes which process is getting returned to and updates its description appropriately.
\end{itemize}
\item If we had a heap policy, maybe we could talk about dynamic code generation, loading, as allocating a heap region, storing instructions into it, and then calling into them.  For now, we just make all the instructions read only and assume they exist in the initial state.
\item Question: how efficiently can consistency be tested? How much scrambling is needed, and does it really need to occur before every instruction? How expensive is it to check for agreement between the (in)accessible parts of two memories?  Would spot checking for agreement be adequate?]
\item What are the effects of compartmentalization on the ability of each compartment to change its own code/stack?
\item Tail calls (maybe by not marking them as call sites?)
\end{itemize}

\section*{Acknowledgments}
\fi

\section*{References}
\bibliographystyle{IEEEtran}
% \bibliography{bcp,local}

\newpage

\section*{Things to think about}

\begin{itemize}
\item
How does Nick’s stack policy actually work these days?
\item Andrew remembers that Catalin looked at something like this a long time ago and they decided that they needed unique tags for each dynamic call, not just levels.  We should check.
\end{itemize}

\end{document}
