%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\input{macros}

\begin{document}

%% Title information
\title{Stack Safety as a Security Property}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
%\author{First1 Last1}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
%  \institution{Institution1}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{Country1}                    %% \country is recommended
%}
%\email{first1.last1@inst1.edu}          %% \email is recommended
%
%%% Author with two affiliations and emails.
%\author{First2 Last2}
%\authornote{with author2 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
%\affiliation{
%  \position{Position2a}
%  \department{Department2a}             %% \department is recommended
%  \institution{Institution2a}           %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
%  \country{Country2a}                   %% \country is recommended
%}
%\email{first2.last2@inst2a.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Stack Safety, Micropolicy, Random Testing, RISC-V}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}

\newcommand*{\MemoryLabel}[3]{\raisebox{#2}{\makebox(0,0){\hspace{#1}#3}}}

\begin{figure}
  \begin{minipage}{\textwidth}
    \begin{center}
\MemoryLabel{10em}{1.5em}{40}
\MemoryLabel{16em}{1.5em}{60}
\MemoryLabel{22em}{1.5em}{80}
$\cdots$
\memory{4}{gray}%
\memory{5}{green}[{\makebox[0pt]{Caller}}]%
\memory{5}{yellow}[{\makebox[0pt]{Args}}]%
\memory{8}{red}[{\makebox[0pt]{Callee}}]%
\memory{4}{gray}%
~$\cdots$\\
  \end{center}
  \end{minipage}\\
~\\
~\\
  \begin{minipage}{0.45\textwidth}
    \begin{center}
\begin{verbatim}
jal ...
lw r1 r0 40
\end{verbatim}
    \end{center}
  \end{minipage}~
  \begin{minipage}{0.45\textwidth}
    \begin{center}
\begin{verbatim}
jal ...
sw r0 r0 40
\end{verbatim}
    \end{center}
  \end{minipage}
  \caption{Examples of Unsafe Programs}
  \label{fig:stackunsafety}
\end{figure}

\leo{I hate the writing here, but I wanted to make a start.}

The call stack is an increasingly popular target for attacks
exploiting memory safety vulnerabilities, with potential consequences
ranging from attackers reading or corrupting private stack data, to
highjacking a program's control flow. To prevent such attacks, many
techniques have been proposed in the literature\leo{cite, point out?
  stack canaries, cherry, nicks...} aiming to achieve {\em stack
  safety}.

But what {\em is} stack safety? A precise formal definition of stack
safety is lacking from the literature, with the notion only being
defined negatively: through examples of stack unsafety. Two classical
examples of stack unsafety appear in Figure~\ref{fig:stackunsafety}.
\leo{Goal: on the left, a bad read; on the right, a bad write.}
\leo{Do we also need an example of ROP/control flow for the new part?}
Recently, a \leo{inspiring/awesome/something good} work reasoned
about a stack safety enforcement mechanism using capabilities\leo{cite};
while impressive, stack safety was defined with respect to an abstract
machine that ``exhibits stack safety by construction''. Which begs
the question, what {\em is} the property that holds by construction?

\leo{StackTokens} provides some intuition towards answering that question,
by informally describing two components that comprise stack safety:
local state encapsulation and well-bracketed control flow. In this paper
we turn this intuition into two formal \leo{extensional} security properties,
that together form a formal definition of stack safety.

The underlying notion behind local state encapsulation is the
intention to protect callers from callees: a callee should be not be
able to access or overwrite a caller's private data. We formalize this
intuition as a security property, with a confidentiality and an
integrity component.
%
At a high level, {\em stack confidentiality} ensures that a callee's
observable behavior is not affected by memory outside its stack frame
(e.g. a caller's private data or uninitialized memory).  {\em Stack
  integrity} guarantees that if a function call returns, the caller's
stack data will be identical to what it was before the call.

While integrity and confidentiality are relatively standard security
properties, this setting provides an interesting additional challenge:
the notion of who the attacker shifts throught execution. Not only
does a caller need to be protected from its callee, but the callee
itself needs to be potentially proteced from {\em its} callees.  In
this paper we address this challenge by varying the observation power
of the attacker at call points, and demonstrate that our policy is
implementable by pre-existing monitoring mechanisms.

Similarly, the underlying notion behind well-bracketed control flow is
the need to protect the call structure itself: a callee should not be
allowed to jump to the middle of an arbitrary block of code either
directly (via a jump instruction) or indirectly (by corrupting stack
data and returning). \leo{There needs to be some informal description
  of the wbcf part here. Sean?}

We begin by giving some background in Section~\ref{sec:prelim}.
Our contributions are:
\begin{itemize}
\item \leo{More? Extensional} formal characterizations of the
  intuitive concepts of local state encapsulation~\ref{sec:lse} and
  well-bracketed control flow~\ref{sec:wbcf}.  Evidence that this
  property is strong enough to capture the folk intuition: we show
  that the stack unsafe examples from the literature also fail our
  property.
\item Evidence that the property is not too strong. It's realizible by
  a previously proposed micropolicy enforcement
  mechanism~\ref{sec:micropolicy}. \leo{And it says yes on a
    substantial body of code} We then present a variation of the
  property + policy that is lazy, easier/more efficient to implement,
  and provably weaker.
\item A provably stronger (inductive? step-by-step/stepwise) variant
  of this property tuned for testing/verification.  We test the whole
  thing with a cool framework.
\end{itemize}
Finally, in Section~\ref{sec:relwork} we discuss related work and
sketch directions for future work in Section~\ref{sec:future}.

\section{Background}
\label{sec:prelim}

Before we define stack safety, we need to first set the stage by
describing our machine model. Concretely, we have in mind a
conventional machine architecture with a standard (RISC-V) processor
extended with some kind of (static or dynamic, software- or
hardware-enforced) security monitor. However, our definition of stack
safety is generic: we will begin with an abstract interface to our
machine model and only make specific choices about details when we get
to the policy enforcement section~\ref{sec:micropolicy}.

\paragraph*{Values, States, and Observations}

The basic building blocks of the machine are {\em values} and {\em
  addresses}. Both are drawn from some set of all possible words
$\WORDS$. We will denote words with $\word$.
%
Our machine states are comprised of {\em components}, that can be word
(denoting memory addresses) or registers (drawn from some set $\REGS$.
%
    \[\reg \in \REGS\]
    \[\component \in \COMPONENTS = \WORDS + \REGS \]
%
The registers must include two special purpose registers: the program
counter \PCname and the stack pointer \SP.
%
Formally, a machine state is just a map from components to values:
%
\[\mach \in \MACHS = \COMPONENTS \rightarrow \WORDS\]

Our stack safety property will be defined in terms of {\em
  observations}, which may be silent (written $\tau$) or a word of
data:\leo{Needs more exposition}
%
\[\obs \in \OBSS = \tau ~ | ~ \word \in \WORDS\]
%
These observations are a byproduct of the step function of the
machine, which takes a machine state and produces a pair of a
machine state and an observation.
%
\(\mach \stepstoobs{\obs} \mach' : \MACHS \rightarrow \MACHS \times \OBSS \).

\paragraph*{Policies}

A policy is a general model of an enforcement mechanism, consisting of
a set of policy states \(\pol \in \POLS\), and a policy step function
\((\mach, \pol) \stepstopol \pol' : \MACHS \times \POLS
\rightharpoonup \POLS\).

We write $\MPS$ for the set of all pairs of machine states and policy
states.
%
\[\MPS = \MACHS \times \POLS\]
%
We then lift this policy step function to operate on such pairs,
by combining it with the regular step function for machine states.

\judgmenttwo{\(\mach_1 \stepstoobs{\obs} \mach_2\)}{\((\mach_1, \pol_1) \stepstopol \pol_2\)}
            {\(\mpstate{\mach_1}{\pol_1} \stepstoobs{\obs}_P \mpstate{\mach_2}{\pol_2}\)}

\leo{Notation: Should $\stepstoobs{}$ use harpoon for the lifted step?}

\paragraph{Traces}

A trace over some type $A$ is a potentially infinite, nonempty
sequence of $A$s. We will mostly be concerned with sequences of
machines states, usually denoted $\machT$, and with sequences of
triples of (machine states, policy states, and observations), usually
denoted $\MPT$. To continue, we will require three generic operations
on traces: a ``trace-of'' operation to construct the potentially
infinite traced induced by a step relation; a ``split'', to break a
trace into two components based on a predicate; a ``join'', the
reverse of split; and a ``prefix'', as a shorthand to only keep the
first component of a split.

The ``trace-of'' operator, written \(\hookrightarrow\), coinductively
relates a machine state with the trace of machine states paired with
observations produced by repeated application of step:
%
\[\hookrightarrow : \machT \rightarrow \MOTRACE\]%
%
\judgmenttwo{\(\mach_0 \stepstoobs{\obs} \mach_1\)}{\(\mach_1 \hookrightarrow \machT\)}
            {\(\mach_0 \hookrightarrow (\mach_0,\obs) \machT\)}%
%
\noindent
Since the step function is total, if \(\mach \hookrightarrow \machT\),
then \(\machT\) must be infinite.

Similarly, we define \(\hookrightarrow_P\) to relate a machine-policy
state pair to the trace of triples of machine states, policy states,
and observations induced by by \(\stepstoobs{}_P\):
%
\[\hookrightarrow_P : \MACHS \times \POLS \rightarrow \MPOTRACE \]
%
\judgment{\(\neg \exists \pol_1 . \pol_0 \rightharpoonup \pol_1\)}
         {\(\mpstate{\mach_0}{\pol_0} \hookrightarrow \mpostate{\mach_0}{\pol_0}{\tau}\)}
%  
\judgmentthree{\(\mach_0 \stepstoobs{\obs} \mach_1\)}
              {\(\pol_0 \rightharpoonup \pol_1\)}
              {\(\mpstate{\mach_1}{\pol_1} \hookrightarrow \machT\)}
              {\(\mpstate{\mach_0}{\pol_0} \hookrightarrow_P \mpostate{\mach_0}{\pol_0}{\obs} \machT\)}
We will also use \(\pi_m\) to project the trace of machine states
out of a trace, \(\pi_p\) to project the trace of policy states, and
\(\pi_o\) to project the observations.

The {\it prefUpTo} operation \(\PUT(\Trace,f)\) takes a trace \(T\)
and a predicate on elements \(f\) and gives the prefix of \(T\)
ending with the first element on which \(f\) holds, coinductively:

\judgment{\(f\ \traceelem\)}
         {\(\PUT(f,\traceelem\Trace) = \traceelem\)}
%
\judgment{}
         {\(\PUT(f,\traceelem) = \traceelem\)}
%
\judgmenttwo{\(\neg f\ \traceelem\)}{\(\PUT(f,\Trace) = \Trace'\)}
            {\(\PUT(f,\traceelem\Trace) = \traceelem\Trace'\)}
%
Note that if the resulting trace is a strict prefix of the parameter, then the
predicate must hold on its final element. Conversely, if the predicate never
holds, \(\PUT\) is the identity function.

% The {\it join} operation, written \(T_1 \cdot T_2\) is the reverse of
%$\mathit{split}$: it takes two traces and links them by replacing the
%last element of the first (if it has one) with the first element of
%the second

%\judgment{} {\(t \cdot T = T\)}
%\judgment{\(T_1 \cdot T_2 = T\)}{\(tT_1 \cdot T_2 = tT\)}
%\leo{Lemma/theorem: split/join = id?}
%\leo{TODO: FORMATTING: Remove force line break/par at end of judgments}

We will frequently take a prefix of the trace from an initial state up
through the first state where some condition holds on the machine state.
This can easily be implemented using \(\PUT\), and we provide special notation
for convenience.
%
Let \(f\) be a predicate on machine states. Then we define \(\mach
\hookrightarrow \machT | f\) (read ``\(\machT'\) is the prefix of
running \(\mach\) up to \(f\)''):
  
\judgmenttwo{\(\mach \hookrightarrow \machT\)}
            {\(\PUT(\lambda (\mach',\obs).f\ \mach',\machT)
              = \machT'\)}
            {\(\mach \hookrightarrow \machT' | f\)}
\noindent
And similarly for traces with policies:
  
\judgmenttwo{\(\mpstatename \hookrightarrow \MPT\)}
            {\(\PUT(\lambda \mpostate{\mach}{\pol}{\obs}.f(\mach),\MPT) = \MPT'\)}
         {\(\mpstatename \hookrightarrow \MPT' | f\)}

%    \COQ{this operation steps until it reaches a state on which \(f\) holds,
%    and is infinite if it doesn't. It doesn't compute the observation of the step after the final,
%    which coq would. So coq may need a ``step until'' relation rather than ``prefix up to''.
%    Still thinking about this.}\leo{So this is strictly weaker than the one we have in Coq, right?
%      So its only the Eager implies Lazy direction that might need tweaking, but not the Test implies Eager one?}
%    \leo{Also, it steps until it reaches an f-state or if the policy raises a fault}

\paragraph*{Observational Equivalence}

We say that a trace of observations $\obsT_1$ is a prefix of $\obsT_2$
\leo{Benjamin suggested ``as far as an attacker is conerned in an
  e-mail, but we haven't said anything about attackers yet.}, if the
sequence of non-silent observations of $\obsT_1$ is a prefix of those
of $\obsT_2$; that is we operate up to deletion of \(\tau\)
observations, coinductively:

\leo{TODO: We really need a better layout than centered paragraphs.}
\judgment{}{\(\obsT \lesssim \obsT\)}

\judgment{}{\(\tau \lesssim \obsT\)}
\judgment{}{\(w \lesssim w\obsT\)}

\judgment{\(\obsT_1 \lesssim \obsT_2\)}
         {\(\tau \obsT_1 \lesssim \obsT_2\)}

\judgment{\(\obsT_1 \lesssim \obsT_2\)}
         {\(\obsT_1 \lesssim \tau \obsT_2\)}

\judgment{\(\obsT_1 \lesssim \obsT_2\)}
         {\(w\obsT_1 \lesssim w\obsT_2\)}

% Fixed by Andrew:
%\COQ{This is the same as the coq version minus a redundant case.}

We then define equivalence of observation traces as traces prefixing each other:
\[O_1 \simeq O_2 \triangleq O_1 \lesssim O_2 \land O_2 \lesssim O_1\]

\leo{Rephrase transition. I hate it:} There are two interesting things
to note.  First, observation trace equivalence could alternatively be
defined as the prefix relation but dropping the only assymetric rules
\leo{2 + 3. TODO: name rules?}

\leo{Also rephrase this.}
Second, an infinite silent trace is a prefix of (and equivalent to)
any other trace. While this might seem surprising at first, it makes
sense in a timing-insensitive context: an external observer looking
at two machine runs cannot distinguish between a machine that
steps forever or a machine that steps for a long time before producing
some output, before that time has passed.

%Let the predicate \(\isinf(T)\) hold when the trace $T$ is infinite.
%We then define {\em policy-sensitive observational equivalence}: a
%trace $\MPT \in \MPOTRACE$ is equivalent to a trace $\machT \in
%\MOTRACE$ if (1) \(\MPT\) is infinite and the observations of \(\MPT\)
%and \(\machT\) are equivalent, or (2) if the \(\MPT\) is finite (due to a
%policy fault) and its observations are a prefix of those of M.
% 
%% Fixed by Sean
%%\leo{Why $\mathit{Obs}$ and not $\pi_o$ defined earlier?}
%\judgmenttwo{\(\neg \isinf(\MPT)\)}{\(\pi_o(\MPT) \lesssim \pi_o(\machT)\)}
%            {\(\MPT \sim_P \machT\)}
% 
%\judgmenttwo{\(\isinf(\MPT)\)}{\(\pi_o(\MPT) \simeq \pi_o(\machT)\)}
%            {\(\MPT \sim_P \machT\)}

\section{Stack Safety, Formally}

In this section we will describe stack safety as a formal property. We
begin with our model of knowledge about the program structure\leo{I
  hate this}, and then dive in to local state encapsulation and
well-bracketed control flow. 

\subsection{Program Structre}

Our properties and policies are parameterized by several types of
annotations describing features of a program. A {\em code map}
identifies some addresses as code and assigns each to a function. A
{\em call map} identifies addresses that complete a call sequence,
abstracting away from any concrete calling convention. Likewise a {\em
  return map} identifies addresses that complete a return sequence. An
{\em entry map} identifies valid entry points to a function.

Formally a code map is a partial function from addresses to a function
identifier drawn from the set \(\FUNIDS\).
  %
\[\codemap \in \CODEMAPS = \WORDS \rightharpoonup \FUNIDS\]

A call map is a partial function from addresses to a natural number,
the number of arguments of the call.
  %
\[\callmap \in \CALLMAPS = \WORDS \rightharpoonup \mathbb{N}\]

For concreteness, in a typical calling convention, a call map may be
considered to identify the state just before the \(\JAL\), in which
space for arguments is already allocated, but the mechanism is more
general. A state in which a call map is defined on the program counter
is referred to as a {\it call state}.
  
A return map is simply a predicate on addresses and may be considered
to identify the final jump of the return sequence. An entry map is
likewise a predicate on addresses.
  %
\[\retmap \in \RETMAPS \subseteq \WORDS\]
\[\entmap \in \ENTMAPS \subseteq \WORDS\]

\paragraph*{What is a return?}

We separately identify, for any call state, what is means for a state
to have correctly returned from a call. We consider the call to have
returned the first time control returns to the instruction following
the \(\JAL\) with the stack restored. Formally this is a relation
between the states:
    
\[\begin{split}
    \ret{\mach_c}\ \mach_r \triangleq & \mach_r(\PCname) =
    \nextPC(\mach_c(\PCname)) \land \\ & \mach_r(\SP) = \mach_c(\SP)
\end{split}\]

\subsection{Local State Encapsulation}
\label{sec:lse}
  
The first part of stack safety is {\em local state encapsulation}.
Informally, it captures the notion that a caller's data is
protected from a callee's actions. We formalize this notion
as a security property with an integrity and a confidentiality
component, where the former protects the caller's data from being
written and the latter from being read.

As is standard with security properties, we associate with each
component of the machine a {\em label}: a pair of security levels
denoting high or low confidentiality and high or low integrity.
%
\[\mathit{label} ::= \{\HIGHSEC,\LOWSEC\} \times \{\HIGHINT,\LOWINT\}\]
%
In a traditional setting, integrity would enforce that the contents of
$\HIGHINT$ locations remain unchanged, while confidentiality would
enforce that the contents of $\HIGHSEC$ locations don't influence the
observable behavior. However, when dealing with nested calls and
returns, stack safety needs to enforce integrity and confidentiality
for {\em every} function call in a trace; that is, we must treat the
security level of data dynamically.
%
To that end, we introduce the notion of a {\em contour}, a map from
components to labels:
%
\[\contour \in \CONTOURS ::= \COMPONENTS \rightarrow \mathit{label}\]

When \(\mach_c\) is a call state \(\callmap(\mach(\PCname)) = n\) for
some \(n\) and \(\mach_c \stepstoobs{\obs} \mach_e\), we can construct
a contour based on the bounds of the callee's stack frame.
%
The private state of the callee is the entire area of the memory from
stack base to stack pointer, with the exception of the $n$ locations
corresponding to the arguments of a call. Private components are
marked high confidentiality and high integrity: the callee should be
able to neither read, nor write them.
%  
Everything above the stack pointer at the point of the call is
``uninitialized'' memory that can be written into but should not be
read. To protect the callee itself from such reads, these components
are marked high confidentiality and low integrity.
%
Special care is needed for the code memory corresponding to the
callee: they are marked low confidentiality if they belong to the
callee and high confidentiality otherwise; regardless they are always
high integrity.\leo{That would mean we scramble some instructions, I
  guess that makes sense.}
%
Finally, registers and the frame of arguments to the callee are free
for the callee to use, and are therefore tagged with low integrity and
low confidentiality.

 \[\mathit{Cof}(\mach,\funid,n)(\component) =
  \begin{cases}
    (\LOWSEC,\HIGHINT) & \text{if } \component \in \WORDS
                         \text{ and for some } \funid, \codemap(\component) = \funid \\
    (\HIGHSEC,\HIGHINT) & \text{else if } \component \in \WORDS
                          \text{ and } \component \leq \mach(\SP) - n \\
    (\HIGHSEC,\LOWINT) & \text{else if } \component \in \WORDS
                         \text{ and } \component \geq \mach(\SP) \\
    (\LOWSEC,\LOWINT) & \text{else} \\
  \end{cases}\]

\paragraph*{Stack Integrity}

The first component of local state encapsulation is an integrity
property: it ensures that the caller's data is never overwritten by a
callee. We will formally define integrity in two steps: first, we will
define integrity as a trace property over the trace corresponding to a
single call (from its entry point to its corresponding return), and
then we will lift that to a property for every such subtrace of a
callee.

\definition{Trace Integrity}
\label{def:trace-integrity}
Let $\contour$ be a contour and $MP$ be a (potentially infinite)
$\MPOTRACE$. We will say $MP$ satisfies {\em trace integrity} with
respect to $\contour$ if its final state (if any) agrees with its
initial one on all components marked $\HIGHSEC$ in $\contour$:
%
\[
\mathit{int} ~ \contour ~ MP \triangleq
\left \{ \begin{array}{ll}
  \mathit{True}, & \text{if $MP$ is infinite}\\
  \forall \component. ~ \contour(\component) = \HIGHSEC \rightarrow m_0(\component) = m_f(\component), & \text{otherwise} \\
\end{array}
\right .
\]
\leo{TODO: DISCUSS: Figure out notation for first/last machine state in a trace}

Intuitively, the caller expects to find their private data untouched
after the callee returns. That means that if the callee never returns,
integrity is trivially satisfied. Similarly, the callee is allowed to
temporarily overwrite these locations, as long as they are restored
once control returns. We will see variations of this later on: a
stronger, inductive integrity property that ensures that the caller's
private data is never overwritten, even during the caller's execution
(a variation that leads to easier reasoning and more effective testing);
and a weaker, lazy integrity property that only ensures that the
locations that a caller accesses are preserved (a variation that allows
for a more efficient enforcement mechanism).

Trace integrity characterizes the trace corresponding to a single
callee. We now lift this definition to an integrity property for a
complete execution trace. We do this by requiring that trace integrity
holds for every transition between a caller and a callee $f$ for
the entirety of the trace of $f$.

\definition{Transition}
Given a trace $MP$, a call map $\callmap$ and a code map $\codemap$,
an $n$-{\em transition} to a callee $f$ is a pair of machine-policy
state pairs $(\mach_c, \pol_c)$ and $(\mach_e, \pol_e)$ in the trace
such that:
\begin{itemize}
\item one state pair steps to the other: 
  $$\exists \obs. ~ (\mach_c, \pol_c) \stepstoobs{\obs}_P (\mach_e, \pol_e),$$
\item $\mach_c$ is a valid call with $n$ arguments:
  $$\callmap(\mach_c(\PCname)) = n,$$
\item and $\mach_e$ is an entry point for $f$:
  $$\codemap(\mach_e(\PCname)) = f.$$
\end{itemize}

\definition{Stack Integrity}
Let $\callmap$ be a call map and $\codemap$ a code map. We say that a
system satisfies {\em stack integrity} with respect to $\callmap$ and
$\codemap$ if, for every initial machine-policy state pair $(\mach_0,
\pol_0)$ and its induced trace $MP$, and every $n$-transition
$(\mach_c, \pol_c)$ and $(\mach_e, \pol_e)$ to a callee $f$ in $MP$,
the prefix $MP_{pre}$ of $MP$ from $(\mach_e, \pol_e)$ until the first
return corresponding to $\mach_c$ (if any) satisfies trace integrity
with respect to the contour at the call:
%
$$\forall MP_{pre}. ~ \mpstate{\mach_e}{\pol_e} \hookrightarrow_P
MP_{pre} ~ | ~ \ret{\mach_c} \rightarrow
\mathit{int}~\mathit{Cof}(\mach_c, f, n)~MP_{pre}$$

\paragraph*{Stack Confidentiality}

The second component of local state encapsulation is a confidentiality
property: just like integrity ensures that a caller's data is never
overwritten by a callee, confidentiality ensures that it never
influences its observable behavior. We will formally define
confidentiality in two similar steps: a trace version and a system
version.

Unlike integrity, confidentiality is a noninterference-style property,
comparing the behavior of a machine with an arbitrary variant that
preserves low confidentiality data.

\definition{Variations}
We say two machine states $\mach$ and $\mach'$ are {\em variations} of one
another given a contour $\contour$ if they agree on low
confidentiality data:
%
\[
\mach \approx_\contour \mach' \triangleq \forall \component .
\contour(\component) = \LOWSEC \rightarrow \mach(\component) =
\mach'(\component)
\]
%
Then, the trace version of confidentiality operates on two traces: the
``original'' one $MP \in \MPOTRACE$ that corresponds to a callee $f$
and a ``variant'' one $M \in \MTRACE$ that would corresponding to $f$
if it started from a variant initial machine state.

\definition{Trace Confidentiality}
\leo{Add info for ``valid return'':}
We will say two traces $MP$ and $M$ satisfy {\em trace
  confidentiality} with respect to $\contour$ if:
\begin{itemize}
\item If $MP$ is finite and its final state $\mach_r$ is a valid
  return, then $M$ is also finite with some final state $\mach_r'$ and
  any changes from the initial states have changed in the same way:
$$\forall \component. ~ \mach_e(\component) \not = \mach_r(\component)
  \vee \mach_e'(\component) \not = \mach_r'(\component) \rightarrow
  \mach_r(\component) = \mach_r'(\component)$$
  In addittion their observations must be equivalent:
  $$\pi_o(MP) \eqsim \pi_o(M)$$
\item If $MP$ is infinite, then $M$ is also infinite and their
  observations are equivalent:
  $$\pi_o(MP) \eqsim \pi_o(M)$$  
\item If the $MP$ ends prematurely with a policy fault, then
  we require that its observations are a prefix of those of $M$:
  $$\pi_o(MP) \lesssim \pi_o(M)$$
\end{itemize}

\leo{Discuss variations in a similar manner}

To lift trace confidentiality to a system property, we follow the same
pattern as in stack integrity:

\sna{Version for stepping from a state}
\definition{Confidential Execution}
  Stack confidentiality, below, is a property of a system that, from a call to
  a return, each trace obeys a local confidentiality property,
  {\it confidential execution}.

  We will say that a state \(\mpstate{\mach}{\pol}\) satisfies confidential
  execution with regard to a contour \(\contour\) and an ending condition
  \(R\) that is a predicate on machine states if, for all variant states
  \(\mach' \approx_\contour \mach\), the induced traces from \(\mach\) and
  \(\mach'\) behave the same across three cases. Let
  \(\mpstate{\mach}{\pol} \hookrightarrow \MPT | R\) and
  \(\mach' \hookrightarrow \machT | R\).
  
  If \(\MPT\) ends with a state \(\mach_r\) and \(R\ \mach_r\), then \(\machT\)
  ends with a state \(\mach_r'\) such that \(R\ \mach_r'\). \(\MPT\) and
  \(\machT\) are observationally equivalent, and for each component
  \(\component\) such that \(\contour(\component) = \HIGHSEC\),
  \(\mach_r(\component) = \mach_r'(\component)\).

  If \(\MPT\) is infinite, then \(\machT\) is infinite, and they are
  observationally equivalent.

  If \(\MPT\) ends before \(R\) ever holds, meaning that it halted due to a
  policy violation, then it is a strict observational prefix of \(\machT\),
  which must be infinite.
  
\definition{Stack Confidentiality}
Let $\callmap$ be a call map and $\codemap$ a code map. We say that a
system satisfies {\em stack confidentiality} with respect to
$\callmap$ and $\codemap$ if, for every initial machine-policy state
pair $(\mach_0, \pol_0)$ and its induced trace $MP$, and every
$n$-transition $(\mach_c, \pol_c)$ and $(\mach_e, \pol_e)$ to a callee
$f$ in $MP$, the prefix $MP_{pre}$ of $MP$ from $(\mach_e, \pol_e)$
until the first return corresponding to $\mach_c$ (if any) satisfies
trace integrity with respect to every similarly prefixed machine trace
of every variation $\mach_e'$ with the contour at the call:
$$\forall MP_{pre} ~ M_{pre}. ~
\mpstate{\mach_e}{\pol_e} \hookrightarrow_P MP_{pre} ~ | ~ \ret{\mach_c} \rightarrow$$
$$\forall \mach_e'. ~ \mach_e \approx_{\mathit{Cof}(\mach_c, f, n)} \mach_e' \wedge
\mach_e' \hookrightarrow M_{pre} ~ | ~ \ret{\mach_c} \rightarrow$$
$$\mathit{conf}~\mathit{Cof}(\mach_c, f, n) ~ MP_{pre} ~ M_{pre}$$

\subsection{Well-bracketed Control Flow}
\label{sec:wbcf}

Our integrity and confidentiality properties concern themselves with
data, and may hold on a wide range of programs that violate expected
control flow.  But well-bracketed control flow prevents this style of
attack by guaranteeing that every jump between functions is either a
call or a return, and each return jumps to the instruction after a
corresponding call.

\leo{Also dumping in relevant wbcf discussion part. TODO: merge}  
    Some forms of security rely on protected control flow. In a classic
    example, a system call that launches a missile might be gated behind code
    that checks a password. A piece of malicious code can jump into the middle
    of the sequence and execute the system call without the appropriate password,
    and still obey integrity if the malicious code never returns to its caller.
    Integrity here protects data, not privileges. But such a jump does violate
    eager stack confidentiality if the attacker jumps beyond its own function's
    instructions without performing a designated call or returning to an
    appropriate site.

    A jump to a function's own code does not violate either, even if done using
    nefarious means such as return-oriented programming (ROP). Our model would
    permit such a jump within the function, so privilege is not elevated by
    permitting ROP in this case.

    But, our policies do enforce orthogonal control flow properties that
    protect from calls that enter outside of valid entry points and from all
    invalid returns, even if they would not escalate privilege. Most notably
    {\em well-bracketed control flow}, below.



\definition{Control Separation}
A system enjoys {\em control separation} with regard to a code map
\(\codemap\), a call map \(\callmap\), and a return map \(\retmap\) if
for any initial state \(\mach_0\) and any adjacent pair of states
\(\mach_1\) and \(\mach_2\) in the induced trace from
\(\mpstate{\mach_0}{\pinit(\mach_0)}\), if
\(\codemap(\mach_1(\PCname)) \not = \codemap(\mach_2)\), then either
\(\callmap(\mach_1(\PCname)) = n\) for some \(n\), or
\(\retmap(\mach_1)\).

\definition{Entry Integrity}
A system enjoys {\em entry integrity} with regard to a call map
\(\callmap\) and entry map \(\entmap\) if for any initial state
\(\mach_0\) and any adjacent pair of states \(\mach_c\) and
\(\mach_e\) in the induced trace from
\(\mpstate{\mach_0}{\pinit(\mach_0)}\), if
\(\callmap(\mach_c(\PCname)) = n\) then \(\entmap(\mach_e)\).

\definition{Return Integrity}
Return integrity captures the expected behavior of marked returns with
regard to their call points. We begin by defining a coinductive
relation \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT_1
\MPT_2\). Given a call map \(\callmap\) and return map \(\retmap\),
\(\MPT\) is related to \(\MPT'\) if \(\MPT'\) is a suffix of \(\MPT\)
whose head is the first unmatched return in \(\MPT\). So if \(\MPT\)
starts with a return, it is related to itself:

  \judgmenttwo{\(\callmap(\mach(\PCname)) = \bot\)}
           {\(\retmap(\mach(\PCname))\)}
      {\(\mathit{Unmatched}\ \callmap\ \retmap\ \mpstate{\mach}{\pol}\ 
        \mpstate{\mach}{\pol}\)}
  \judgmenttwo{\(\callmap(\mach(\PCname)) = \bot\)}
              {\(\retmap(\mach(\PCname))\)}
      {\(\mathit{Unmatched}\ \callmap\ \retmap\ \mpstate{\mach}{\pol}\MPT\ 
              \mpstate{\mach}{\pol}\MPT\)}

If \(\MPT\) starts with a non-call, non-return state, its unmatched
return must come later:

  \judgment{\(\callmap(\mach(\PCname)) = \bot
              \hspace{.5cm} \neg \retmap(\mach(\PCname))

              \mathit{Unmatched}\ \callmap\ \retmap\ \MPT\ \MPT'\)}
           {\(\mathit{Unmatched}\ \callmap\ \retmap\ 
            \mpstate{\mach}{\pol}\MPT\ \MPT'\)}

And most intricately, if \(\MPT\) starts with a call, we must find the
return that matches it, which will be the unmatched return once we
step past the call. Then the first unmatched return beyond it is the
true unmatched return.
    
    \judgment{\(\callmap(\mach(\PCname)) = n
              \hspace{.5cm} \neg \retmap(\mach(\PCname))\)

              \(\MPT = \mpstate{\mach}{\pol} \MPT_{\mathit{call}}\)
              
              \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT_{\mathit{call}}\ \MPT_{\mathit{matched}}\)
            
              \(\MPT_{\mathit{matched}} = \mpstate{\mach'}{\pol'} \MPT_{\mathit{tail}}\)

              \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT_{\mathit{tail}}\ \MPT_{\mathit{unmatched}}\)}
            {\(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT\ \MPT_{\mathit{unmatched}}\)}

A system enjoys {\em return integrity} with regard to a call map
\(\callmap\) and return map \(\retmap\) if for any initial state
\(\mach_0\) and any call state and policy state \(\mach_c\) and
\(\pol_c\) in the induced trace from
\(\mpstate{\mach_0}{\pinit(\mach_0)}\), if \(\mpstate{\mach_c}{\pol_c}
\hookrightarrow_P \MPT\) and \(\mach_r\) is the first unmatched
return, with \(\mathit{Unmatched}\ \callmap\ \retmap\ \MPT \ \MPT'\)
and \(\mach_r\) the first machine state of \(\MPT'\), then
\(\ret{\mach_c}\ \mach_r\).

\definition{Well Bracketed Control Flow}
The above properties are somewhat orthogonal, but together they
capture a standard notion of control flow for a stack: functions keep
their code separate outside of calls and returns, calls respect
explicit entry points, and returns respect implicit entry points
corresponding to their call.  A system that enjoys them with regard to
a code, a call, a return, and an entry map is said to enjoy {\em well
  bracketed control flow} with regard to those maps.

\section{Discussion}

  \paragraph{Examples}

  \bcp{Illustrate the definition by using it to discuss a range of ``stack
    unsafety'' examples from the literature. }

  \paragraph{What about tail recursion and other non-stack-like control flow}

  \paragraph{Adding Heap Safety}

    While these ideas are here presented in a stack-centric style, they could
    be extended to heap safety in a system extended with a heap. Heap safety,
    like stack safety, may be framed as a form of noninterference
    [cite Meaning of Memory Safety]. For each certain component marked as
    containing a valid pointer to a heap object, we can propagate that
    validity when the pointer moves or is used in pointer arithmetic. Heap
    objects to which a valid pointer is in a register are reachable, and
    treated as low confidentiality and low integrity.

\section{Lazy Stack Safety}

    \definition{Observable Integrity}
      Observable integrity weakens eager integrity by allowing a returned state
      to differ from its call state at high integrity components, provided the
      observable behavior of the induced trace from the return matches that of
      an idealized state whose high integrity components do match the call
      state.

      Given a contour, a call state, and a returned state, we define a
      ``rollback'' function \(\mathit{roll} : \CONTOURS \times \MACHS \times
      \MACHS \rightarrow \MACHS\). The rollback returns a state that matches
      the call state on those components that are high integrity in its
      contour, and matches the return state on low integrity components:
      \[\mathit{roll}(\contour,\mach_c,\mach_r)(\component) =
      \begin{cases}
        \mach_c(\component) & \contour(\component) = (\HIGHINT,\_) \\
        \mach_r(\component) & \contour(\component) = (\LOWINT,\_) \\
      \end{cases}\]

      Intuitively, the result of a rollback is an idealized state that
      reflects changes to accessible components, but ignores the callee's
      interference with the caller's data. Then the observable behavior of the
      resulting trace is the standard to which we expect the real trace to
      conform.

      A system enjoys observable integrity with regard to \(\callmap\) and 
      \(\codemap\) if for any initial state \(\mach_0\) and each adjacent pair
      of a call state \(\mach_c\) and a state \(\mach_e\) with policy state
      \(\pol_e\) in the trace induced by
      \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\) where
      \(\callmap(\mach_c) = n\) and \(\codemap(\mach_e) = \funid\),
      if \(\mpstate{\mach_e}{\pol_e} \hookrightarrow \MPT | \ret{\mach_c}\)
      with the return state \(\mach_r\) at the end of \(\MPT\), then the
      following holds.

      Let \(\contour = \mathit{Cof}(\mach_c,\funid,n)\) describe the security
      levels of the call and
      \(\mach_r' = \mathit{roll}(\contour,\mach_e,\mach_r)\). The induced
      traces \(\mpstate{\mach_r}{\pol_r} \hookrightarrow \MPT\) and
      \(\mach_r' \hookrightarrow \machT'\) must be equivalent up to
      possible policy failure: \(\MPT \sim_P \machT'\).

    \definition{Observable Confidentiality}
      Observable confidentiality is concerned with whether high confidentiality
      data influences observable both behavior during and after a call. As with
      eager confidentiality, we will compare the behavior of the trace induced
      by a state to another induced by its variant. But if the original returns,
      before continuing, we must reset the variant to conform with the original
      state.

      The \(\mathit{restore}\) function takes a contour and four states: the
      original call state, a variant call state, and corresponding return
      states, and returns another state. The resulting state restores those
      components that are high confidentiality to match the original call,
      unless they were changed during execution:
      \[\mathit{restore}(\contour,\mach_c,\mach_c',\mach_r,\mach_r')(\component) =
        \begin{cases}
          \mach_c(\component) & \text{if } \contour(\component) = (\HIGHSEC,\_) \text{ and } \\
                  & \mach_c(\component) = \mach_r(\component) \text{ and }
                    \mach_c'(\component) = \mach_r'(\component) \\
          \mach_r'(\component) & \text{else} \\
        \end{cases}\]

      A system enjoys observable confidentiality with respect to \(\callmap\)
      and \(\codemap\) if for any initial state \(\mach_0\), each adjacent pair
      of a call state \(\mach_c\) and a state \(\mach_e\) with policy state
      \(\pol_e\) in the inducted trace from
      \(\mpstate{\mach_0}{\mathit{pinit}(\mach_0)}\), and each variant
      \(\mach_e' \approx_\contour \mach_e'\) where
      \(\contour = \mathit{Cof}(\mach_c, \funid, n)\), one of two cases holds
      on the induced traces from \(\mach_e\) and \(\mach_e'\).

      If \(\mpstate{\mach_e}{\pol_e} \hookrightarrow_P \MPT_1 | \ret{\mach_c}\)
      with \(\MPT_1\) the trace within the callee ending with the machine state
      \(\mach_r\), the first state to return to the caller, and policy state
      \(\pol_r\), then the there is a return state \(\mach_r'\) reached by the
      trace from the variant, \(\mach_c' \hookrightarrow \machT_1 |
      \ret{\mach_c}\). Let \(\mach_r'' = \mathit{restore}(\contour,\mach_e,
      \mach_e',\mach_r,\mach_r')\), and let the induced traces from the
      returned states be \(\mpstate{\mach_r}{\pol_r} \hookrightarrow_P \MPT_2\)
      and \(\mach_r'' \hookrightarrow \machT_2\). With the callee and caller
      traces joined, the traces are observationally equivalent up to policy
      failures: \(\MPT_1 \cdot \MPT_2 \sim_P \machT_1 \cdot \machT_2\).

      The case in which the induced trace does not return is the same as in the
      eager property: the variant trace also does not return, and the induced
      traces are observationally equivalent up to policy failure.

    \definition{Observable Stack Safety}
      A system enjoys {\em observable stack safety} with regard to a call map
      and a code map if it enjoys both observable integrity and observable
      confidentiality with regard to them.


\section{Related Work}
\label{sec:relwork}

\section{Future Work}
\label{sec:future}

We've assumed that callees always have less access than their callers, but
in real systems things are more complicated (because of objects, static
variables in C, software compartmentalization, coroutines, ...).  What we've
defined is a very ``pure'' variant of stack safety.  In future work, we
should go further. :-)


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
%\bibliography{bcp.bib}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
