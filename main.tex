\documentclass[conference]{IEEEtran}
\input{macros}

\begin{document}

\title{Interfering with Noninterference
\iftext\thanks{\bcp{Identify applicable funding agencies here (DARPA and NSF
    and...?)}}\fi
}

\iftext
\IEEEauthorblockN{Leonidas Lampropoulos}
\IEEEauthorblockA{\textit{University of Maryland \bcp{right?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\author{\IEEEauthorblockN{Roberto Blanco}
\IEEEauthorblockA{\textit{\bcp{affiliation?}}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
\and
\IEEEauthorblockN{Benjamin C. Pierce}
\IEEEauthorblockA{\textit{University of Pennsylvania}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
  }
\and
\IEEEauthorblockN{Andrew Tolmach}
\IEEEauthorblockA{\textit{Portland State University}
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID
}
}
\fi

\maketitle

\iftext
\begin{abstract}
\end{abstract}

\begin{IEEEkeywords}
% component, formatting, style, styling, insert
\end{IEEEkeywords}
\fi

\iftext
\section{Introduction}

\bcp{How about coining the term ``lockstep noninterference'' and then saying
that we study several variants...?}

\fi

\section{Preliminaries}

\subsection{Machine model}

Concretely, we have in mind a conventional machine architecture with a
RISC-V processor, perhaps extended with some kind of hardware-enforced
security policy, but we won't need any RISC-V-specific details till we get
to \cref{impl}.

Conventions:
%
\begin{itemize}
\item Words / addresses: $\word,\addr \in \WORDS$
\item Registers: $\reg \in \REGS$
\item Machine components: $\component \in \WORDS \cup \REGS \cup \{
\textsc{pc} \}$
\item Machine states: $\mach \in \MACHS = \COMPONENTS\rightarrow\WORDS$
\end{itemize}

% \bcp{Now we need to define {\em property} formally.  But since we're talking
% about hyperproperties, I'm not certain how to go about it.  The standard way
% would be something like ``A policy $P$ has property $Q$ (i.e., $P$ is
% noninterfering) if, for every pair of traces $\trace{M}$ and $\trace{M'}$
% in $P \times P$, if the initial states $M_0$ and $M'_0$ differ only in
% high parts then every pair ...'' (blah: I'm not sure whether to talk about
% lockstep-corresponding states, which seems too restrictive, or final states,
% which doesn't work if the traces are infinite!  do we really need some kind
% of reactive noninterference here?? Urg.)  (Well, no, we can just do
% a flavor of termination-insensitive NI, which says that all infinite traces
% are indistinguishable from anything...?)}

% \bcp{Should we start from a notion of ``variant traces'' and then talk about
% pairs of variant traces being ``distinguishable'' and then go to the full
% thing?}

The {\em underlying} step function, $\mathord{\stepstounderfull} \in \MACHS
\rightarrow \MACHS$, embodies the standard RISC-V ISA semantics.

% \bcp{Needed?}A {\em trace} $\trace{M}$ is a nonempty, finite or infinite
% sequence of machine states $\mach_0, \mach_1, \mach_2, ...$ such that
% $\mach_{i-1} \stepsto \mach_i$, for each $i \geq 1$.

\subsection{Policies}

Intuitively, we use the word {\em policy} for any kind of dynamic
enforcement mechanism (e.g., a runtime taint tracker, heap coloring rules,
capability hardware, etc.). We use {\em property} for a mathematical
predicate on programs (i.e., machine states) articulating some useful
security goal, e.g. noninterference.

A {\em contour}
$\contour \in \CONTOURS = \COMPONENTS \rightarrow \{\HIGH,\LOW\}\times
\{\OBS,\HIDDEN\}$ is a map from machine components to pairs of ``security
levels,'' where $\HIGH$ marks locations containing secret or low-integrity
data and $\LOW$ marks those with public or high-integrity data, and
``observabilities,'' where $\OBS$ marks locations whose contents are
observable from the outside (by the ``attacker'') and $\HIDDEN$ marks
internal ``hidden'' state that cannot be observed directly.

Informally, a (micro-){\em policy}
is an enriched
step function that works on pairs of contours and machines---i.e., it is a
partial function taking a contour and a machine state to an updated contour
and machine state that, wherever is is defined, agrees with
$\stepstounderfull$.  That is,
it represents an enforcement mechanism that sometimes halts programs earlier
than the bare step relation does, but that agrees with the bare step
relation when it allows evaluation to proceed.  We write
$(\contour_1,\mach_1) \stepstounder{\pol} (\contour_2,\mach_2)$ for
$\pol(\contour_1,\mach_1) = (\contour_2,\mach_2)$.

Formally, a policy
%
$\pol \in \CONTOURS \rightarrow \exists X.\; X \times (\MACHS \times X
\rightharpoonup \MACHS \times X)$
%
 is a function that takes a contour to
\begin{enumerate*}
  \item a private type $X$,
  \item an initial value of $X$, and
  \item a partial step function of type
  $(\MACHS \times X) \rightharpoonup (\MACHS \times X)$ that, when defined,
  agrees with $\stepstounderfull$ on machine states.
\end{enumerate*}
That is, a policy takes a starting contour and produces a runtime monitor
that carries along some private information and uses it to decide whether to
terminate execution early.




Given a machine state $\mach$ and a contour $\contour$, a {\em variant} of
$\mach$ with respect to $\contour$ is any machine state $\mach'$ whose
components agree with $\mach$ on all components marked $\LOW$ by
$\contour$---i.e., if $\contour(\component) = (\LOW$,\,\underscore), then
$\mach(\component) = \mach'(\component)$.



\bcp{
  \begin{itemize}
  \item A {\em property} is a function that takes a contour to a
  prefix-closed set of (finite and/or infinite) sequences of machine states.
  That is, it takes a starting contour and produces a checker that tells
  whether a given trace is OK to observe.
  \item A policy $p$ {\em guarantees} a property $P$ if, for each contour
  $\contour$, the sequence of machine states obtained by projecting the
  sequence of ..... ARGH WHAT ABOUT VARIANTS!?!
  \item Proposal: Forget about full-blown NI and make the whole paper be
  about ``lockstep NI'' where the PC is the same in every pair of
  related runs
  \begin{itemize}
  \item One issue that I am not sure about: Could there be a sneaky way of
  ``putting secret information into the control state'' where the PCs of
  related runs are always in lockstep but, because the instruction memory is
  writeable, different instructions can get dispatched.  E.g., XXXX
  \item So maybe we should be asking that the instruction stream be
  identical, not (just?) the PCs
  \item One nice observation is that, if we are only interested in pairs of
  runs with identical PCs, there are two different ways to proceed: (1) say
  that we {\em ignore} runs where the PCs (or instruction streams) diverge
  (e.g., taint tracking), or (2) {\em disallow} runs where the PCs (or
  instruction streams) diverge, i.e., demand that this never happens (e.g.,
  stack and heap policies).
  \end{itemize}
  \item A remaining question is what to do about the possibility that the
  contour changes differently on two related runs.  We could disallow this,
  but not certain it's necessary---maybe everything works out OK.
  \end{itemize}
}


The {\em observation trace} arising from a finite or infinite sequence of
contours and machine states
$(\contour_0,\mach_0),\, (\contour_1,\mach_1),\ldots$, written
$\obstrace((\contour_0,\mach_0),\, (\contour_1,\mach_1),\ldots)$ is a
partial map taking each machine component to the (finite or infinite)
sequence of {\em distinct} values taken on by this component at moments when
it is {\em observable}.  Formally, this map can be constructed as
follows. For each component $\component$,
%
(1) if
$\contour_i(\component) = (\underscore,\HIDDEN)$ for all $i$, then
$\obstrace(\component) = \bot$;
%
and otherwise (2), $\obstrace(\component)$ is a sequence whose first element
is $\mach_i(\component)$ for the smallest $i$ such that
$\contour_i(\component) = (\underscore,\OBS)$ and whose $(m+1)^{th}$ element
(if any) is $\mach_j(\component)$, where $j$ is the smallest index greater
than the index $i$ of the $m^{th}$ element and such that
$\contour_j(\component) = (\underscore,\OBS)$ and
$\mach_j(\component) \neq \mach_i(\component)$.
%
\iftext
\bcp{Unfinished and horrible...  But maybe the textual description is OK?}
\newcommand{\aux}{\mathit{aux}}
\bcp{Don't like the ``rest'' argument and the fact that we don't
  have a metavariable for sequences of pairs of contours and machines.
  Consider defining one.}
%
\[
\begin{array}{lcl}
\aux \; ( [\,] ) \; \trace& = & \trace
\\
\aux \; ( (\contour,\mach) \mathrel{::} \mathit{rest} ) \; T
  & = &
        \aux \;( \mathit{rest} )
        \\ && \quad (\lambda k.\; \mbox{\bcp{and so on}}
\\
\\
\obstrace \;( (\contour_0,\mach_0),\, \ldots )
  &=& \aux \; ( (\contour_0,\mach_0),\, \ldots ) \; (\lambda
      \component.\, \bot)
\end{array}
\]
\fi

\subsection{Noninterference}

If $\mach$ and $\mach'$ are variant machine states with respect to contour
$\contour$, then $\mach$ and $\mach'$ are said to be {\em indistinguishable}
under policy $\pol$ if their observable
%
$\obstrace(
                      (\contour,\mach)
  \stepstounder{\pol} (\contour_1,\mach_1)
  \stepstounder{\pol} (\contour_2,\mach_2)
  \stepstounder{\pol} \ldots)$
%
yields the same trace as
$\obstrace(
                      (\contour,\mach')
  \stepstounder{\pol} (\contour_1,\mach_1')
  \stepstounder{\pol} (\contour_2,\mach_2')
  \stepstounder{\pol} \ldots)$.

% either (1) one or both of $(\contour,\mach)$ and
% $(\contour,\mach')$ fail to terminate when executed with
% $\stepstounder{\pol}$, or (2) both terminate and the machine-state
% components of their results are variants with respect to the original
% $\contour$.

Policy $\pol$ {\em guarantees noninterference} if, for every $\contour$,
every pair $(\mach,\mach')$ of variant machine states with respect to
$\contour$ are indistinguishable under $\pol$.

\iftext
\begin{itemize}
\item \bcp{Should we be talking about end-to-end or single-step NI?  I guess we
  have to begin with EENI and then get to SSNI as a (stronger) refinement.}

\item Relation to the standard definition of NI.

\item Fact: The standard RISC-V semantics does not guarantee NI.  (Give a
little example of a program that reads from a secret location and writes to
a public one, just to illustrate the definition of NI.)
\end{itemize}
\fi

\section{Tainting is noninterference$-$}

\bcp{This needs to be written, now that we have added the hidden/observable stuff.}

\begin{itemize}
\item First intuition: A program is taint-NI if every pair of runs that don’t
branch on high data are noninterfering in the standard sense.  (i.e., they
don't write secret data to public locations and vice versa)
\item Better alternative: … for every pair of runs that take the same control path (even if they branch on tainted data)...
\item We could even go a step farther: {\em truncate} the runs at the
  first point where their PCs differ, then demand NI.  This is a less
  demanding property and probably a less desirable one, as it doesn't
  predict the behavior of actual taint policies.  Discuss.
\item Note that this is a super-simple property that doesn't really track
taint at all.
\item (Are there any other variations of tainting that we could present in
this framework?)
\end{itemize}


\section{Separation is noninterference$+$}

Presentation idea: Start here with a super-simple separation policy, which
just makes some part of the address space inaccessible, truncating any
traces that read or write it.  Formulate the property as a flavor of NI.
(The $+$ part in the title is a hint that one thing that gets added is that
the PCs of corresponding traces always stay in lock step.)

\section{Stack protection is noninterference$++$}

\begin{itemize}
\item
  Idea of accessibility: set of data memory addresses that can legally be read or written at a particular execution point.
  (Assume instruction memory is distinct.)
\item
  Stack protection intuition in a nutshell: caller's memory data is not accessible to callee, although callee's memory data is accessible to caller.
  This gives both an integrity property (callee cannot affect caller's memory) and a secrecy property
  (caller's memory cannot affect callee).
  Can generalize to other control situations, such as coroutines, threads, compartments,...
\item
  In NI terms, protected programs are oblivious to variations in memory outside of their accessible set.
  Unlike standard NI, the accessible set changes dynamically, so we cannot just frame the property in terms of
  variant start states. [Is this true? Is it a significant difference? Are there other significant differences?]
\end{itemize}

We start with a very simple (and unrealistic) set of assumptions/conventions for stack frames and procedure calls.
We assume that memory is divided into two disjoint regions, one containing the code, the other the stack.
Code begins at address 0; the stack begins at address $B$ and grows in the direction of increasing addresses.

The part of the stack between $B$ and the stack pointer \textsc{sp} is structured into a sequence of consecutive
\emph{frames}. Each frame consists of a single return address and a single word of local data.

  \begin {itemize}
  \item Memory is divided into an instruction region and a data region. The data region contains a single contiguous stack, divided into frames, each associated with a procedure activation. (The stack grows in the direction of increasing addresses.)
  \item Each frame consists of a saved return address and a single word of local data. These [both??] form the entirety of the procedure's memory data, and are the only thing we need to track when considering accessibility.
  \item Registers other than RA, SP are not affected by calls or returns and hence are the (only) way to pass values between caller and callee.
  \item Instructions serving as calls are statically marked as such in the code. [The entry and exit sequences must also be marked???]
  \item The code for each procedure is bracketed by fixed entry and exit sequences (details to follow), which save/restore the RA and
    adjust the SP. [Are these assumptions or checked facts?]
  \item During the body of the procedure, the single word of local data is accessed via SP, which does not change (except during a call, of course).  The stored RA in the frame never changes. [I'm confused about these. They are checked facts, not assumptions.]
  \end {itemize}
  In this model, the definition of accessible memory is simply all (data) memory at addresses $\geq pc$.
\begin{itemize}
\item
  Describe conjecture 2 property in terms of this model: informally and formally.
\item
  Define abstract state descriptions.
\item
  Define step consistency.
\item
  Discuss relationship between state consistency and conjecture 2 property.  (Former is: presumably stronger; hopefully not
  too strong that it produces lots of undesired test failures; surely easier to test).

\end{itemize}







\iftext
\section{Stack + heap protection too}

POTENTIALLY: Memory safety (before stack) + Conjunction of memory + stack
safety (after).

(Memory safety by itself is just arthur’s paper, but it’s cool to see how
they are combined, especially what bits can be factored out as common
structure, e.g. the notion of accessibility)
\fi

\section{Implementation}
\label{impl}

Sketch of the micropolicies that claim to implement these properties on
PIPE...

\subsection{A taint checking monitor}

\subsection{A stack safety monitor}

\section{Testing the implementations}

\begin{itemize}
\item Experimental results of testing
\end{itemize}

\section{Related work}

\begin{itemize}
\item Daniel's tainting paper (and some refs cited there)
\item Nick and Andre's papers (and other micropolicy papers)
\item StkTokens: Skorstengaard, Devriese, Birkedal
\begin{itemize}
\item {https://arxiv.org/pdf/1811.02787.pdf}
\item {https://arxiv.org/pdf/1902.05283.pdf}
\item {http://cs.au.dk/~lask/papers/esop2018.pdf}
\item {https://dl.acm.org/doi/fullHtml/10.1145/3363519}
\end{itemize}

\item Simple Noninterference by Normalization {http://nachivpn.me/nibnbe.pdf}

\item Mechanized Reasoning about a Capability Machine: [Linn] Georges,
Trieu, Birkedal (PriSC 2020).
%
Described at the Iris Workshop as formalizing the security properties of
capabilities. This appears to involve a fairly complex and very large
mechanization in Iris (also in the eyes of the Iris people).
\end{itemize}

\iftext
\section{Future work}

\begin{itemize}
\item Variations / extensions (OS, multiple processes, coroutines, generalizing depths to stacks of static call points, etc.)
\item Extending the policy / property to more realistic ones
\begin{itemize}
\item Argument passing
\item Variable-size stack frames
\item Stack variables
\item Relation to Nick and Andre’s policy
\end{itemize}
\item Could we also implement all this using Cheri capabilities?
\end{itemize}

More:
\begin{itemize}
\item More realistic calling conventions.  (We need to eventually match this to the particular calling convention of whatever compiler we choose.)  E.g., the above will not quite work for passing arguments on the stack: callee won’t be able to read them…So perhaps need to support a special kind of write instruction that stores D.PCdepth+1 . [RB: Or implement this distinction through tags?]
\item Combination with heap policy (colors, etc.)
\item For coroutines:
\begin{itemize}
\item Generalize depth to depth + PID
\item Private stuff not having changed as an idea should still work
\item Maybe not so hard: The scheduler + other coroutines are just a sort of generalized “callee” as far as this process is concerned.  Just need to fiddle th step relation so that it recognizes which process is getting returned to and updates its description appropriately.
\end{itemize}
\item If we had a heap policy, maybe we could talk about dynamic code generation, loading, as allocating a heap region, storing instructions into it, and then calling into them.  For now, we just make all the instructions read only and assume they exist in the initial state.
\item Question: how efficiently can consistency be tested? How much scrambling is needed, and does it really need to occur before every instruction? How expensive is it to check for agreement between the (in)accessible parts of two memories?  Would spot checking for agreement be adequate?]
\item What are the effects of compartmentalization on the ability of each compartment to change its own code/stack?
\item Tail calls (maybe by not marking them as call sites?)
\end{itemize}

\section*{Acknowledgments}
\fi

\section*{References}
\bibliographystyle{IEEEtran}
% \bibliography{bcp,local}

\newpage

\section*{Things to think about}

\begin{itemize}
\item
How does Nick’s stack policy actually work these days?
\item Andrew remembers that Catalin looked at something like this a long time ago and they decided that they needed unique tags for each dynamic call, not just levels.  We should check.
\end{itemize}

\end{document}
